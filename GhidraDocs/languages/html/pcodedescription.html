<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>P-Code Operation Reference</title>
<link rel="stylesheet" type="text/css" href="Frontpage.css">
<link rel="stylesheet" type="text/css" href="languages.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="pcoderef.html" title="P-Code Reference Manual">
<link rel="up" href="pcoderef.html" title="P-Code Reference Manual">
<link rel="prev" href="pcoderef.html" title="P-Code Reference Manual">
<link rel="next" href="pseudo-ops.html" title="Pseudo P-CODE Operations">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">P-Code Operation Reference</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="pcoderef.html">Prev</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="pseudo-ops.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pcodedescription"></a>P-Code Operation Reference</h2></div></div></div>
<p>
For each possible p-code operation, we give a brief description and
provide a table that lists the inputs that must be present and their
meaning. We also list the basic syntax for denoting the operation when
describing semantics in a processor specification file.
</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_copy"></a>COPY</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="copy.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Source varnode.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Destination varnode.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
Copy a sequence of contiguous bytes from anywhere to anywhere. Size of
input0 and output must be the same.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_load"></a>LOAD</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="load.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td>(<span class="bold"><strong>special</strong></span>)</td>
  <td>Constant ID of space to load from.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode containing pointer offset to data.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Destination varnode.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = *input1;</code></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = *[input0]input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This instruction loads data from a dynamic location into the output
variable by dereferencing a pointer. The &#8220;pointer&#8221; comes in two
pieces. One piece, input1, is a normal variable containing the offset
of the object being pointed at. The other piece, input1, is a constant
indicating the space into which the offset applies. The data in input1
is interpreted as an unsigned offset and should have the same size as
the space referred to by the ID, i.e. a 4-byte address space requires
a 4-byte offset. The space ID is not manually entered by a user but is
automatically generated by the p-code compiler. The amount of data
loaded by this instruction is determined by the size of the output
variable.  It is easy to confuse the address space of the output and
input1 variables and the Address Space represented by the ID, which
could all be different. Unlike many programming models, there are
multiple spaces that a &#8220;pointer&#8221; can refer to, and so an extra ID is
required.
</p>
<p>
It is possible for the addressable unit of an address
space to be bigger than a single byte. If
the <span class="bold"><strong>wordsize</strong></span> attribute of the space
given by the ID is bigger than one, the offset into the space obtained
from input1 must be multiplied by this value in order to obtain the
correct byte offset into the space.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_store"></a>STORE</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="store.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td>(<span class="bold"><strong>special</strong></span>)</td>
  <td>Constant ID of space to store into.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode containing pointer offset of destination.</td>
</tr>
<tr>
  <td align="right">input2</td>
  <td></td>
  <td>Varnode containing data to be stored.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">*input1 = input2;</code></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">*[input0]input1 = input2; </code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This instruction is the complement
of <span class="bold"><strong>LOAD</strong></span>.  The data in the variable
input2 is stored at a dynamic location by dereferencing a pointer. As
with <span class="bold"><strong>LOAD</strong></span>, the &#8220;pointer&#8221; comes in two
pieces: a space ID part, and an offset variable. The size of input1
must match the address space specified by the ID, and the amount of
data stored is determined by the size of input2.
</p>
<p>
Its possible for the addressable unit of an address
space to be bigger than a single byte. If
the <span class="bold"><strong>wordsize</strong></span> attribute of the space
given by the ID is bigger than one, the offset into the space obtained
from input1 must be multiplied by this value in order to obtain the
correct byte offset into the space.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_branch"></a>BRANCH</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="branch.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody><tr>
  <td align="right">input0</td>
  <td>(<span class="bold"><strong>special</strong></span>)</td>
  <td>Location of next instruction to execute.</td>
</tr></tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">goto input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an absolute jump instruction. The varnode parameter input0 encodes
the destination address (address space and offset) of the jump. The varnode is not
treated as a variable for this instruction and does not store the destination. Its address space and
offset <span class="emphasis"><em>are</em></span> the destination. The size of input0 is irrelevant.
</p>
<p>
Confusion about the meaning of this instruction can result because of
the translation from machine instructions to p-code. The destination of the jump is
a <span class="emphasis"><em>machine</em></span> address and refers to
the <span class="emphasis"><em>machine</em></span> instruction at that address. When
attempting to determine which p-code instruction is executed next, the
rule is: execute the first p-code instruction resulting from the
translation of the machine instruction(s) at that address. The
resulting p-code instruction may not be attached directly to the
indicated address due to NOP instructions and delay slots.
</p>
<p>
If input0 is constant, i.e. its address space
is the <span class="bold"><strong>constant</strong></span>
address space, then it encodes a <span class="emphasis"><em>p-code relative branch</em></span>.
In this case, the offset of input0 is considered a relative offset into
the indexed list of p-code operations corresponding to the translation
of the current machine instruction. This allows branching within the
operations forming a single instruction. For example, if
the <span class="bold"><strong>BRANCH</strong></span> occurs as the pcode
operation with index 5 for the instruction, it can branch to operation
with index 8 by specifying a constant destination &#8220;address&#8221; of
3. Negative constants can be used for backward branches.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_cbranch"></a>CBRANCH</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="cbranch.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td>(<span class="bold"><strong>special</strong></span>)</td>
  <td>Location of next instruction to execute.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Boolean varnode indicating whether branch is taken.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">if (input1) goto input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a conditional branch instruction where the dynamic condition
for taking the branch is determined by the 1 byte variable input1. If
this variable is non-zero, the condition is
considered <span class="emphasis"><em>true</em></span> and the branch is taken.  As in
the <span class="bold"><strong>BRANCH</strong></span> instruction the parameter
input0 is not treated as a variable but as an address and is
interpreted in the same way. Furthermore, a constant space address is
also interpreted as a relative address so that
a <span class="bold"><strong>CBRANCH</strong></span> can do <span class="emphasis"><em>p-code
relative branching</em></span>.  See the discussion for the
<span class="bold"><strong>BRANCH</strong></span> operation.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_branchind"></a>BRANCHIND</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="branchind.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody><tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode containing offset of next instruction.</td>
</tr></tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">goto [input0];</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an indirect branching instruction. The address to branch to is
determined dynamically (at runtime) by examining the contents of the
variable input0. As this instruction is currently defined, the
variable input0 only contains the <span class="emphasis"><em>offset</em></span> of the
destination, and the address space is taken from the address
associated with the branching instruction
itself. So <span class="emphasis"><em>execution can only branch within the same address
space</em></span> via this instruction. The size of the variable input0
must match the size of offsets for the current address space. P-code
relative branching is not possible with <span class="bold"><strong>BRANCHIND</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_call"></a>CALL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="call.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td>(<span class="bold"><strong>special</strong></span>)</td>
  <td>Location of next instruction to execute.</td>
</tr>
<tr>
  <td align="right">[input1]</td>
  <td></td>
  <td>First parameter to call (never present in raw p-code)</td>
</tr>
<tr>
  <td align="right">...</td>
  <td></td>
  <td>Additional parameters to call (never present in raw p-code)</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">call [input0];</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This instruction is semantically equivalent to
the <span class="bold"><strong>BRANCH</strong></span> instruction.
<span class="bold"><strong>Beware:</strong></span> This instruction does not
behave like a typical function call. In particular, there is no
internal stack in p-code for saving the return address. Use of this
instruction instead of <span class="bold"><strong>BRANCH</strong></span> is
intended to provide a hint to algorithms that try to follow code flow.
It indicates that the original machine instruction, of which this
p-code instruction is only a part, is intended to be a function
call. The p-code instruction does not implement the full semantics of
the call itself; it only implements the final branch.
</p>
<p>
In the raw p-code translation process, this operation can only take
input0, but in follow-on analysis, it can take arbitrary additional inputs.
These represent (possibly partial) recovery of the parameters being
passed to the logical <span class="emphasis"><em>call</em></span> represented by this
operation.  These additional parameters have no effect on the original
semantics of the raw p-code but naturally hold the varnode values flowing
into the call.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_callind"></a>CALLIND</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="callind.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode containing offset of next instruction.</td>
</tr>
<tr>
  <td align="right">[input1]</td>
  <td></td>
  <td>First parameter to call (never present in raw p-code)</td>
</tr>
<tr>
  <td align="right">...</td>
  <td></td>
  <td>Additional parameters to call (never present in raw p-code)</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">call [input0];</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This instruction is semantically equivalent to
the <span class="bold"><strong>BRANCHIND</strong></span> instruction. It does
not perform a function call in the usual sense of the term. It merely
indicates that the original machine instruction is intended to be an
indirect call. See the discussion for
the <span class="bold"><strong>CALL</strong></span> instruction.
</p>
<p>As with the <span class="bold"><strong>CALL</strong></span> instruction,
this operation may take additional inputs when not in raw form, representing
the parameters being passed to the logical call.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_return"></a>RETURN</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="return.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode containing offset of next instruction.</td>
</tr>
<tr>
  <td align="right">[input1]</td>
  <td></td>
  <td>Value returned from call (never present in raw p-code)</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">return [input0];</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This instruction is semantically equivalent to
the <span class="bold"><strong>BRANCHIND</strong></span> instruction. It does
not perform a return from subroutine in the usual sense of the
term. It merely indicates that the original machine instruction is
intended to be a return from subroutine. See the discussion for
the <span class="bold"><strong>CALL</strong></span> instruction.
</p>
<p>
Similarly to <span class="bold"><strong>CALL</strong></span> and <span class="bold"><strong>CALLIND</strong></span>,
this operation may take an additional input when not in raw form. If input1 is
present it represents the value being <span class="emphasis"><em>returned</em></span> by this operation.
This is used by analysis algorithms to hold the value logically flowing back to the parent
subroutine.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_piece"></a>PIECE</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="piece.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode containing most significant data to merge.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode containing least significant data to merge.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode to contain resulting concatenation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><span class="emphasis"><em>Cannot (currently) be explicitly coded</em></span></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a concatenation operator that understands the endianess of the
data. The size of input0 and input1 must add up to the size of
output. The data from the inputs is concatenated in such a way that,
if the inputs and output are considered integers, the first input
makes up the most significant part of the output.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_subpiece"></a>SUBPIECE</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="subpiece.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode containing source data to truncate.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td>(<span class="bold"><strong>constant</strong></span>)</td>
  <td>Constant indicating how many bytes to truncate.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode to contain result of truncation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0(input1);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a truncation operator that understands the endianess of the
data. Input1 indicates the number of least significant bytes of input0
to be thrown away. Output is then filled with any remaining bytes of
input0 <span class="emphasis"><em>up to the size of output</em></span>. If the size of
output is smaller than the size of input0 plus the constant input1,
then the additional most significant bytes of input0 will also be
truncated.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_equal"></a>INT_EQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 == input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is the integer equality operator. Output is
assigned <span class="emphasis"><em>true</em></span>, if input0 equals input1. It works
for signed, unsigned, or any contiguous data where the match must be
down to the bit. Both inputs must be the same size, and the output
must have a size of 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_notequal"></a>INT_NOTEQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intnotequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 != input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is the integer inequality operator. Output is
assigned <span class="emphasis"><em>true</em></span>, if input0 does not equal
input1. It works for signed, unsigned, or any contiguous data where
the match must be down to the bit. Both inputs must be the same size,
and the output must have a size of 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_less"></a>INT_LESS</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intless.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First unsigned varnode to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second unsigned varnode to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 &lt; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an unsigned integer comparison operator. If the unsigned
integer input0 is strictly less than the unsigned integer input1,
output is set to <span class="emphasis"><em>true</em></span>. Both inputs must be the
same size, and the output must have a size of 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_sless"></a>INT_SLESS</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsless.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First signed varnode to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second signed varnode to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 s&lt; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a signed integer comparison operator. If the signed integer
input0 is strictly less than the signed integer input1, output is set
to <span class="emphasis"><em>true</em></span>. Both inputs must be the same size, and
the output must have a size of 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_lessequal"></a>INT_LESSEQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intlessequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First unsigned varnode to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second unsigned varnode to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 &lt;= input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an unsigned integer comparison operator. If the unsigned
integer input0 is less than or equal to the unsigned integer input1,
output is set to <span class="emphasis"><em>true</em></span>. Both inputs must be the
same size, and the output must have a size of 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_slessequal"></a>INT_SLESSEQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intslessequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First signed varnode to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second signed varnode to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 s&lt;= input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a signed integer comparison operator. If the signed integer
input0 is less than or equal to the signed integer input1, output is
set to <span class="emphasis"><em>true</em></span>. Both inputs must be the same size,
and the output must have a size of 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_zext"></a>INT_ZEXT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intzext.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode to zero-extend.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing zero-extended result.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = zext(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
Zero-extend the data in input0 and store the result in output. Copy
all the data from input0 into the least significant positions of
output. Fill out any remaining space in the most significant bytes of
output with zero. The size of output must be strictly bigger than the
size of input.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_sext"></a>INT_SEXT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsext.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode to sign-extend.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing sign-extended result.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = sext(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
Sign-extend the data in input0 and store the result in output. Copy
all the data from input0 into the least significant positions of
output. Fill out any remaining space in the most significant bytes of
output with either zero or all ones (0xff) depending on the most
significant bit of input0. The size of output must be strictly bigger
than the size of input0.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_add"></a>INT_ADD</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intadd.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode to add.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode to add.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of integer addition.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 + input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is standard integer addition. It works for either unsigned or
signed interpretations of the integer encoding (twos complement). Size
of both inputs and output must be the same. The addition is of course
performed modulo this size. Overflow and carry conditions are
calculated by other
operations. See <span class="bold"><strong>INT_CARRY</strong></span>
and <span class="bold"><strong>INT_SCARRY</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_sub"></a>INT_SUB</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsub.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode to subtract from first.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of integer subtraction.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 - input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is standard integer subtraction. It works for either unsigned or
signed interpretations of the integer encoding (twos complement). Size
of both inputs and output must be the same. The subtraction is of
course performed modulo this size. Overflow and borrow conditions are
calculated by other
operations. See <span class="bold"><strong>INT_SBORROW</strong></span>
and <span class="bold"><strong>INT_LESS</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_carry"></a>INT_CARRY</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intcarry.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode to add.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode to add.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean result containing carry condition.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = carry(input0,input1);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation checks for unsigned addition overflow or carry
conditions. If the result of adding input0 and input1 as unsigned
integers overflows the size of the varnodes, output is
assigned <span class="emphasis"><em>true</em></span>. Both inputs must be the same size,
and output must be size 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_scarry"></a>INT_SCARRY</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intscarry.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode to add.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode to add.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean result containing signed overflow condition.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = scarry(input0,input1);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation checks for signed addition overflow or carry
conditions. If the result of adding input0 and input1 as signed
integers overflows the size of the varnodes, output is
assigned <span class="emphasis"><em>true</em></span>. Both inputs must be the same size,
and output must be size 1.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_sborrow"></a>INT_SBORROW</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsborrow.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode to subtract from first.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean result containing signed overflow condition.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = sborrow(input0,input1);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation checks for signed subtraction overflow or borrow
conditions. If the result of subtracting input1 from input0 as signed
integers overflows the size of the varnodes, output is
assigned <span class="emphasis"><em>true</em></span>. Both inputs must be the same size,
and output must be size 1.  Note that the equivalent unsigned
subtraction overflow condition
is <span class="bold"><strong>INT_LESS</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_2comp"></a>INT_2COMP</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="int2comp.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First to negate.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing twos complement.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = -input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is the twos complement or arithmetic negation operation. Treating input0 as a signed
integer, the result is the same integer value but with the opposite sign. This is equivalent
to doing a bitwise negation of input0 and then adding one. Both input0 and output must
be the same size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_negate"></a>INT_NEGATE</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intnegate.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode to negate.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing bitwise negation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = ~input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is the bitwise negation operation. Output is the result of taking
every bit of input0 and flipping it. Both input0 and output must be
the same size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_xor"></a>INT_XOR</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intxor.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First input to exclusive-or.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second input to exclusive-or.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing exclusive-or of inputs.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 ^ input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation performs a logical Exclusive-Or on the bits of input0
and input1. Both inputs and output must be the same size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_and"></a>INT_AND</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intand.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First input to logical-and.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second input to logical-and.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing logical-and of inputs.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 &amp; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation performs a Logical-And on the bits of input0 and input1. Both inputs and
output must be the same size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_or"></a>INT_OR</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intor.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First input to logical-or.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second input to logical-or.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing logical-or of inputs.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 | input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation performs a Logical-Or on the bits of input0 and input1. Both inputs and
output must be the same size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_left"></a>INT_LEFT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intleft.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode input being shifted.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode indicating number of bits to shift.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing shifted result.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 &lt;&lt; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation performs a left shift on input0. The value given by
input1, interpreted as an unsigned integer, indicates the number of
bits to shift. The vacated (least significant) bits are filled with
zero. If input1 is zero, no shift is performed and input0 is copied
into output. If input1 is larger than the number of bits in output,
the result is zero. Both input0 and output must be the same
size. Input1 can be any size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_right"></a>INT_RIGHT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intright.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode input being shifted.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode indicating number of bits to shift.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing shifted result.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 &gt;&gt; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation performs an unsigned (logical) right shift on
input0. The value given by input1, interpreted as an unsigned integer,
indicates the number of bits to shift. The vacated (most significant)
bits are filled with zero. If input1 is zero, no shift is performed
and input0 is copied into output. If input1 is larger than the number
of bits in output, the result is zero. Both input0 and output must be
the same size. Input1 can be any size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_sright"></a>INT_SRIGHT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsright.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Varnode input being shifted.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Varnode indicating number of bits to shift.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing shifted result.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 s&gt;&gt; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation performs a signed (arithmetic) right shift on
input0. The value given by input1, interpreted as an unsigned integer,
indicates the number of bits to shift. The vacated bits are filled
with the original value of the most significant (sign) bit of input0.
If input1 is zero, no shift is performed and input0 is copied into
output. If input1 is larger than the number of bits in output, the
result is zero or all 1-bits (-1), depending on the original sign of
input0. Both input0 and output must be the same size. Input1 can be
any size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_mult"></a>INT_MULT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intmult.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode to be multiplied.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode to be multiplied.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of multiplication.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 * input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an integer multiplication operation. The result of multiplying
input0 and input1, viewed as integers, is stored in output. Both
inputs and output must be the same size. The multiplication is
performed modulo the size, and the result is true for either a signed
or unsigned interpretation of the inputs and output. To get extended
precision results, the inputs must first by zero-extended or
sign-extended to the desired size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_div"></a>INT_DIV</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intdiv.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode input (divisor).</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of division.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 / input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an unsigned integer division operation. Divide input0 by
input1, truncating the result to the nearest integer, and store the
result in output. Both inputs and output must be the same size. There
is no handling of division by zero. To simulate a processor&#8217;s handling
of a division-by-zero trap, other operations must be used before
the <span class="bold"><strong>INT_DIV</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_rem"></a>INT_REM</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intrem.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode input (divisor).</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing remainder of division.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 % input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an unsigned integer remainder operation. The remainder of
performing the unsigned integer division of input0 and input1 is put
in output. Both inputs and output must be the same size. If q =
input0/input1, using the <span class="bold"><strong>INT_DIV</strong></span>
operation defined above, then output satisfies the equation q*input1 +
output = input0, using the <span class="bold"><strong>INT_MULT</strong></span>
and <span class="bold"><strong>INT_ADD</strong></span> operations.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_sdiv"></a>INT_SDIV</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsdiv.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode input (divisor).</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of signed division.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 s/ input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a signed integer division operation. The resulting integer is
the one closest to the rational value input0/input1 but which is still
smaller in absolute value. Both inputs and output must be the same
size. There is no handling of division by zero. To simulate a
processor&#8217;s handling of a division-by-zero trap, other operations must
be used before the <span class="bold"><strong>INT_SDIV</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int_srem"></a>INT_SREM</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="intsrem.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First varnode input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second varnode input (divisor).</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing remainder of signed division.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 s% input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a signed integer remainder operation. The remainder of
performing the signed integer division of input0 and input1 is put in
output. Both inputs and output must be the same size. If q = input0 s/
input1, using the <span class="bold"><strong>INT_SDIV</strong></span> operation
defined above, then output satisfies the equation q*input1 + output =
input0, using the <span class="bold"><strong>INT_MULT</strong></span>
and <span class="bold"><strong>INT_ADD</strong></span> operations.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_bool_negate"></a>BOOL_NEGATE</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="boolnegate.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Boolean varnode to negate.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of negation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = !input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a logical negate operator, where we assume input0 and output
are boolean values.  It puts the logical complement of input0, treated
as a single bit, into output. Both input0 and output are size
1. Boolean values are implemented with a full byte, but are still
considered to only support a value of <span class="emphasis"><em>true</em></span>
or <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_bool_xor"></a>BOOL_XOR</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="boolxor.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First boolean input to exclusive-or.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second boolean input to exclusive-or.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of exclusive-or.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 ^^ input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an Exclusive-Or operator, where we assume the inputs and
output are boolean values. It puts the exclusive-or of input0 and
input1, treated as single bits, into output.  Both inputs and output
are size 1. Boolean values are implemented with a full byte, but are
still considered to only support a value of <span class="emphasis"><em>true</em></span>
or <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_bool_and"></a>BOOL_AND</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="booland.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First boolean input to logical-and.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second boolean input to logical-and.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of logical-and.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 &amp;&amp; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a Logical-And operator, where we assume the inputs and output
are boolean values. It puts the logical-and of input0 and input1,
treated as single bits, into output.  Both inputs and output are size
1. Boolean values are implemented with a full byte, but are still
considered to only support a value of <span class="emphasis"><em>true</em></span>
or <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_bool_or"></a>BOOL_OR</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="boolor.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First boolean input to logical-or.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second boolean input to logical-or.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of logical-or.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 || input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a Logical-Or operator, where we assume the inputs and output
are boolean values. It puts the logical-or of input0 and input1,
treated as single bits, into output.  Both inputs and output are size
1. Boolean values are implemented with a full byte, but are still
considered to only support a value of <span class="emphasis"><em>true</em></span>
or <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_equal"></a>FLOAT_EQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f== input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point equality operator. Output is
assigned <span class="emphasis"><em>true</em></span>, if input0 and input1 are
considered equal as floating-point values. Both inputs must be the
same size, and output is size 1. If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_notequal"></a>FLOAT_NOTEQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatnotequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f!= input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point inequality operator. Output is
assigned <span class="emphasis"><em>true</em></span>, if input0 and input1 are not
considered equal as floating-point values. Both inputs must be the
same size, and output is size 1. If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_less"></a>FLOAT_LESS</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatless.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f&lt; input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a comparison operator, where both inputs are considered
floating-point values. Output is assigned <span class="emphasis"><em>true</em></span>,
if input0 is less than input1. Both inputs must be the same size, and
output is size 1. If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_lessequal"></a>FLOAT_LESSEQUAL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatlessequal.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input to compare.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of comparison.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f&lt;= input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a comparison operator, where both inputs are considered
floating-point values. Output is assigned <span class="emphasis"><em>true</em></span>,
if input0 is less than or equal to input1. Both inputs must be the
same size, and output is size 1. If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="emphasis"><em>false</em></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_add"></a>FLOAT_ADD</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatadd.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input to add.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input to add.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of addition.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f+ input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point addition operator. The result of adding
input0 and input1 as floating-point values is stored in output. Both
inputs and output must be the same size. If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>. If any overflow condition
occurs, output is set to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_sub"></a>FLOAT_SUB</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatsub.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Floating-point varnode to subtract from first.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of subtraction.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f- input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point subtraction operator. The result of
subtracting input1 from input0 as floating-point values is stored in
output. Both inputs and output must be the same size.  If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>. If any overflow condition
occurs, output is set to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_mult"></a>FLOAT_MULT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatmult.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input to multiply.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input to multiply.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of multiplication.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f* input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point multiplication operator. The result of
multiplying input0 to input1 as floating-point values is stored in
output. Both inputs and output must be the same size.  If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>. If any overflow condition
occurs, output is set to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_div"></a>FLOAT_DIV</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatdiv.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>First floating-point input.</td>
</tr>
<tr>
  <td align="right">input1</td>
  <td></td>
  <td>Second floating-point input (divisor).</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of division.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = input0 f/ input1;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point division operator. The result of dividing
input1 into input0 as floating-point values is stored in output. Both
inputs and output must be the same size. If either input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>. If any overflow condition
occurs, output is set to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_neg"></a>FLOAT_NEG</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatneg.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point varnode to negate.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode containing result of negation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = f- input0;</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point negation operator. The floating-point value
in input0 is stored in output with the opposite sign. Both input and
output must be the same size. If input
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_abs"></a>FLOAT_ABS</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatabs.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing absolute-value.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = abs(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point absolute-value operator. The absolute value
of input0 is stored in output. Both input0 and output must be the same
size. If input0 is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_sqrt"></a>FLOAT_SQRT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatsqrt.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing square root.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = sqrt(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point square-root operator. The square root of
input0 is stored in output.  Both input0 and output must be the same
size. If input0 is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_ceil"></a>FLOAT_CEIL</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatceil.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing result of truncation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = ceil(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation rounds input0, as a signed floating-point value, towards <span class="emphasis"><em>positive infinity</em></span>.
For instance, the value 1.2 rounds to 2.0; -1.2 rounds to -1.0.
The integral value obtained by rounding input0 up is stored in output, as a floating-point
value. Both input0 and output must be the same size. If input0
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_floor"></a>FLOAT_FLOOR</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatfloor.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing result of truncation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = floor(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operation rounds input0, as a floating-point value, towards <span class="emphasis"><em>negative infinity</em></span>.
For instance, the value 1.2 rounds to 1.0 and -1.2 rounds to -2.0.
The integral value obtained by rounding input0 down is stored in output, as a floating-point
value. <span class="bold"><strong>FLOAT_FLOOR</strong></span> does <span class="emphasis"><em>not</em></span> produce
a twos complement integer output (See the <span class="bold"><strong>TRUNC</strong></span> operator).
Both input0 and output must be the same size. If input0
is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_round"></a>FLOAT_ROUND</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatround.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Varnode result containing result of truncation.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = round(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point rounding operator. The integral value closest to the
floating-point value in input0 is stored in output, as a floating-point value.
For example, 1.2 rounds to 1.0 and 1.9 rounds to 2.0.
<span class="bold"><strong>FLOAT_ROUND</strong></span> does <span class="emphasis"><em>not</em></span>
produce a twos complement integer output (See the <span class="bold"><strong>TRUNC</strong></span> operator).
Both input0 and output must be the same size. If
input0 is <span class="bold"><strong>NaN</strong></span>, output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float_nan"></a>FLOAT_NAN</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="floatnan.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Boolean varnode containing result of NaN test.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = nan(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This operator returns <span class="emphasis"><em>true</em></span> in output if input0 is
interpreted as <span class="bold"><strong>NaN</strong></span>. Output must be
size 1, and input0 can be any size.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_int2float"></a>INT2FLOAT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="int2float.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Signed integer input.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Result containing floating-point conversion.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = int2float(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is an integer to floating-point conversion operator. Input0
viewed as a signed integer is converted to floating-point format and
stored in output. Input0 and output do not need to be the same
size. The conversion to floating-point may involve a loss of
precision.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_float2float"></a>FLOAT2FLOAT</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="float2float.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input varnode.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Result varnode containing conversion.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = float2float(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point precision conversion operator. The
floating-point value in input0 is converted to a floating-point value
of a different size and stored in output. If output is smaller than
input0, then the operation will lose precision. Input0 and output
should be different sizes. If input0
is <span class="bold"><strong>NaN</strong></span>, then output is set
to <span class="bold"><strong>NaN</strong></span>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="cpui_trunc"></a>TRUNC</h3></div></div></div>
<div class="informalexample"><div class="table">
<a name="trunc.htmltable"></a><table frame="above" width="80%" rules="groups">
<col width="23%">
<col width="15%">
<col width="61%">
<thead><tr>
  <td align="center" colspan="2"><span class="bold"><strong>Parameters</strong></span></td>
  <td><span class="bold"><strong>Description</strong></span></td>
</tr></thead>
<tbody>
<tr>
  <td align="right">input0</td>
  <td></td>
  <td>Floating-point input varnode.</td>
</tr>
<tr>
  <td align="right">output</td>
  <td></td>
  <td>Resulting integer varnode containing conversion.</td>
</tr>
</tbody>
<tfoot>
<tr>
  <td align="center" colspan="2"><span class="bold"><strong>Semantic statement</strong></span></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td colspan="2"><code class="code">output = trunc(input0);</code></td>
</tr>
</tfoot>
</table>
</div></div>
<p>
This is a floating-point to integer conversion operator. The
floating-point value in input0 is converted to a signed integer and
stored in output using the default twos complement encoding.
The fractional part of input0 is dropped in the conversion by rounding <span class="emphasis"><em>towards zero</em></span>.
Input0 and output can be different sizes. 
</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="pcoderef.html">Prev</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="pseudo-ops.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">P-Code Reference Manual </td>
<td width="20%" align="center"><a accesskey="h" href="pcoderef.html">Home</a></td>
<td width="40%" align="right" valign="top"> Pseudo P-CODE Operations</td>
</tr>
</table>
</div>
</body>
</html>
