/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ghidra.program.database.data.merge;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import ghidra.program.model.data.*;

/**
 * Base class for datatype mergers. Note that these mergers are non interactive and can only
 * merge datatypes that have no conflicting internal components or settings.
 * <P>
 * The basic pattern is to create a merger with the two datatypes to be merged and then call
 * the {@link #merge()} method to produce the new datatype that is the merger of the two original
 * datatypes. The new datatype will have the same name and category path of the first original 
 * datatype. 
 * <P>
 * Even if the merge is able to successfully complete and return a new datatype, the merge may
 * have associated warnings that can be retrieved by calling {@link #getWarnings()}. The intent
 * is that the warning messages can be presented to the user before applying the new datatype.
 * <P>
 * Typically, after merging the two datatypes, the client will replace the first datatype with
 * the merged datatype (it already has the same name and category). Then all uses of the second
 * datatype will be replaced with updated first datatype.
 *
 * @param <T> The specific type of datatype being merged.
 */
public abstract class DataTypeMerger<T extends DataType> {

	private T dt1;
	private T dt2;

	protected T working;
	protected T other;
	private List<String> warnings = new ArrayList<>();

	protected DataTypeMerger(T dt1, T dt2) {
		this.dt1 = dt1;
		this.dt2 = dt2;
	}

	/**
	 * Merge the two datatypes that this object was created with into a new datatype.
	 * @return the the new merged datatype.
	 * @throws DataTypeMergeException thrown if the merge was unable to complete due to some
	 * conflict.
	 */
	public final T merge() throws DataTypeMergeException {
		warnings.clear();
		intializedDataTypes();
		doMerge();
		return working;
	}

	@SuppressWarnings("unchecked")
	private void intializedDataTypes() {
		DataTypeManager dtm = dt1.getDataTypeManager();
		// copy the  first datatype to be the working datatype, this forces a complete new object
		// versus a clone which may return itself.
		this.working = (T) dt1.copy(dtm);

		// we clone the second datatype to make sure it has the same data type organization
		this.other = (T) dt2.clone(dtm);
	}

	protected abstract void doMerge() throws DataTypeMergeException;

	/**
	 * {@return any warnings that were generated by a call to the merge() method}
	 */
	public List<String> getWarnings() {
		return warnings;
	}

	/**
	 * {@return true if there are any warnings}
	 */
	public boolean hasWarnings() {
		return !warnings.isEmpty();
	}

	/**
	 * Adds a warning to the list of warnings.
	 * @param message the warning message to add
	 */
	protected void warning(String message) {
		warnings.add(message);
	}

	/**
	 * Generates a DataTypeMergeException with the given error message.
	 * @param message the error message
	 * @throws DataTypeMergeException with the given message
	 */
	protected void error(String message) throws DataTypeMergeException {
		throw new DataTypeMergeException(message);
	}

	/**
	 * Joins two comment strings unless they are identical or one is null or blank.
	 * @param comment1 the first comment
	 * @param comment2 the second comment
	 * @return a new string with the two non-blank, non-identical commments joined by a space.
	 */
	protected String join(String comment1, String comment2) {
		if (StringUtils.isBlank(comment1)) {
			return comment2;
		}
		else if (StringUtils.isBlank(comment2)) {
			return comment1;
		}
		if (comment1.equals(comment2)) {
			return comment1;
		}
		return comment1 + " " + comment2;
	}

	protected DataType pickBestTypeForMerge(DataType type1, DataType type2) {
		if (type1.getLength() != type2.getLength()) {
			return null;
		}
		if (canUpgrade(type1, type2)) {
			return type2;
		}
		if (canUpgrade(type2, type1)) {
			return type1;
		}
		return null;
	}

	/**
	 * Checks if one datatype can can be upgraded to a another during a merge operation. In this
	 * context, upgrade means that one datatype is often a stand-in for another because there 
	 * wasn't initially enough information to get the correct type. For example, any undefined
	 * type of some size is a stand-in for any other datatype of that size, so undefined types
	 * can always be upgraded to another type of the same size. Another case is integer types are
	 * often mistaken for pointers, integer types can be upgraded to pointers.
	 * @param from the datatype to test if it can be updated
	 * @param to the dataType to that is the possible upgrade
	 * @return  true if typically the from dataType can be reasonably upgraded to the to datatype
	 */
	protected boolean canUpgrade(DataType from, DataType to) {
		if (from.getLength() != to.getLength()) {
			return false;
		}

		if (Undefined.isUndefined(from)) {
			return true;
		}
		if (from instanceof AbstractIntegerDataType && to instanceof Pointer) {
			return true;
		}
		if (from instanceof Pointer fromPointer && to instanceof Pointer toPointer) {
			DataType pdt1 = fromPointer.getDataType();
			DataType pdt2 = toPointer.getDataType();
			return canUpgrade(pdt1, pdt2);
		}
		return false;
	}

	protected void mergeDescription() {
		String description1 = dt1.getDescription();
		String description2 = dt2.getDescription();
		String merged = join(description1, description2);
		working.setDescription(merged);
	}
}
