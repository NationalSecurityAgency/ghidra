
define alignment=2;
define space ram type=ram_space size=4 default;
define space register type=register_space size=4;

#TODO  This is probably in the spec
define register offset=0x00 size=4 contextreg;
define context contextreg
        PCPMode=(0,0)
;

# Data General Purpose Registers
define register offset=0xFF00 size=8 [ e0    e2    e4    e6    e8    e10     e12     e14 ];
define register offset=0xFF00 size=4 [ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 ];

# Address General Purpose Registers
define register offset=0xFF80 size=8 [ p0    p2    p4    p6    p8    p10     p12     p14 ];
define register offset=0xFF80 size=4 [ a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 ];

# Program Counter
define register offset=0xFE08 size=4 [ PC ];

# Program Status Word Register
define register offset=0xFE04 size=4 [ PSW ];

#TODO  bitrange vs define vs context
# define bitrange PSW_USB=PSW[24,8]
#                 PSW_C=PSW[31,1]
#                 PSW_V=PSW[30,1]
#                 PSW_SV=PSW[29,1]
#                 PSW_AV=PSW[28,1]
#                 PSW_SAV=PSW[27,1]
#                 PSW_S=PSW[14,1]
#                 PSW_PRS=PSW[12,2]
#                 PSW_IO=PSW[10,2]
#                 PSW_IS=PSW[9,1]
#                 PSW_GW=PSW[8,1]
#                 PSW_CDE=PSW[7,1]
#                 PSW_CDC=PSW[0,7];
@define PSW_USB "PSW[24,8]"
@define PSW_C "PSW[31,1]"
@define PSW_FS "PSW[31,1]"
@define PSW_V "PSW[30,1]"
@define PSW_FI "PSW[30,1]"
@define PSW_SV "PSW[29,1]"
@define PSW_FV "PSW[29,1]"
@define PSW_AV "PSW[28,1]"
@define PSW_FZ "PSW[28,1]"
@define PSW_SAV "PSW[27,1]"
@define PSW_FU "PSW[27,1]"
@define PSW_FX "PSW[26,1]"
@define PSW_RM "PSW[24,2]"
@define PSW_S "PSW[14,1]"
@define PSW_PRS "PSW[12,2]"
@define PSW_IO "PSW[10,2]"
@define PSW_IS "PSW[9,1]"
@define PSW_GW "PSW[8,1]"
@define PSW_CDE "PSW[7,1]"
@define PSW_CDC "PSW[0,7]"

# Previous Context Information and Pointer Register
define register offset=0xFE00 size=4 [ PCXI ];
# define context PCXI
#   PCXO=(0,15)
#   PCXS=(16,19)
#   UL=(20,20)
#   PIE=(21,21)
#   PCPN=(22,29)
# ;

# Interrupt Stack Pointer Register
define register offset=0xFE28 size=4 [ ISP ];

# System Control Register
define register offset=0xFE14 size=4 [ SYSCON ];
# define context SYSCON
#   FCDSF=(0,0)
#   PROTEN=(1,1)
#   TPROTEN=(2,2)
#   IS=(3,3)
#   TS=(4,4)
#   U1_IED=(16,16)
#   U1_IOS=(17,17)
# ;

# CPU Identification Register
define register offset=0xFE18 size=4 [ CPU_ID ];
# define context CPU_ID
#   MOD_REV=(0,7)
#   MOD_32B=(8,15)
#   MOD=(16,31)
# ;

# Core Identification Register
define register offset=0xFE1C size=4 [ CORE_ID ];


# Compatibility Mode Register
define register offset=0x9400 size=4 [ COMPAT ];

# SIST Mode Access Control Register
define register offset=0x900C size=4 [ SMACON ];

# Free CSA List Head Pointer Register
define register offset=0xFE38 size=4 [ FCX ];
# define context FCX
#   FCXO=(0,15)
#   FCXS=(16,19)
# ;

# Free CSA List Limit Pointer Register
define register offset=0xFE3C size=4 [ LCX ];
# define context LCX
#   LCXO=(0,15)
#   LCXS=(16,19)
# ;

# ICU Interrupt Control Register
define register offset=0xFE2C size=4 [ ICR ];
define register offset=0xFE2E size=1 [ PIPN ];
# define context ICR
#   CCPN=(0,7)
#   IE=(15,15)
#   PIPN=(16,23)
# ;
@define ICR_PIPN "ICR[16,8]"
@define ICR_IE "ICR[15,1]"
@define ICR_CCPN "ICR[0,8]"

# Base Interrupt Vector Table Pointer
define register offset=0xFE20 size=4 [ BIV ];
# define context BIV
#   VSS=(0,0)
# ;

# Base Trap Vector Table Pointer
define register offset=0xFE24 size=4 [ BTV ];

# Program Synchronous Error Trap Register
define register offset=0x9200 size=4 [ PSTR ];

# Data Synchronous Error Trap Register
define register offset=0x9010 size=4 [ DSTR ];

# Data Asynchronous Error Trap Register
define register offset=0x9018 size=4 [ DATR ];

# Data Error Address Register
define register offset=0x901C size=4 [ DEADD ];

# Program Integrity Error Trap Register
define register offset=0x9214 size=4 [ PIETR ];

# Program Integrity Error Address Register
define register offset=0x9210 size=4 [ PIEAR ];

# Data Integrity Error Trap Register
define register offset=0x9024 size=4 [ DIETR ];

# Data Integrity Error Address Register
define register offset=0x9020 size=4 [ DIEAR ];

# Programmable Memory Access Register
define register offset=0x8100 size=4 [ PMA0 PMA1 PMA2 ];

# Program Memory Configuration Registers
define register offset=0x9204 size=4 [ PCON1 PCON2 PCON0 ];

# Data Memory Configuration Registers
define register offset=0x9040 size=4 [ DCON0 ];
define register offset=0x9008 size=4 [ DCON1 ];
define register offset=0x9000 size=4 [ DCON2 ];

# Data Protection Range Register Lower & Upper Bound
define register offset=0xC000 size=4 [ DPR0_L DPR0_U DPR1_L DPR1_U DPR2_L DPR2_U DPR3_L DPR3_U DPR4_L DPR4_U DPR5_L DPR5_U DPR6_L DPR6_U DPR7_L DPR7_U DPR8_L DPR8_U DPR9_L DPR9_U DPR10_L DPR10_U DPR11_L DPR11_U DPR12_L DPR12_U DPR13_L DPR13_U DPR14_L DPR14_U DPR15_L DPR15_U ];

# Code Protection Range Register Lower & Upper Bound
define register offset=0xD000 size=4 [ CPR0_L CPR0_U CPR1_L CPR1_U CPR2_L CPR2_U CPR3_L CPR3_U CPR4_L CPR4_U CPR5_L CPR5_U CPR6_L CPR6_U CPR7_L CPR7_U CPR8_L CPR8_U CPR9_L CPR9_U CPR10_L CPR10_U CPR11_L CPR11_U CPR12_L CPR12_U CPR13_L CPR13_U CPR14_L CPR14_U CPR15_L CPR15_U ];

# Data Protection Read Enable Set Configuration Register
define register offset=0xE010 size=4 [ DPRE_0 DPRE_1 DPRE_2 DPRE_3 ];

# Data Protection Write Enable Set Configuration Register
define register offset=0xE020 size=4 [ DPWE_0 DPWE_1 DPWE_2 DPWE_3 ];

# Code Protection Execute Enable Set Configuration Register
define register offset=0xE000 size=4 [ CPXE_0 CPXE_1 CPXE_2 CPXE_3 ];

# Temporal Protect System (TPS) Timer Register
define register offset=0xE404 size=4 [ TPS_TIMER0 TPS_TIMER1 TPS_TIMER2 ];

# TPS Control Register
define register offset=0xE400 size=4 [ TPS_CON ];
# define context TPS_CON
#   TEXP0=(0,0)
#   TEXP1=(1,1)
#   TEXP2=(2,2)
#   TTRAP=(16,16)
# ;

# FPU Trap Control Register
define register offset=0xA000 size=4 [ FPU_TRAP_CON ];
# define context FPU_TRAP_CON
#   TST=(0,0)
#   TCL=(1,1)
#   RM=(8,9)
#   FXE=(18,18)
#   FUE=(19,19)
#   FZE=(20,20)
#   FVE=(21,21)
#   FIE=(22,22)
#   FX=(26,26)
#   FU=(27,27)
#   FZ=(28,28)
#   FV=(29,29)
#   FI=(30,30)
# ;

# FPU Trapping Instruction Program Counter
define register offset=0xA004 size=4 [ FPU_TRAP_PC ];

# FPU Trapping Instruction Opcode Register
define register offset=0xA008 size=4 [ FPU_TRAP_OPC ];
# define context FPU_TRAP_OPC
#   OPC=(0,7)
#   FMT=(8,8)
#   DREG=(16,19)
# ;

# FPU Trapping Instruction Operand SRC1 Register
define register offset=0xA010 size=4 [ FPU_TRAP_SRC1 FPU_TRAP_SRC2 FPU_TRAP_SRC3 ];



# Core Debug Controller (CDC) Registers
# Debug Status Register
define register offset=0xFD00 size=4 [ DBGSR ];
# define context DBGSR
#   DE=(0,0)
#   HALT=(1,2)
#   SIH=(3,3)
#   SUSP=(4,4)
#   PREVSUSP=(6,6)
#   PEVT=(7,7)
#   EVTSRC=(8,12)
# ;
@define DBGSR_EVTSRC "DBGSR[8,5]"
@define DBGSR_PEVT "DBGSR[7,1]"
@define DBGSR_PREVSUSP "DBGSR[6,1]"
@define DBGSR_SUSP "DBGSR[4,1]"
@define DBGSR_SIH "DBGSR[3,1]"
@define DBGSR_HALT "DBGSR[1,2]"
@define DBGSR_DE "DBGSR[0,1]"

# External Event Register
define register offset=0xFD08 size=4 [ EXEVT ];
# define context EXEVT
#   EVTA=(0,2)
#   BBM=(3,3)
#   BOD=(4,4)
#   SUSP=(5,5)
#   CNT=(6,7)
# ;

# Core Register Access Event Register
define register offset=0xFD0C size=4 [ CREVT ];
# define context CREVT
#   CREVT_EVTA=(0,2)
#   CREVT_BBM=(3,3)
#   CREVT_BOD=(4,4)
#   CREVT_SUSP=(5,5)
#   CREVT_CNT=(6,7)
# ;

# Software Debug Event Register
define register offset=0xFD10 size=4 [ SWEVT ];
# define context SWEVT
#   SWEVT_EVTA=(0,2)
#   SWEVT_BBM=(3,3)
#   SWEVT_BOD=(4,4)
#   SWEVT_SUSP=(5,5)
#   SWEVT_CNT=(6,7)
# ;

# Trigger Accumulator Register
define register offset=0xFD30 size=4 [ TRIG_ACC ];
# define context TRIC_ACC
#   T0=(0,0)
#   T1=(1,1)
#   T2=(2,2)
#   T3=(3,3)
#   T4=(4,4)
#   T5=(5,5)
#   T6=(6,6)
#   T7=(7,7)
# ;

# Debug Monitor Start Address Register
define register offset=0xFD40 size=4 [ DMS ];

# Debug Context Save Area Pointer Register
define register offset=0xFD44 size=4 [ DCX ];

# Debug Trap Control Register
define register offset=0xFD48 size=4 [ DBGTCR ];

# Application Space Identifier Register
define register offset=0x8004 size=4 [ TASK_ASI ];

# Software Breakpoint Service Request Control
#define register offset=0xFFB0 size=4 [ SBSRC3 SBSRC2 SBSRC1 SBSRC0 ];

# Trigger Event Configuration / Address Register
define register offset=0xF000 size=4 [ TR0EVT TR0ADR TR1EVT TR1ADR TR2EVT TRA2DR TR3EVT TR3ADR TR4EVT TR4ADR TR5EVT TR5ADR TR6EVT TR6ADR TR7EVT TR7ADR ];
# define context TRxEVT
#   EVTA=(0,2)
#   BBM=(3,3)
#   BOD=(4,4)
#   SUSP=(5,5)
#   CNT=(6,7)
#   TYP=(12,12)
#   RNG=(13,13)
#   ASI_EN=(15,15)
#   ASI=(16,20)
#   AST=(27,27)
#   ALD=(28,28)
# ;


# Counter Control Register
define register offset=0xFC00 size=4 [ CCTRL ];
# define context CCTRL
#   CM=(0,0)
#   CE=(1,1)
#   M1=(2,4)
#   M2=(5,7)
#   M3=(8,10)
# ;

# CPU Clock Cycle Count Register
define register offset=0xFC04 size=4 [ CCNT ];

# Instruction Count Register
define register offset=0xFC08 size=4 [ ICNT ];

# Mult-Count Register
define register offset=0xFC0C size=4 [ M1CNT M2CNT M3CNT ];





define token instr (16)
  op0003=(0, 3)
  op0005=(0, 5)
  op0006=(0, 6)
  op0007=(0, 7)
  op0404=(4, 4)
  op0405=(4, 5)
  op0407=(4, 7)
  op0606=(6, 6)
  op0607=(6, 7)
  op0707=(7, 7)
  op0810=(8, 10)
  Rd0811=(8, 11)
  Ra0811=(8, 11)
  Re0811=(8, 11)
  Ree0811=(8, 11)
  Reo0811=(8, 11)
  ReN0811=(8, 11)
  op0811=(8, 11)
  Rp0811=(8, 11)
  Rpe0811=(8, 11)
  Rpo0811=(8, 11)
  op0815=(8, 15)
  sop0815=(8, 15) signed
  op1111=(11, 11)
  Rd1215=(12, 15)
  op1215=(12, 15)
  sop1215=(12, 15) signed
  Ra1215=(12, 15)
  Rpe1215=(12, 15)
  Rpo1215=(12, 15)
  op1515=(15, 15)
;

define token instr2 (16)
  op1617=(0, 1)
  op1620=(0, 4)
  sop1620=(0, 4) signed
  op1621=(0, 5)
  op1622=(0, 6)
  op1623=(0, 7)
  op1627=(0, 11)
  sop1627=(0, 11) signed
  sop1630=(0, 14) signed
  op1631=(0, 15)
  op1819=(2, 3)
  op1823=(2, 7)
  op1827=(2, 11)
  op2020=(4, 4)
  op2023=(4, 7)
  op2027=(4, 11)
  op2122=(5, 6)
  op2123=(5, 7)
  op2127=(5, 11)
  op2131=(5, 15)
  op2225=(6, 9)
  op2227=(6, 11)
  sop2227=(6, 11) signed
  op2327=(7, 11)
  Rd2427=(8, 11)
  Re2427=(8, 11)
  Ree2427=(8, 11)
  Reo2427=(8, 11)
  op2627=(10, 11)
  Rd2831=(12, 15)
  Ra2831=(12, 15)
  Re2831=(12, 15)
  Ree2831=(12, 15)
  Reo2831=(12, 15)
  op2831=(12, 15)
  sop2831=(12, 15) signed
  op3131=(15, 15)
;



attach variables [ Rd0811 Rd1215 Rd2427 Rd2831 ] [ d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 ];
attach variables [ Re0811 Re2427 Re2831 ] [ e0 _ e2 _ e4 _ e6 _ e8 _ e10 _ e12 _ e14 _ ];
attach variables [ ReN0811 ] [ e2 _ e4 _ e6 _ e8 _ e10 _ e12 _ e14 _ e0 _ ];
attach variables [ Ree0811 Ree2427 Ree2831 ] [ d0 _ d2 _ d4 _ d6 _ d8 _ d10 _ d12 _ d14 _];
attach variables [ Reo0811 Reo2427 Reo2831 ] [ d1 _ d3 _ d5 _ d7 _ d9 _ d11 _ d13 _ d15 _];

attach variables [ Ra0811 Ra1215 Ra2831 ] [ a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 ];
attach variables [ Rp0811 ] [ p0 _ p2 _ p4 _ p6 _ p8 _ p10 _ p12 _ p14 _ ];
attach variables [ Rpe0811 Rpe1215 ] [ a0 _ a2 _ a4 _ a6 _ a8 _ a10 _ a12 _ a14 _];
attach variables [ Rpo0811 Rpo1215 ] [ a1 _ a3 _ a5 _ a7 _ a9 _ a11 _ a13 _ a15 _];




# 0 MMU
# * 0 VAF
# * 1 VAP
# 1 Internal Protection Traps
# * 1 PRIV
# * 2 MPR
# * 3 MPW
# * 4 MPX
# * 5 MPP
# * 6 MPN
# * 7 GRWP
# 2 Instruction Errors
# * 1 IOPC
# * 2 UOPC
# * 3 OPD
# * 4 ALN
# * 5 MEM
# 3 Context Management
# * 1 FCD
# * 2 CDO
# * 3 CDU
# * 4 FCU
# * 5 CSU
# * 6 CTYP
# * 7 NEST
# 4 System Bus and Peripheral Errors
# * 1 PSE
# * 2 DSE
# * 3 DAE
# * 4 CAE
# * 5 PIE
# * 6 DIE
# * 7 TAE
# 5 Assertion Traps
# * 1 OVF
# * 2 SOVF
# 6 System Call
# * 0-255 SYS
# 7 Non-Maskable Interrupt
# * 0 NMI
define pcodeop trap;


define pcodeop cache_address_ivld;
define pcodeop cache_address_wb;
define pcodeop cache_address_wi;
define pcodeop cache_index_ivld;
define pcodeop cache_index_wb;
define pcodeop cache_index_wi;
define pcodeop round16;
define pcodeop leading_ones;
define pcodeop leading_zeros;
define pcodeop leading_signs;
define pcodeop crc32;

# float
define pcodeop denorm_to_zero;
define pcodeop ieee754_round;
define pcodeop ieee754_32bit_format;

define pcodeop coprocessor;

define pcodeop debug;
define pcodeop dsync;
define pcodeop isync;
define pcodeop tlbdemap;
define pcodeop tlbflusha;
define pcodeop tlbflushb;
define pcodeop tlbmap;
define pcodeop tlbprobea;
define pcodeop tlbprobei;
define pcodeop wait;


@if defined(TRICORE_VERBOSE)
@else
define pcodeop bmerge;
define pcodeop bsplit;
define pcodeop load_lower_context;
define pcodeop load_upper_context;
define pcodeop store_lower_context;
define pcodeop store_upper_context;
@endif



#TODO  
define pcodeop reverse16;
# macro reverse16(src, dst) {
#       dst[0,1]=src[15,1];
#       dst[1,1]=src[14,1];
#       dst[2,1]=src[13,1];
#       dst[3,1]=src[12,1];
#       dst[4,1]=src[11,1];
#       dst[5,1]=src[10,1];
#       dst[6,1]=src[9,1];
#       dst[7,1]=src[8,1];
#       dst[8,1]=src[7,1];
#       dst[9,1]=src[6,1];
#       dst[10,1]=src[5,1];
#       dst[11,1]=src[4,1];
#       dst[12,1]=src[3,1];
#       dst[13,1]=src[2,1];
#       dst[14,1]=src[1,1];
#       dst[15,1]=src[0,1];
# }

macro overflowflagsd(r) {
        $(PSW_V) = r[63,1];
        $(PSW_SV) = $(PSW_V) | $(PSW_SV);
        $(PSW_AV) = r[63,1] ^ r[62,1];
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}

macro overflowflagsww(r1, r0) {
        $(PSW_V) = r1[31,1] | r0[31,1];
        $(PSW_SV) = $(PSW_V) | $(PSW_SV);
        $(PSW_AV) = (r1[31,1] ^ r1[30,1]) | (r0[31,1] ^ r0[30,1]);
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}

macro advoverflowflagsww(r1, r0) {
        $(PSW_V) = 0;
        $(PSW_AV) = (r1[31,1] ^ r1[30,1]) | (r0[31,1] ^ r0[30,1]);
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}

macro advoverflowflags(r) {
        $(PSW_V) = 0;
        $(PSW_AV) = r[31,1] ^ r[30,1];
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}

macro overflowflags(r) {
        $(PSW_V) = r[31,1];
        $(PSW_SV) = $(PSW_V) | $(PSW_SV);
        $(PSW_AV) = r[31,1] ^ r[30,1];
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}

macro overflowflagsh(r1, r0) {
        $(PSW_V) = r1[15,1] | r0[15,1];
        $(PSW_SV) = $(PSW_V) | $(PSW_SV);
        $(PSW_AV) = (r1[15,1] ^ r1[14,1]) | (r0[15,1] ^ r0[14,1]);
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}

macro overflowflagsb(r3, r2, r1, r0) {
        $(PSW_V) = r3[7,1] | r2[7,1] | r1[7,1] | r0[7,1];
        $(PSW_SV) = $(PSW_V) | $(PSW_SV);
        $(PSW_AV) = (r3[7,1] ^ r3[6,1]) | (r2[7,1] ^ r2[6,1]) | (r1[7,1] ^ r1[6,1]) | (r0[7,1] ^ r0[6,1]);
        $(PSW_SAV) = $(PSW_AV) | $(PSW_SAV);
}


#define pcodeop ssov;
macro ssov(res,x,y) {
        local max_pos = (1 << (y - 1)) - 1;
        local max_neg = -(1 << (y - 1));
	local sc1 = x s> max_pos;
	local sc2 = x s< max_neg;
	res = (max_pos * zext(sc1 != 0)) + (max_neg * zext(sc1 == 0 && sc2 != 0)) + (x * zext(sc1 == 0 && sc2 == 0));
}

#define pcodeop suov;
macro suov(res,x,y) {
        local max_pos = (1 << y) - 1;
	local sc1 = x s> max_pos;
	local sc2 = x s< 0;
	res = (max_pos * zext(sc1 != 0)) + (x * zext(sc1 == 0 && sc2 == 0));
}

macro ternary(res, cond, avar, bvar) {
	res = (avar * zext(cond != 0)) + (bvar * zext(cond == 0));
}

@if defined(TRICORE_VERBOSE)
macro load_lower_context(EA) {
      # dummy = *[ram]:4 EA ;
      EA = EA + 4;
      # dummy = *[ram]:4 EA ;
      EA = EA + 4;
      a2 = *[ram]:4 EA ; EA = EA + 4;
      a3 = *[ram]:4 EA ; EA = EA + 4;
      d0 = *[ram]:4 EA ; EA = EA + 4;
      d1 = *[ram]:4 EA ; EA = EA + 4;
      d2 = *[ram]:4 EA ; EA = EA + 4;
      d3 = *[ram]:4 EA ; EA = EA + 4;
      a4 = *[ram]:4 EA ; EA = EA + 4;
      a5 = *[ram]:4 EA ; EA = EA + 4;
      a6 = *[ram]:4 EA ; EA = EA + 4;
      a7 = *[ram]:4 EA ; EA = EA + 4;
      d4 = *[ram]:4 EA ; EA = EA + 4;
      d5 = *[ram]:4 EA ; EA = EA + 4;
      d6 = *[ram]:4 EA ; EA = EA + 4;
      d7 = *[ram]:4 EA ; EA = EA + 4;
}
@endif

@if defined(TRICORE_VERBOSE)
macro store_lower_context(EA) {
	*[ram]:4 EA = PCXI; EA = EA + 4;
	*[ram]:4 EA = a11; EA = EA + 4;
	*[ram]:4 EA = a2; EA = EA + 4;
	*[ram]:4 EA = a3; EA = EA + 4;
	*[ram]:4 EA = d0; EA = EA + 4;
	*[ram]:4 EA = d1; EA = EA + 4;
	*[ram]:4 EA = d2; EA = EA + 4;
	*[ram]:4 EA = d3; EA = EA + 4;
	*[ram]:4 EA = a4; EA = EA + 4;
	*[ram]:4 EA = a5; EA = EA + 4;
	*[ram]:4 EA = a6; EA = EA + 4;
	*[ram]:4 EA = a7; EA = EA + 4;
	*[ram]:4 EA = d4; EA = EA + 4;
	*[ram]:4 EA = d5; EA = EA + 4;
	*[ram]:4 EA = d6; EA = EA + 4;
	*[ram]:4 EA = d7; EA = EA + 4;
}
@endif

macro _restore_upper_context(EA) {
	a10 = *[ram]:4 EA; EA = EA + 4;
	a11 = *[ram]:4 EA; EA = EA + 4;
	d8 = *[ram]:4 EA; EA = EA + 4;
	d9 = *[ram]:4 EA; EA = EA + 4;
	d10 = *[ram]:4 EA; EA = EA + 4;
	d11 = *[ram]:4 EA; EA = EA + 4;
	a12 = *[ram]:4 EA; EA = EA + 4;
	a13 = *[ram]:4 EA; EA = EA + 4;
	a14 = *[ram]:4 EA; EA = EA + 4;
	a15 = *[ram]:4 EA; EA = EA + 4;
	d12 = *[ram]:4 EA; EA = EA + 4;
	d13 = *[ram]:4 EA; EA = EA + 4;
	d14 = *[ram]:4 EA; EA = EA + 4;
	d15 = *[ram]:4 EA; EA = EA + 4;
}

@if defined(TRICORE_VERBOSE)
macro restore_upper_context(EA) {
	PCXI = *[ram]:4 EA; EA = EA + 4;
	PSW = *[ram]:4 EA; EA = EA + 4;
	_restore_upper_context(EA);
}
@endif


define pcodeop saveCallerState;
define pcodeop restoreCallerState;


@if defined(TRICORE_VERBOSE)
macro restore_debug_context(EA) {
	PCXI = *[ram]:4 EA; EA = EA + 4;
	PSW = *[ram]:4 EA; EA = EA + 4;
	a10 = *[ram]:4 EA; EA = EA + 4;
	a11 = *[ram]:4 EA; EA = EA + 4;
}
@else
define pcodeop restore_debug_context;
@endif

@if defined(TRICORE_VERBOSE)
macro load_upper_context(EA) {
      # dummy = *[ram]:4 EA;
      EA = EA + 4;
      # dummy = *[ram]:4 EA;
      EA = EA + 4;
      _restore_upper_context(EA);
}
@endif

@if defined(TRICORE_VERBOSE)
macro store_upper_context(EA) {
      *[ram]:4 EA = PCXI; EA = EA + 4;
      *[ram]:4 EA = PSW; EA = EA + 4;
      *[ram]:4 EA = a10; EA = EA + 4;
      *[ram]:4 EA = a11; EA = EA + 4;
      *[ram]:4 EA = d8; EA = EA + 4;
      *[ram]:4 EA = d9; EA = EA + 4;
      *[ram]:4 EA = d10; EA = EA + 4;
      *[ram]:4 EA = d11; EA = EA + 4;
      *[ram]:4 EA = a12; EA = EA + 4;
      *[ram]:4 EA = a13; EA = EA + 4;
      *[ram]:4 EA = a14; EA = EA + 4;
      *[ram]:4 EA = a15; EA = EA + 4;
      *[ram]:4 EA = d12; EA = EA + 4;
      *[ram]:4 EA = d13; EA = EA + 4;
      *[ram]:4 EA = d14; EA = EA + 4;
      *[ram]:4 EA = d15; EA = EA + 4;
}
@endif

macro BitReverseAddressingMode(rege, rego, EA) {
      local index:2 = rego[0,16];
      local incr:2 = rego[16,16];
      EA = rege + zext(index);
      local rindex:2 = reverse16(index);
      local rincr:2 = reverse16(incr);
      local new_index:2 = reverse16(rindex + rincr);
      rego[0,16] = new_index;
}

macro CircularAddressingMode(rege, rego, EA0, off10) {
      local index:2 = rego[0,16];
      local length:2 = rego[16,16];
      EA0 = rege + zext(index);
      local new_index:2 = index + off10[0,10];
      ternary(new_index, new_index s< 0, new_index + length, new_index % length);
      rego[0,16] = new_index;
}

macro CircularAddressingMode2(rege, rego, EA0, EA1, off10, circsize) {
      local index:2 = rego[0,16];
      local length:2 = rego[16,16];
      EA0 = rege + zext(index);
      EA1 = rege + zext((index + circsize) % length);
      local new_index:2 = index + off10[0,10];
      ternary(new_index, new_index s< 0, new_index + length, new_index % length);
      rego[0,16] = new_index;
}

macro CircularAddressingMode4(rege, rego, EA0, EA1, EA2, EA3, off10, circsize) {
      local index:2 = rego[0,16];
      local length:2 = rego[16,16];
      EA0 = rege + zext(index);
      EA1 = rege + zext((index + circsize) % length);
      EA2 = rege + zext((index + circsize + circsize) % length);
      EA3 = rege + zext((index + circsize + circsize + circsize) % length);
      local new_index:2 = index + off10[0,10];
      ternary(new_index, new_index s< 0, new_index + length, new_index % length);
      rego[0,16] = new_index;
}

#TODO  Should probably just delete this and any "+i" until referencing a
#      T2 manual instead of DSP/compiler guide
macro IndexAddressingMode(rege, rego, EA) {
      local index:2 = rego[0,16];
      local modifier:2 = rego[16,16];
      EA = rege + zext(index);
      rego[0,16] = index + modifier;
}

off10: reloc is PCPMode=0 & op1621 & sop2831 [ reloc = op1621 | (sop2831 << 6); ] { local tmp:4 = reloc; export tmp; }

off16: reloc is PCPMode=0 & op1621 & sop2227 & op2831 [ reloc = op1621 | (op2831 << 6) | (sop2227 << 10); ] { local tmp:4 = reloc; export tmp; }

off18: reloc is PCPMode=0 & op1215 ; op1621 & op2225 & op2831 [ reloc = (op1215 << 28) | (op2225 << 10) | (op2831 << 6) | op1621; ] { local tmp:4 = reloc; export tmp; }

off24pc: reloc is PCPMode=0 & sop0815 ; op1631 [ reloc = inst_start + ((op1631 | (sop0815 << 16)) * 2); ] { export *[ram]:4 reloc; }

off24abs: reloc is PCPMode=0 & op0811 & op1215 ; op1631 [ reloc = (op1631 << 1) | (op0811 << 17) | (op1215 << 28); ] { export *[ram]:4 reloc; }

off0811pc4o: reloc is PCPMode=0 & op0811 [ reloc = inst_start + (0xffffffe0 | (op0811 << 1)); ] { export *[ram]:4 reloc; }

off0811pc4z: reloc is PCPMode=0 & op0811 [ reloc = inst_start + (op0811 * 2); ] { export *[ram]:4 reloc; }

off0815pc8s: reloc is PCPMode=0 & sop0815 [ reloc = inst_start + (sop0815 * 2); ] { export *[ram]:4 reloc; }

off1630pc15s: reloc is PCPMode=0 & sop1630 [ reloc = inst_start + (sop1630 * 2); ] { export *[ram]:4 reloc; }

@if defined(TRICORE_V2)
off0811pc4z16: reloc is PCPMode=0 & op0811 [ reloc = inst_start + ((op0811 + 16) * 2); ] { export *[ram]:4 reloc; }
@endif

const0607Z: "#"^op0607 is PCPMode=0 & op0607 { local tmp:4 = op0607; export tmp; }

const0810Z: "#"^op0810 is PCPMode=0 & op0810 { local tmp:4 = op0810; export tmp; }

const0811Z6zz: "#"^reloc is PCPMode=0 & op0811 [ reloc = op0811 << 2; ] { local tmp:4 = reloc; export tmp; }

const0811Z: "#"^op0811 is PCPMode=0 & op0811 { local tmp:4 = op0811; export tmp; }

const0811Z5z: "#"^reloc is PCPMode=0 & op0811 [ reloc = op0811 << 1; ] { local tmp:4 = reloc; export tmp; }

const0815Z: "#"^op0815 is PCPMode=0 & op0815 { local tmp:4 = op0815; export tmp; }

const0815Z10zz: "#"^reloc is PCPMode=0 & op0815 [ reloc = op0815 << 2; ] { local tmp:4 = reloc; export tmp; }

const1111Z: "#"^op1111 is PCPMode=0 & op1111 { local tmp:4 = op1111; export tmp; }

const1215S: "#"^sop1215 is PCPMode=0 & sop1215 { local tmp:4 = sop1215; export tmp; }

const1215Z: "#"^op1215 is PCPMode=0 & op1215 { local tmp:4 = op1215; export tmp; }

const1215Z6zz: "#"^reloc is PCPMode=0 & op1215 [ reloc = op1215 << 2; ] { local tmp:4 = reloc; export tmp; }

const1215Z5z: "#"^reloc is PCPMode=0 & op1215 [ reloc = op1215 << 1; ] { local tmp:4 = reloc; export tmp; }

const1220S: "#"^reloc is PCPMode=0 & op1215 ; sop1620 [ reloc = (sop1620 << 4) | op1215; ] { local tmp:4 = reloc; export tmp; }

const1220Z: "#"^reloc is PCPMode=0 & op1215 ; op1620 [ reloc = (op1620 << 4) | op1215; ] { local tmp:4 = reloc; export tmp; }

const1227S: "#"^reloc is PCPMode=0 & op1215 ; sop1627 [ reloc = (sop1627 << 4) | op1215; ] { local tmp:4 = reloc; export tmp; }

const1227Z: "#"^reloc is PCPMode=0 & op1215 ; op1627 [ reloc = (op1627 << 4) | op1215; ] { local tmp:4 = reloc; export tmp; }

const1617Z: "#"^op1617 is PCPMode=0 & op1617 { local tmp:4 = op1617; export tmp; }

const1620Z: "#"^op1620 is PCPMode=0 & op1620 { local tmp:4 = op1620; export tmp; }

const2327Z: "#"^op2327 is PCPMode=0 & op2327 { local tmp:4 = op2327; export tmp; }

Nbit: "#"^reloc is PCPMode=0 & op0707 & op1215 [ reloc = (op0707 << 4) | op1215; ] { local tmp:4 = reloc; export tmp; }



#TODO  circular is seems too compilcated to do this way
#BO: [Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rpe1215 & Rpo1215 & op0003=9 & op0405=2 ; off10 & op2627=1 { local EA:4; CircularAddressingMode(Rpe1215, Rpo1215, EA, off10); export EA; }


BO: [Rpe1215/Rpo1215^"+r"^] is PCPMode=0 & Rpe1215 & Rpo1215 & op0003=9 & op0405=2 ; op1621=0x0 & op2627=0 & op2831=0x0 { local EA:4; BitReverseAddressingMode(Rpe1215, Rpo1215, EA); export EA; }

BO: [Rpe1215/Rpo1215^"+i"^] is PCPMode=0 & Rpe1215 & Rpo1215 & op0003=9 & op0405=2 ; op1621=0x0 & op2627=2 & op2831=0x0 { local EA:4; IndexAddressingMode(Rpe1215, Rpo1215, EA); export EA; }

BO: [Ra1215]off10 is PCPMode=0 & Ra1215 & op0003=9 & op0405=0 ; off10 & op2627=2 { local EA = Ra1215 + off10; export EA; }

BO: [Ra1215+]off10 is PCPMode=0 & Ra1215 & op0003=9 & op0405=0 ; off10 & op2627=0 { local EA = Ra1215; Ra1215 = Ra1215 + off10; export EA; }

BO: [+Ra1215]off10 is PCPMode=0 & Ra1215 & op0003=9 & op0405=0 ; off10 & op2627=1 { Ra1215 = Ra1215 + off10; local EA = Ra1215; export EA; }


BOL: [Ra1215]off16 is PCPMode=0 & Ra1215 ; off16 { local EA = Ra1215 + off16; export EA; }


SSR: [Ra1215] is PCPMode=0 & Ra1215 & op0003=4 & op0405=3 { local EA = Ra1215; export EA; }

SSR: [Ra1215+] is PCPMode=0 & Ra1215 & op0003=4 & op0405=2 & op0606=1 { local EA = Ra1215; Ra1215 = Ra1215 + 4; export EA; }

SSR: [Ra1215+] is PCPMode=0 & Ra1215 & op0003=4 & op0405=2 & op0606=0 & op0707=1 { local EA = Ra1215; Ra1215 = Ra1215 + 2; export EA; }

SSR: [Ra1215+] is PCPMode=0 & Ra1215 & op0003=4 & op0405=2 & op0606=0 & op0707=0 { local EA = Ra1215; Ra1215 = Ra1215 + 1; export EA; }


SLR: [Ra1215] is PCPMode=0 & Ra1215 & op0003=4 & op0405=1 { local EA = Ra1215; export EA; }

SLR: [Ra1215+] is PCPMode=0 & Ra1215 & op0003=4 & op0405=0 & op0606=1 { local EA = Ra1215; Ra1215 = Ra1215 + 4; export EA; }

SLR: [Ra1215+] is PCPMode=0 & Ra1215 & op0003=4 & op0405=0 & op0606=0 & op0707=1 { local EA = Ra1215; Ra1215 = Ra1215 + 2; export EA; }

SLR: [Ra1215+] is PCPMode=0 & Ra1215 & op0003=4 & op0405=0 & op0606=0 & op0707=0 { local EA = Ra1215; Ra1215 = Ra1215 + 1; export EA; }


SRO: [Ra1215]const0811Z is PCPMode=0 & Ra1215 & const0811Z & op0003=0xc & op0404=0 & op0607=0 { local EA = Ra1215 + const0811Z; export EA; }

SRO: [Ra1215]const0811Z5z is PCPMode=0 & Ra1215 & const0811Z5z & op0003=0xc & op0404=0 & op0607=2 { local EA = Ra1215 + const0811Z5z; export EA; }

SRO: [Ra1215]const0811Z6zz is PCPMode=0 & Ra1215 & const0811Z6zz & op0003=0xc & op0404=0 & op0606=1 { local EA = Ra1215 + const0811Z6zz; export EA; }


SLRO: [a15]const1215Z is PCPMode=0 & a15 & const1215Z & op0003=8 & op0405=0 & op0607=0 { local EA = a15 + const1215Z; export EA; }

SLRO: [a15]const1215Z5z is PCPMode=0 & a15 & const1215Z5z & op0003=8 & op0405=0 & op0607=2 { local EA = a15 + const1215Z5z; export EA; }

SLRO: [a15]const1215Z6zz is PCPMode=0 & a15 & const1215Z6zz & op0003=8 & op0405=0 & op0606=1 { local EA = a15 + const1215Z6zz; export EA; }


SSRO: [a15]const1215Z is PCPMode=0 & a15 & const1215Z & op0003=8 & op0405=2 & op0607=0 { local EA = a15 + const1215Z; export EA; }

SSRO: [a15]const1215Z5z is PCPMode=0 & a15 & const1215Z5z & op0003=8 & op0405=2 & op0607=2 { local EA = a15 + const1215Z5z; export EA; }

SSRO: [a15]const1215Z6zz is PCPMode=0 & a15 & const1215Z6zz & op0003=8 & op0405=2 & op0606=1 { local EA = a15 + const1215Z6zz; export EA; }


SC: [a10]const0815Z10zz is PCPMode=0 & a10 & const0815Z10zz & op0003=8 & op0404=1 & op0606=1 { local EA = a10 + const0815Z10zz; export EA; }



# ABS D[c], D[b] (RR)
:abs Rd2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Rd2831 & op1627=0x1c0
{
	Rd2831 = abs(Rd1215);
	overflowflags(Rd2831);
}

# ABS.B D[c], D[b] (RR)
:abs.b Rd2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Rd2831 & op1627=0x5c0
{
	local result3:4 = zext(abs(Rd1215[24,8]));
	local result2:4 = zext(abs(Rd1215[16,8]));
	local result1:4 = zext(abs(Rd1215[8,8]));
	local result0:4 = zext(abs(Rd1215[0,8]));
	overflowflagsb(result3, result2, result1, result0);
	Rd2831[24,8] = result3[0,8];
	Rd2831[16,8] = result2[0,8];
	Rd2831[8,8] = result1[0,8];
	Rd2831[0,8] = result0[0,8];
	
}

# ABS.H D[c], D[b] (RR)
:abs.h Rd2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Rd2831 & op1627=0x7c0
{
	local result1:4 = zext(abs(Rd1215[16,16]));
	local result0:4 = zext(abs(Rd1215[0,16]));
	overflowflagsh(result1, result0);
	Rd2831[16,16] = result1[0,16];
	Rd2831[0,16] = result0[0,16];
}

# ABSDIF D[c], D[a], D[b] (RR)
:absdif Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0xe0
{
	Rd2831 = abs(Rd0811 - Rd1215);
	overflowflags(Rd2831);
}

# ABSDIF D[c], D[a], const9 (RC)
:absdif Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0xe ) & const1220S
{
	Rd2831 = abs(Rd0811 - const1220S);
	overflowflags(Rd2831);
}

# ABSDIF.B D[c], D[a], D[b] (RR)
:absdif.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x4e0
{
	local result3:4 = zext(abs(Rd0811[24,8] - Rd1215[24,8]));
	local result2:4 = zext(abs(Rd0811[16,8] - Rd1215[16,8]));
	local result1:4 = zext(abs(Rd0811[8,8] - Rd1215[8,8]));
	local result0:4 = zext(abs(Rd0811[0,8] - Rd1215[0,8]));
	overflowflagsb(result3, result2, result1, result0);
	Rd2831[24,8] = result3[0,8];
	Rd2831[16,8] = result2[0,8];
	Rd2831[8,8] = result1[0,8];
	Rd2831[0,8] = result0[0,8];
}

# ABSDIF.H D[c], D[a], D[b] (RR)
:absdif.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x6e0
{
	local result1:4 = zext(abs(Rd0811[16,16] - Rd1215[16,16]));
	local result0:4 = zext(abs(Rd0811[0,16] - Rd1215[16,16]));
	overflowflagsh(result1, result0);
	Rd2831[16,16] = result1[0,16];
	Rd2831[0,16] = result0[0,16];
}

# ABSDIFS D[c], D[a], D[b] (RR)
:absdifs Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0xf0
{
	local result:4 = abs(Rd0811 - Rd1215);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# ABSDIFS D[c], D[a], const9 (RC)
:absdifs Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0xf ) & const1220S
{
	local result:4 = abs(Rd0811 - const1220S);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# ABSDIFS.H D[c], D[a], D[b] (RR)
:absdifs.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x6f0
{
	local result1:4 = sext(abs(Rd0811[16,16] - Rd1215[16,16]));
	local result0:4 = sext(abs(Rd0811[0,16] - Rd1215[16,16]));
	overflowflagsh(result1, result0);
	ssov(Rd2831[16,16], result1[0,16], 16);
	ssov(Rd2831[0,16], result0[0,16], 16);
}

# ABSS D[c], D[b] (RR)
:abss Rd2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Rd2831 & op1627=0x1d0
{
	local result:4 = abs(Rd1215);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# ABSS.H D[c], D[b] (RR)
:abss.h Rd2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Rd2831 & op1627=0x7d0
{
	local result1:4 = sext(abs(Rd1215[16,16]));
	local result0:4 = sext(abs(Rd1215[0,16]));
	overflowflagsh(result1, result0);
	ssov(Rd2831[16,16], result1[0,16], 16);
	ssov(Rd2831[0,16], result0[0,16], 16);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADD D[a], D[15], D[b] (SRR)
:add Rd0811,d15,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x12
{
	Rd0811 = d15 + Rd1215;
	overflowflags(Rd0811);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADD D[a], D[15], const4 (SRC)
:add Rd0811,d15,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0x92
{
	Rd0811 = d15 + const1215S;
	overflowflags(Rd0811);
}
@endif

# ADD D[15], D[a], D[b] (SRR)
:add d15,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x1a
{
	d15 = Rd0811 + Rd1215;
	overflowflags(d15);
}

# ADD D[a], D[b] (SRR)
:add Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x42
{
	Rd0811 = Rd0811 + Rd1215;
	overflowflags(Rd0811);
}

# ADD D[15], D[a], const4 (SRC)
:add d15,Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0x9a
{
	d15 = Rd0811 + const1215S;
	overflowflags(d15);
}

# ADD D[a], const4 (SRC)
:add Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & op0007=0xc2
{
	Rd0811 = Rd0811 + const1215S;
	overflowflags(Rd0811);
}

# ADD D[c], D[a], D[b] (RR)
:add Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x0
{
	Rd2831 = Rd0811 + Rd1215;
	overflowflags(Rd2831);
}

# ADD D[c], D[a], const9 (RC)
:add Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x0 ) & const1220S
{
	Rd2831 = Rd0811 + const1220S;
	overflowflags(Rd2831);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADD.A A[a], A[b] (SRR)
:add.a Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x30
{
	Ra0811 = Ra0811 + Ra1215;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADD.A A[a], const4 (SRC)
:add.a Ra0811,const1215S is PCPMode=0 & Ra0811 & const1215S & op0007=0xb0
{
	Ra0811 = Ra0811 + const1215S;
}
@endif

# ADD.A A[c], A[a], A[b] (RR)
:add.a Ra2831,Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x1 ; Ra2831 & op1627=0x10
{
	Ra2831 = Ra0811 + Ra1215;
}

# ADD.B D[c], D[a], D[b] (RR)
:add.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x400
{
	local result3:4 = zext(Rd0811[24,8] + Rd1215[24,8]);
	local result2:4 = zext(Rd0811[16,8] + Rd1215[16,8]);
	local result1:4 = zext(Rd0811[8,8] + Rd1215[8,8]);
	local result0:4 = zext(Rd0811[0,8] + Rd1215[0,8]);
	overflowflagsb(result3, result2, result1, result0);
	Rd2831[24,8] = result3[0,8];
	Rd2831[16,8] = result2[0,8];
	Rd2831[8,8] = result1[0,8];
	Rd2831[0,8] = result0[0,8];
}

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADD.F D[c], D[d], D[a] (RRR)
:add.f Rd2831,Rd2427,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x6b & op1215=0x0 ; Rd2427 & Rd2831 & op1623=0x21
{
	#TODO  float
	#TODO  flags
	Rd2831 = Rd2427 f+ Rd0811;
}
@endif

# ADD.H D[c], D[a], D[b] (RR)
:add.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x600
{
	local result1:4 = zext(Rd0811[16,16] + Rd1215[16,16]);
	local result0:4 = zext(Rd0811[0,16] + Rd1215[0,16]);
	overflowflagsh(result1, result0);
	Rd2831[16,16] = result1[0,16];
	Rd2831[0,16] = result0[0,16];
}

# ADDC D[c], D[a], D[b] (RR)
:addc Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x50
{
	local tmp:5 = zext(Rd0811) + zext(Rd1215) + zext($(PSW_C));
	Rd2831 = tmp[0,32];
	$(PSW_C) = tmp[32,1];
	overflowflags(Rd2831);
}

# ADDC D[c], D[a], const9 (RC)
:addc Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x5 ) & const1220S
{
	local tmp:5 = zext(Rd0811) + zext(const1220S) + zext($(PSW_C));
	Rd2831 = tmp[0,32];
	$(PSW_C) = tmp[32,1];
	overflowflags(Rd2831);
}

# ADDI D[c], D[a], const16 (RLC)
:addi Rd2831,Rd0811,const1227S is PCPMode=0 & ( Rd0811 & op0007=0x1b ; Rd2831 ) & const1227S
{
	Rd2831 = Rd0811 + const1227S;
	overflowflags(Rd2831);
}

# ADDIH D[c], D[a], const16 (RLC)
:addih Rd2831,Rd0811,const1227Z is PCPMode=0 & ( Rd0811 & op0007=0x9b ; Rd2831 ) & const1227Z
{
	Rd2831 = Rd0811 + (const1227Z << 16);
	overflowflags(Rd2831);
}

# ADDIH.A A[c], A[a], const16 (RLC)
:addih.a Ra2831,Ra0811,const1227Z is PCPMode=0 & ( Ra0811 & op0007=0x11 ; Ra2831 ) & const1227Z
{
	Ra2831 = Ra0811 + (const1227Z << 16);
}

# ADDS D[a], D[b], (SRR)
:adds Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x22
{
	local result:4 = Rd0811 + Rd1215;
	overflowflags(result);
	ssov(Rd0811, result, 32);
}

# ADDS D[c], D[a], D[b] (RR)
:adds Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x20
{
	local result:4 = Rd0811 + Rd1215;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# ADDS D[c], D[a], const9 (RC)
:adds Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x2 ) & const1220S
{
	local result:4 = Rd0811 + const1220S;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# ADDS.H D[c], D[a], D[b] (RR)
:adds.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x620
{
	local result1:4 = sext(Rd0811[16,16] + Rd1215[16,16]);
	local result0:4 = sext(Rd0811[0,16] + Rd1215[0,16]);
	overflowflagsh(result1, result0);
	ssov(Rd2831[16,16], result1[0,16], 16);
	ssov(Rd2831[0,16], result0[0,16], 16);
}

# ADDS.HU D[c], D[a], D[b] (RR)
:adds.hu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x630
{
	local result1:4 = sext(Rd0811[16,16] + Rd1215[16,16]);
	local result0:4 = sext(Rd0811[0,16] + Rd1215[0,16]);
	overflowflagsh(result1, result0);
	suov(Rd2831[16,16], result1[0,16], 16);
	suov(Rd2831[0,16], result0[0,16], 16);
}

# ADDS.U D[c], D[a], D[b] (RR)
:adds.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x30
{
	local result:4 = Rd0811 + Rd1215;
	overflowflags(result);
	suov(Rd2831, result, 32);
}

# ADDS.U D[c], D[a], const9 (RC)
:adds.u Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x3 ) & const1220S
{
	local result:4 = Rd0811 + const1220S;
	overflowflags(result);
	suov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADDSC.A A[a], A[b], D[15], n (SRRS)
:addsc.a Ra0811,Ra1215,d15,const0607Z is PCPMode=0 & Ra0811 & Ra1215 & const0607Z & d15 & op0005=0x10
{
	Ra0811 = Ra1215 + (d15 << const0607Z);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADDSC.A A[c], A[b], D[a], n (RR)
:addsc.a Ra2831,Ra1215,Rd0811,const1617Z is PCPMode=0 & Ra1215 & Rd0811 & op0007=0x1 ; Ra2831 & const1617Z & op1827=0x180
{
	Ra2831 = Ra1215 + (Rd0811 << const1617Z);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ADDSC.AT A[c], A[b], D[a] (RR)
:addsc.at Ra2831,Ra1215,Rd0811 is PCPMode=0 & Ra1215 & Rd0811 & op0007=0x1 ; Ra2831 & op1627=0x620
{
	Ra2831 = (Ra1215 + (Rd0811 >> 3)) & 0xFFFFFFFC;
}
@endif

# ADDX D[c], D[a], D[b] (RR)
:addx Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x40
{
	local result:4 = Rd0811 + Rd1215;
	$(PSW_C) = carry(Rd0811, Rd1215);
	overflowflags(result);
	Rd2831 = result;
}

# ADDX D[c], D[a], const9 (RC)
:addx Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x4 ) & const1220S
{
	local result:4 = Rd0811 + const1220S;
	$(PSW_C) = carry(Rd0811, const1220S);
	overflowflags(result);
	Rd2831 = result;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# AND D[a], D[b] (SRR)
:and Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x26
{
	Rd0811 = Rd0811 & Rd1215;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# AND D[15], const8 (SC)
:and d15,const0815Z is PCPMode=0 & const0815Z & d15 & op0007=0x16
{
	d15 = d15 & const0815Z;
}
@endif

# AND D[c], D[a], D[b] (RR)
:and Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x80
{
	Rd2831 = Rd0811 & Rd1215;
}

# AND D[c], D[a], const9 (RC)
:and Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x8 ) & const1220Z
{
	Rd2831 = Rd0811 & const1220Z;
}

# AND.AND.T D[c], D[a], pos1, D[b], pos2 (BIT)
:and.and.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x47 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831[0,1] = Rd2831[0,1] & (tmpa[0,1] & tmpb[0,1]);
}

# AND.ANDN.T D[c], D[a,] pos1, D[b], pos2 (BIT)
:and.andn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x47 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831[0,1] = Rd2831[0,1] & (tmpa[0,1] & ~tmpb[0,1]);
}

# AND.EQ D[c], D[a], D[b] (RR)
:and.eq Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x200
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 == Rd1215);
}

# AND.EQ D[c], D[a], const9 (RC)
:and.eq Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x20 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 == const1220S);
}

# AND.GE D[c], D[a], D[b] (RR)
:and.ge Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x240
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 s>= Rd1215);
}

# AND.GE D[c], D[a], const9 (RC)
:and.ge Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x24 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 s>= const1220S);
}

# AND.GE.U D[c], D[a], D[b] (RR)
:and.ge.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x250
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 >= Rd1215);
}

# AND.GE.U D[c], D[a], const9 (RC)
:and.ge.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x25 ) & const1220Z
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 >= const1220Z);
}

# AND.LT D[c], D[a], D[b] (RR)
:and.lt Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x220
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 s< Rd1215);
}

# AND.LT D[c], D[a], const9 (RC)
:and.lt Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x22 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 s< const1220S);
}

# AND.LT.U D[c], D[a], D[b] (RR)
:and.lt.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x230
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 < Rd1215);
}

# AND.LT.U D[c], D[a], const9 (RC)
:and.lt.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x23 ) & const1220Z
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 < const1220Z);
}

# AND.NE D[c], D[a], D[b] (RR)
:and.ne Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x210
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 != Rd1215);
}

# AND.NE D[c], D[a], const9 (RC)
:and.ne Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x21 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] & (Rd0811 != const1220S);
}

# AND.NOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:and.nor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x47 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831[0,1] = Rd2831[0,1] & !(tmpa[0,1] | tmpb[0,1]);
}

# AND.OR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:and.or.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x47 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831[0,1] = Rd2831[0,1] & (tmpa[0,1] | tmpb[0,1]);
}

# AND.T D[c], D[a], pos1, D[b], pos2 (BIT)
:and.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x87 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831 = zext(tmpa[0,1] & tmpb[0,1]);
}

# ANDN D[c], D[a], D[b] (RR)
:andn Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0xe0
{
	Rd2831 = Rd0811 & ~Rd1215;
}

# ANDN D[c], D[a], const9 (RC)
:andn Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0xe ) & const1220Z
{
	Rd2831 = Rd0811 & ~const1220Z;
}

# ANDN.T D[c], D[a], pos1, D[b], pos2 (BIT)
:andn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x87 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831 = zext(tmpa[0,1] & !tmpb[0,1]);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# BISR const8 (SC)
:bisr const0815Z is PCPMode=0 & const0815Z & op0007=0xe0
{
	#TODO  isr
	# tmp_FCX = FCX;
	# if (FCX == 0) trap(FCU);
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA,16 * word) = {PCXI, a11, a2, a3, d0, d1, d2, d3, a4, a5, a6, a7, d4, d5, d6, d7};
	# PCXI.PCPN = ICR.CCPN;
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 0;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# ICR.IE = 1;
	# ICR.CCPN = const8;
	# if (tmp_FCX == LCX) trap(FCD);
}
@endif

# BISR const9 (RC)
:bisr const1220Z is PCPMode=0 & ( op0007=0xad & op0811=0x0 ; op2131=0x0 ) & const1220Z
{
	#TODO  isr
	# if (FCX == 0) trap(FCU);
	# tmp_FCX = FCX;
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA,16 * word) = {PCXI, a11, a2, a3, d0, d1, d2, d3, a4, a5, a6, a7, d4, d5, d6, d7};
	# PCXI.PCPN = ICR.CCPN;
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 0;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# ICR.IE = 1;
	# ICR.CCPN = const9[7:0];
	# if (tmp_FCX == LCX) trap(FCD);
}


@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# BMERGE D[c], D[a], D[b] (RR)
:bmerge Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x10
{
@if defined(TRICORE_VERBOSE)
	Rd2831[31,1] = Rd0811[15,1];
	Rd2831[30,1] = Rd1215[15,1];
	Rd2831[29,1] = Rd0811[14,1];
	Rd2831[28,1] = Rd1215[14,1];
	Rd2831[27,1] = Rd0811[13,1];
	Rd2831[26,1] = Rd1215[13,1];
	Rd2831[25,1] = Rd0811[12,1];
	Rd2831[24,1] = Rd1215[12,1];
	Rd2831[23,1] = Rd0811[11,1];
	Rd2831[22,1] = Rd1215[11,1];
	Rd2831[21,1] = Rd0811[10,1];
	Rd2831[20,1] = Rd1215[10,1];
	Rd2831[19,1] = Rd0811[9,1];
	Rd2831[18,1] = Rd1215[9,1];
	Rd2831[17,1] = Rd0811[8,1];
	Rd2831[16,1] = Rd1215[8,1];
	Rd2831[15,1] = Rd0811[7,1];
	Rd2831[14,1] = Rd1215[7,1];
	Rd2831[13,1] = Rd0811[6,1];
	Rd2831[12,1] = Rd1215[6,1];
	Rd2831[11,1] = Rd0811[5,1];
	Rd2831[10,1] = Rd1215[5,1];
	Rd2831[9,1] = Rd0811[4,1];
	Rd2831[8,1] = Rd1215[4,1];
	Rd2831[7,1] = Rd0811[3,1];
	Rd2831[6,1] = Rd1215[3,1];
	Rd2831[5,1] = Rd0811[2,1];
	Rd2831[4,1] = Rd1215[2,1];
	Rd2831[3,1] = Rd0811[1,1];
	Rd2831[2,1] = Rd1215[1,1];
	Rd2831[1,1] = Rd0811[0,1];
	Rd2831[0,1] = Rd1215[0,1];
@else
	bmerge(Rd2831,Rd0811,Rd1215);
@endif
}
@endif


@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# BSPLIT E[c], D[a] (RR)
:bsplit Re2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Re2831 & op1627=0x90
{
@if defined(TRICORE_VERBOSE)
	Re2831[48,16] = 0;
	Re2831[47,1] = Rd0811[31,1];
	Re2831[46,1] = Rd0811[29,1];
	Re2831[45,1] = Rd0811[27,1];
	Re2831[44,1] = Rd0811[25,1];
	Re2831[43,1] = Rd0811[23,1];
	Re2831[42,1] = Rd0811[21,1];
	Re2831[41,1] = Rd0811[19,1];
	Re2831[40,1] = Rd0811[17,1];
	Re2831[39,1] = Rd0811[15,1];
	Re2831[38,1] = Rd0811[13,1];
	Re2831[37,1] = Rd0811[11,1];
	Re2831[36,1] = Rd0811[9,1];
	Re2831[35,1] = Rd0811[7,1];
	Re2831[34,1] = Rd0811[5,1];
	Re2831[33,1] = Rd0811[3,1];
	Re2831[32,1] = Rd0811[1,1];
	Re2831[16,16] = 0;
	Re2831[15,1] = Rd0811[30,1];
	Re2831[14,1] = Rd0811[28,1];
	Re2831[13,1] = Rd0811[26,1];
	Re2831[12,1] = Rd0811[24,1];
	Re2831[11,1] = Rd0811[22,1];
	Re2831[10,1] = Rd0811[20,1];
	Re2831[9,1] = Rd0811[18,1];
	Re2831[8,1] = Rd0811[16,1];
	Re2831[7,1] = Rd0811[14,1];
	Re2831[6,1] = Rd0811[12,1];
	Re2831[5,1] = Rd0811[10,1];
	Re2831[4,1] = Rd0811[8,1];
	Re2831[3,1] = Rd0811[6,1];
	Re2831[2,1] = Rd0811[4,1];
	Re2831[1,1] = Rd0811[2,1];
	Re2831[0,1] = Rd0811[0,1];
@else
	bsplit(Re2831,Rd0811);
@endif
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# CACHEA.I A[b], off10 (BO) (Post-increment Addressing Mode)
# CACHEA.I P[b] (BO) (Bit Reverse Addressing Mode)
# CACHEA.I A[b], off10 (BO) (Pre-increment Addressing Mode)
# CACHEA.I A[b], off10 (BO) (Base + Short Offset Addressing Mode)
# CACHEA.I P[b] (BO) (Index Addressing Mode)
:cachea.i BO is PCPMode=0 & ( op0607=0x2 & op0811=0x0 ; op2225=0xe ) & BO
{
	build BO;
	cache_address_ivld(BO);
}

# CACHEA.I P[b], off10 (BO) (Circular Addressing Mode)
#:cachea.i BO is PCPMode=0 & ( op0007=0xa9 & op0811=0x0 ; op2227=0x1e ) & BO
:cachea.i [Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rpe1215 & Rpo1215 & op0007=0xa9 & op0811=0x0 ; off10 & op2227=0x1e
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	cache_address_ivld(EA);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# CACHEA.W A[b], off10 (BO) (Post-increment Addressing Mode)
# CACHEA.W P[b] (BO) (Bit-reverse Addressing Mode)
# CACHEA.W A[b], off10 (BO) (Pre-increment Addressing Mode)
# CACHEA.W A[b], off10 (BO) (Base + Short Offset Addressing Mode)
# CACHEA.W P[b] (BO) (Index Addressing Mode)
:cachea.w BO is PCPMode=0 & ( op0607=0x2 & op0811=0x0 ; op2225=0xc ) & BO
{
	build BO;
	cache_address_wb(BO);
}

# CACHEA.W P[b], off10 (BO)(Circular Addressing Mode)
#:cachea.w BO is PCPMode=0 & ( op0007=0xa9 & op0811=0x0 ; op2227=0x1c ) & BO
:cachea.w [Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rpe1215 & Rpo1215 & op0007=0xa9 & op0811=0x0 ; off10 & op2227=0x1c
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	cache_address_wb(EA);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# CACHEA.WI A[b], off10 (BO)(Post-increment Addressing Mode)
# CACHEA.WI P[b] (BO)(Bit-reverse Addressing Mode)
# CACHEA.WI A[b], off10 (BO)(Pre-increment Addressing Mode)
# CACHEA.WI A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# CACHEA.WI P[b] (BO)(Index Addressing Mode)
:cachea.wi BO is PCPMode=0 & ( op0607=0x2 & op0811=0x0 ; op2225=0xd ) & BO
{
	build BO;
	cache_address_wi(BO);
}

# CACHEA.WI P[b], off10 (BO) (Circular Addressing Mode)
#:cachea.wi BO is PCPMode=0 & ( op0007=0xa9 & op0811=0x0 ; op2227=0x1d ) & BO
:cachea.wi [Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rpe1215 & Rpo1215 & op0007=0xa9 & op0811=0x0 ; off10 & op2227=0x1d
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	cache_address_wi(EA);
}
@endif

@if defined(TRICORE_V2)
# CACHEI.I A[b], off10 (BO)(Post-increment Addressing Mode)
# CACHEI.I A[b], off10 (BO)(Pre-increment Addressing Mode)
# CACHEI.I A[b], off10 (BO)(Base + Short Offset Addressing Mode)
:cachei.i BO is PCPMode=0 & ( op0407=0x8 & op0811=0x0 ; op2225=0xa ) & BO
{
	build BO;
	cache_index_ivld(BO);
}
@endif

@if defined(TRICORE_V2)
# CACHEI.W A[b], off10 (BO)(Post-increment Addressing Mode)
# CACHEI.W A[b], off10 (BO)(Pre-increment Addressing Mode)
# CACHEI.W A[b], off10 (BO)(Base + Short Offset Addressing Mode)
:cachei.w BO is PCPMode=0 & ( op0407=0x8 & op0811=0x0 ; op2225=0xb ) & BO
{
	build BO;
	cache_index_wb(BO);
}
@endif

@if defined(TRICORE_V2)
# CACHEI.WI A[b], off10 (BO)(Post-increment Addressing Mode)
# CACHEI.WI A[b], off10 (BO)(Pre-increment Addressing Mode)
# CACHEI.WI A[b], off10 (BO)(Base + Short Offset Addressing Mode)
:cachei.wi BO is PCPMode=0 & ( op0407=0x8 & op0811=0x0 ; op2225=0xf ) & BO
{
	build BO;
	cache_index_wi(BO);
}
@endif

# CADD D[a], D[15], const4 (SRC)
:cadd Rd0811,d15,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0x8a
{
	local result:4;
	ternary(result, d15 != 0, Rd0811 + const1215S, Rd0811);
	overflowflags(result);
	Rd0811 = result;
}

# CADD D[c], D[d], D[a], D[b] (RRR)
:cadd Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2b ; Rd2427 & Rd2831 & op1623=0x0
{
	local result:4;
	ternary(result, Rd2427 != 0, Rd0811 + Rd1215, Rd0811);
	overflowflags(result);
	Rd2831 = result;
}

# CADD D[c], D[d], D[a], const9 (RCR)
:cadd Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0xab ; Rd2427 & Rd2831 & op2123=0x0 ) & const1220S
{
	local result:4;
	ternary(result, Rd2427 != 0, Rd0811 + const1220S, Rd0811);
	overflowflags(result);
	Rd2831 = result;
}

# CADDN D[a], D[15], const4 (SRC)
:caddn Rd0811,d15,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0xca
{
	local result:4;
	ternary(result, d15 == 0, Rd0811 + const1215S, Rd0811);
	overflowflags(result);
	Rd0811 = result;
}

# CADDN D[c], D[d], D[a], D[b] (RRR)
:caddn Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2b ; Rd2427 & Rd2831 & op1623=0x10
{
	local result:4;
	ternary(result, Rd2427 == 0, Rd0811 + Rd1215, Rd0811);
	overflowflags(result);
	Rd2831 = result;
}

# CADDN D[c], D[d], D[a], const9 (RCR)
:caddn Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0xab ; Rd2427 & Rd2831 & op2123=0x1 ) & const1220S
{
	local result:4;
	ternary(result, Rd2427 == 0, Rd0811 + const1220S, Rd0811);
	overflowflags(result);
	Rd2831 = result;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# CALL disp8 (SB)
:call off0815pc8s is PCPMode=0 & off0815pc8s & op0007=0x5c
{
	#TODO  call
	# if (FCX == 0) trap(FCU);
	# if (PSW.CDE) then if(cdc_increment()) then trap(CDO);
	# PSW.CDE = 1;
	# ret_addr = PC + 2 ;
	# tmp_FCX = FCX;
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA,16 * word) = {PCXI,PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15};
	# PCXI.PCPN = ICR.CCPN;
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 1;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# PC = PC + sign_ext(2 * disp8);
	# A[11] = ret_addr[31:0];
	# if (tmp_FCX == LCX) trap(FCD);

	saveCallerState(FCX, LCX, PCXI);
	a11 = inst_next;
	call off0815pc8s;
}
@endif

# CALL disp24 (B)
:call off24pc is PCPMode=0 & ( op0007=0x6d ) ... & off24pc
{
	#TODO  call
	# if (FCX == 0) trap(FCU);
	# if (PSW.CDE) then if (cdc_increment()) then trap(CDO);
	# PSW.CDE = 1;
	# ret_addr = PC + 4;
	# tmp_FCX = FCX;
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA,16 * word) = {PCXI,PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15};
	# PCXI.PCPN = ICR.CCPN;
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 1;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# PC = PC + sign_ext(2 * disp24);
	# A[11] = ret_addr[31:0];
	# if (tmp_FCX == LCX) trap(FCD);

	saveCallerState(FCX, LCX, PCXI);
	a11 = inst_next;
	call off24pc;
}

# CALLA disp24 (B)
:calla off24abs is PCPMode=0 & ( op0007=0xed ) ... & off24abs
{
	#TODO  call
	# if (FCX == 0) trap(FCU);
	# if (PSW.CDE) then if (cdc_increment()) then trap(CDO);
	# PSW.CDE = 1;
	# ret_addr = PC + 4;
	# tmp_FCX = FCX;
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA,16 * word) = {PCXI,PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15};
	# PCXI.PCPN = ICR.CCPN;
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 1;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# PC = {disp24[23:20], 7'b0, disp24[19:0], 1'b0};
	# A[11] = ret_addr[31:0];
	# if (tmp_FCX == LCX) trap(FCD);

	saveCallerState(FCX, LCX, PCXI);
	a11 = inst_next;
	call off24abs;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# CALLI A[a] (RR)
:calli Ra0811 is PCPMode=0 & Ra0811 & op0007=0x2d & op1215=0x0 ; op1631=0x0
{
	#TODO  call
	# if (FCX == 0) trap(FCU);
	# if (PSW.CDE) then if(cdc_increment()) then trap(CDO);
	# PSW.CDE = 1;
	# ret_addr = PC + 4;
	# tmp_FCX = FCX;
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA,16 * word) = {PCXI,PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15};
	# PCXI.PCPN = ICR.CCPN;
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 1;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# PC = {A[a][31:1], 1'b0};
	# A[11] = ret_addr[31:0];
	# if (tmp_FCX == LCX) trap(FCD);

	saveCallerState(FCX, LCX, PCXI);
	a11 = inst_next;
	local tmp:4 = Ra0811 & 0xFFFFFFFE;
	call [tmp];
}
@endif

# CLO D[c], D[a] (RR)
:clo Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xf & op1215=0x0 ; Rd2831 & op1627=0x1c0
{
	Rd2831 = leading_ones(Rd0811);
}

# CLO.H D[c], D[a] (RR)
:clo.h Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xf & op1215=0x0 ; Rd2831 & op1627=0x7d0
{
	local tmp1:4 = zext(Rd0811[16,16]);
	local tmp0:4 = zext(Rd0811[0,16]);
	Rd2831[16,16] = leading_ones(tmp1);
	Rd2831[0,16] = leading_ones(tmp0);
}

# CLS D[c], D[a] (RR)
:cls Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xf & op1215=0x0 ; Rd2831 & op1627=0x1d0
{
	Rd2831 = leading_signs(Rd0811) - 1;
}

# CLS.H D[c], D[a] (RR)
:cls.h Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xf & op1215=0x0 ; Rd2831 & op1627=0x7e0
{
	local tmp1:4 = zext(Rd0811[16,16]);
	local tmp0:4 = zext(Rd0811[0,16]);
	Rd2831[16,16] = leading_signs(tmp1) - 1;
	Rd2831[0,16] = leading_signs(tmp0) - 1;
}

# CLZ D[c], D[a] (RR)
:clz Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xf & op1215=0x0 ; Rd2831 & op1627=0x1b0
{
	Rd2831 = leading_zeros(Rd0811);
}

# CLZ.H D[c], D[a] (RR)
:clz.h Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xf & op1215=0x0 ; Rd2831 & op1627=0x7c0
{
	local result:4 = (leading_zeros(Rd0811[16,16]) << 16) | leading_zeros(Rd0811[0,16]);
	Rd2831 = result;
}

# CMOV D[a], D[15], D[b] (SRR)
:cmov Rd0811,d15,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x2a
{
	ternary(Rd0811, d15 != 0, Rd1215, Rd0811);
}

# CMOV D[a], D[15], const4 (SRC)
:cmov Rd0811,d15,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0xaa
{
	ternary(Rd0811, d15 != 0, const1215S, Rd0811);
}

# CMOVN D[a], D[15], D[b] (SRR)
:cmovn Rd0811,d15,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x6a
{
	ternary(Rd0811, d15 == 0, Rd1215, Rd0811);
}

# CMOVN D[a], D[15], const4 (SRC)
:cmovn Rd0811,d15,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0xea
{
	ternary(Rd0811, d15 == 0, const1215S, Rd0811);
}

@if defined(TRICORE_V2)
# CMPSWAP.W A[b], off10, E[a] (BO)(Base + Short Offset Addressing Mode)
# CMPSWAP.W P[b], E[a] (BO)(Bit-reverse Addressing Mode)
# CMPSWAP.W A[b], off10, E[a] (BO)(Post-increment Addressing Mode)
# CMPSWAP.W A[b], off10, E[a] (BO)(Pre-increment Addressing Mode)
# CMPSWAP.W P[b], E[a] (BO)(Index Addressing Mode)
:cmpswap.w BO,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0607=0x1 ; op2225=0x3 ) & BO
{
	build BO;
	local tmp:4 = *[ram]:4 BO;
	Ree0811 = tmp;
	ternary(tmp, tmp == Reo0811, Ree0811, tmp);
	*[ram]:4 BO = tmp;
}
@endif

@if defined(TRICORE_V2)
# CMPSWAP.W P[b], off10, E[a] (BO)(Circular Addressing Mode)
#:cmpswap.w BO,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0007=0x69 ; op2227=0x13 ) & BO
:cmpswap.w [Rpe1215/Rpo1215^"+c"^]off10,Ree0811/Reo0811 is PCPMode=0 & Ree0811 & Reo0811 & Rpe1215 & Rpo1215 & op0007=0x69 ; off10 & op2227=0x13
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	local tmp:4 = *[ram]:4 EA;
	Ree0811 = tmp;
	ternary(tmp, tmp == Reo0811, Ree0811, tmp);
	*[ram]:4 EA = tmp;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# CMP.F D[c], D[a], D[b] (RR)
:cmp.f Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x1
{
	#TODO  float
	#TODO  flags
	local tmpDa = Rd0811;
	local tmpDb = Rd1215;
	Rd2831 = 0;
	Rd2831[0,1] = tmpDa f< tmpDb;
	Rd2831[1,1] = tmpDa f== tmpDb;
	Rd2831[2,1] = tmpDa f> tmpDb;
	Rd2831[3,1] = nan(tmpDa) || nan(tmpDb);
	Rd2831[4,1] = tmpDa[23,8] == 0 && tmpDa[0,23] != 0;
	Rd2831[5,1] = tmpDb[23,8] == 0 && tmpDb[0,23] != 0;
}
@endif

:cop op2027[op1617],Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; op1617 & op2027 & Rd2831 & op1819=0x0
{
	# Rd2831 = op2027[op1617](Rd0811,Rd1215);
	local op2:4 = op2027;
	local proc:4 = op1617;
	Rd2831 = coprocessor(op2, proc, Rd0811, Rd1215);
}

:cop op2023[op1617],Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x6b ; op1617 & op2023 & Rd2427 & Rd2831 & op1819=0x0
{
	# Rd2831 = op2023[op1617](Rd2427,Rd0811,Rd1215);
	local op2:4 = op2023;
	local proc:4 = op1617;
	Rd2831 = coprocessor(op2, proc, Rd2427, Rd0811, Rd1215);
}

@if defined(TRICORE_V2)
# CRC32 D[c], D[b], D[a] (RR)
:crc32 Rd2831,Rd1215,Rd0811 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x30
{
	#TODO  crc of Rd0811 and the inverse of Rd1215 into Rd2831
	#      crc is crc32, initial value of Rd1215 should be zero
	Rd2831 = crc32(Rd1215, Rd0811);
}
@endif

# CSUB D[c], D[d], D[a], D[b] (RRR)
:csub Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2b ; Rd2427 & Rd2831 & op1623=0x20
{
	local result:4;
	ternary(result, Rd2427 != 0, Rd0811 - Rd1215, Rd0811);
	overflowflags(result);
	Rd2831 = result;
}

# CSUBN D[c], D[d], D[a], D[b] (RRR)
:csubn Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2b ; Rd2427 & Rd2831 & op1623=0x30
{
	local result:4;
	ternary(result, Rd2427 != 0, Rd0811, Rd1215);
	overflowflags(result);
	Rd2831 = result;
}

# DEBUG (SR)
:debug  is PCPMode=0 & op0007=0x0 & op0815=0xa0
{
	if ($(DBGSR_DE) == 0) goto inst_next;
	debug();
}

# DEBUG (SYS)
:debug  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x100
{
	if ($(DBGSR_DE) == 0) goto inst_next;
	debug();
}

# DEXTR D[c], D[a], D[b], pos (RRPW)
:dextr Rd2831,Rd0811,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x77 ; Rd2831 & const2327Z & op1622=0x0
{
	local tmp:8 = (zext(Rd0811) << 32) | (zext(Rd1215) << const2327Z);
	Rd2831 = tmp[32,32];
}

# DEXTR D[c], D[a], D[b], D[d] (RRRR)
:dextr Rd2831,Rd0811,Rd1215,Rd2427 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x17 ; Rd2427 & Rd2831 & op1623=0x80
{
	local tmp:8 = (zext(Rd0811) << 32) | (zext(Rd1215) << Rd2427[0,5]);
	Rd2831 = tmp[32,32];
}

# DISABLE (SYS)
:disable  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x340
{
	$(ICR_IE) = 0;
}

@if defined(TRICORE_V2)
# DISABLE D[a] (SYS)
:disable Rd0811 is PCPMode=0 & Rd0811 & op0007=0xd & op1215=0x0 ; op1631=0x3c0
{
	Rd0811 = zext($(ICR_IE));
	$(ICR_IE) = 0;
}
@endif

# DIV E[c], D[a], D[b] (RR)
:div Ree2831/Reo2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Ree2831 & Reo2831 & op1627=0x201
{
	#TODO  divide
	#TODO  flags
	local divres = Rd0811 s/ Rd1215;
	local divmod = Rd0811 s% Rd1215;
	Ree2831 = divres;
	Reo2831 = divmod;
}

# DIV.U E[c], D[a], D[b] (RR)
:div.u Ree2831/Reo2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Ree2831 & Reo2831 & op1627=0x211
{
	#TODO  divide
	#TODO  flags
	local divres = Rd0811 / Rd1215;
	local divmod = Rd0811 % Rd1215;
	Ree2831 = divres;
	Reo2831 = divmod;
}

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DIV.F D[c], D[a], D[b] (RR)
:div.f Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x51
{
	#TODO  float
	#TODO  divide
	#TODO  flags
	Rd2831 = Rd0811 f/ Rd1215;
}
@endif

# DSYNC (SYS)
:dsync  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x480
{
	dsync();
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVADJ E[c], E[d], D[b] (RRR)
:dvadj Ree2831/Reo2831,Ree2427/Reo2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & op1623=0xd0
{
	#TODO  divide sequence
	local q_sign = Reo2427[31,1] ^ Rd1215[31,1];
	local x_sign = Reo2427[31,1];
	local eq_pos = x_sign & (Reo2427 == Rd1215);
	local eq_neg = x_sign & (Reo2427 == -Rd1215);
	local quotient:4;
	ternary(quotient, ((q_sign & ~eq_neg) | eq_pos), Ree2427 + 1, Ree2427);
	local remainder:4;
	ternary(remainder, (eq_pos | eq_neg), 0, Reo2427);
	local _gt = abs(Reo2427) > abs(Rd1215);
	local _eq = !x_sign && (abs(Reo2427) == abs(Rd1215));
	ternary(Reo2831, (_eq | _gt) != 0, 0, remainder);
	ternary(Ree2831, (_eq | _gt) != 0, 0, quotient);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVINIT E[c], D[a], D[b] (RR)
:dvinit Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Re2831 & op1627=0x1a0
{
	#TODO  divide sequence
	Re2831 = sext(Rd0811);
	$(PSW_V) = ((Rd1215 == 0) || ((Rd1215 == 0xFFFFFFFF) && (Rd0811 == 0x80000000)));
	$(PSW_SV) = $(PSW_V) | $(PSW_SV);
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVINIT.B E[c], D[a], D[b] (RR)
:dvinit.b Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Re2831 & op1627=0x5a0
{
	#TODO  divide sequence
	local quotient_sign = !(Rd0811[31,1] == Rd1215[31,1]);
	Re2831[24,40] = sext(Rd0811);
	ternary(Re2831[0,24], quotient_sign, 0xFFFFFF, 0);
	$(PSW_V) = ((Rd1215 == 0) || ((Rd1215 == 0xFFFFFFFF) && (Rd0811 == 0xFFFFFF80)));
	$(PSW_SV) = $(PSW_V) | $(PSW_SV);
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVINIT.BU E[c], D[a], D[b] (RR)
:dvinit.bu Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Re2831 & op1627=0x4a0
{
	#TODO  divide sequence
	Re2831 = zext(Rd0811) << 24;
	$(PSW_V) = (Rd1215 == 0);
	$(PSW_SV) = $(PSW_V) | $(PSW_SV);
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVINIT.H E[c], D[a], D[b] (RR)
:dvinit.h Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Re2831 & op1627=0x3a0
{
	#TODO  divide sequence
	local quotient_sign = !(Rd0811[31,1] == Rd1215[31,1]);
	Re2831 = (sext(Rd0811) << 16) | zext(quotient_sign * 0xffff);
	$(PSW_V) = ((Rd1215 == 0) || ((Rd1215 == 0xFFFFFFFF) && (Rd0811 == 0xFFFF8000)));
	$(PSW_SV) = $(PSW_V) | $(PSW_SV);
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVINIT.HU E[c], D[a], D[b] (RR)
:dvinit.hu Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Re2831 & op1627=0x2a0
{
	#TODO  divide sequence
	Re2831 = zext(Rd0811) << 16;
	$(PSW_V) = (Rd1215 == 0);
	$(PSW_SV) = $(PSW_V) | $(PSW_SV);
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVINIT.U E[c], D[a], D[b] (RR)
:dvinit.u Ree2831/Reo2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Ree2831 & Reo2831 & op1627=0xa0
{
	#TODO  divide sequence
	local tmp:4 = Rd0811;
	Reo2831 = 0;
	Ree2831 = tmp;
	$(PSW_V) = (Rd1215 == 0);
	$(PSW_SV) = $(PSW_V) | $(PSW_SV);
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVSTEP E[c], E[d], D[b] (RRR)
:dvstep Ree2831/Reo2831,Ree2427/Reo2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & op1623=0xf0
{
	#TODO  divide sequence
	local dividend_sign = Reo2427[31,1] == 1;
	local divisor_sign = Rd1215[31,1] == 1;
	local quotient_sign = dividend_sign != divisor_sign;
	local addend:4;
	ternary(addend, quotient_sign != 0, Rd1215, 0 - Rd1215);
	local dividend_quotient:4 = Ree2427;
	local remainder:4 = Reo2427;
	local temp:4 = 0;
	local index:1 = 0;
    <loop_start>
	remainder = (remainder << 1) | zext(dividend_quotient[31,1]);
	dividend_quotient = dividend_quotient << 1;
	temp = remainder + addend;
	ternary(remainder, (temp s< 0) == dividend_sign, temp, remainder);
	ternary(temp, (temp s< 0) == dividend_sign, zext(!quotient_sign), zext(quotient_sign));
	dividend_quotient = dividend_quotient | temp;
	index = index + 1;
	if (index < 8) goto <loop_start>;
	Reo2831 = remainder;
	Ree2831 = dividend_quotient;
}
@endif


@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# DVSTEP.U E[c], E[d], D[b] (RRR)
:dvstep.u Ree2831/Reo2831,Ree2427/Reo2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & op1623=0xe0
{
	#TODO  divide sequence
	local divisor = Rd1215;
	local dividend_quotient = Ree2427;
	local remainder = Reo2427;
	local temp:4 = 0;
	local index:1 = 0;
    <loop_start>
	remainder = (remainder << 1) | zext(dividend_quotient[31,1]);
	dividend_quotient = dividend_quotient << 1;
	temp = remainder - divisor;
	ternary(remainder, temp s< 0, remainder, temp);
	dividend_quotient = dividend_quotient | zext(!(temp s< 0));
	index = index + 1;
	if (index < 8) goto <loop_start>;
	Reo2427 = remainder;
	Ree2427 = dividend_quotient;
}
@endif

# ENABLE (SYS)
:enable  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x300
{
	$(ICR_IE) = 1;
}

# EQ D[15], D[a], D[b] (SRR)
:eq d15,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x3a
{
	d15 = zext(Rd0811 == Rd1215);
}

# EQ D[15], D[a], const4 (SRC)
:eq d15,Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0xba
{
	d15 = zext(Rd0811 == const1215S);
}

# EQ D[c], D[a], D[b] (RR)
:eq Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x100
{
	Rd2831 = zext(Rd0811 == Rd1215);
}

# EQ D[c], D[a], const9 (RC)
:eq Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x10 ) & const1220S
{
	Rd2831 = zext(Rd0811 == const1220S);
}

# EQ.A D[c], A[a], A[b] (RR)
:eq.a Rd2831,Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x1 ; Rd2831 & op1627=0x400
{
	Rd2831 = zext(Ra0811 == Ra1215);
}

# EQ.B D[c], D[a], D[b] (RR)
:eq.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x500
{
	local result3:4 = 0xff * zext(Rd0811[24,8] == Rd1215[24,8]);
	local result2:4 = 0xff * zext(Rd0811[16,8] == Rd1215[16,8]);
	local result1:4 = 0xff * zext(Rd0811[8,8] == Rd1215[8,8]);
	local result0:4 = 0xff * zext(Rd0811[0,8] == Rd1215[0,8]);
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# EQ.H D[c], D[a], D[b] (RR)
:eq.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x700
{
	local result1:4 = 0xffff * zext(Rd0811[16,16] == Rd1215[16,16]);
	local result0:4 = 0xffff * zext(Rd0811[0,16] == Rd1215[0,16]);
	Rd2831 = (result1 << 16) | (result0);
}

# EQ.W D[c], D[a], D[b] (RR)
:eq.w Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x900
{
	Rd2831 = 0xffffffff * zext(Rd0811 == Rd1215);
}

# EQANY.B D[c], D[a], D[b] (RR)
:eqany.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x560
{
	local result3 = Rd0811[24,8] == Rd1215[24,8];
	local result2 = Rd0811[16,8] == Rd1215[16,8];
	local result1 = Rd0811[8,8] == Rd1215[8,8];
	local result0 = Rd0811[0,8] == Rd1215[0,8];
	Rd2831 = zext(result3 | result2 | result1 | result0);
}

# EQANY.B D[c], D[a], const9 (RC)
:eqany.b Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x56 ) & const1220S
{
	local result3 = Rd0811[24,8] == const1220S[24,8];
	local result2 = Rd0811[16,8] == const1220S[16,8];
	local result1 = Rd0811[8,8] == const1220S[8,8];
	local result0 = Rd0811[0,8] == const1220S[0,8];
	Rd2831 = zext(result3 | result2 | result1 | result0);
}

# EQANY.H D[c], D[a], D[b] (RR)
:eqany.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x760
{
	local result1 = Rd0811[16,16] == Rd1215[16,16];
	local result0 = Rd0811[0,16] == Rd1215[0,16];
	Rd2831 = zext(result1 | result0);
}

# EQANY.H D[c], D[a], const9 (RC)
:eqany.h Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x76 ) & const1220S
{
	local result1 = Rd0811[16,16] == const1220S[16,16];
	local result0 = Rd0811[0,16] == const1220S[0,16];
	Rd2831 = zext(result1 | result0);
}

# EQZ.A D[c], A[a] (RR)
:eqz.a Rd2831,Ra0811 is PCPMode=0 & Ra0811 & op0007=0x1 & op1215=0x0 ; Rd2831 & op1627=0x480
{
	Rd2831 = zext(Ra0811 == 0);
}

# EXTR D[c], D[a], E[d] (RRRR)
:extr Rd2831,Rd0811,Ree2427/Reo2427 is PCPMode=0 & Rd0811 & op0007=0x17 & op1215=0x0 ; Rd2831 & Ree2427 & Reo2427 & op1623=0x40
{
	local shift:4 = zext(Ree2427[0,5]);
	local tmp:4 = (Rd0811 << (32 - shift - zext(Reo2427[0,5]))) s>> (32 - zext(Reo2427[0,5]));
	Rd2831 = tmp;
}

# EXTR D[c], D[a], pos, width (RRPW)
:extr Rd2831,Rd0811,const2327Z,const1620Z is PCPMode=0 & Rd0811 & op0007=0x37 & op1215=0x0 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local shift:4 = const2327Z;
	local tmp:4 = (Rd0811 << (32 - shift - const1620Z)) s>> (32 - const1620Z);
	Rd2831 = tmp;
}

# EXTR D[c], D[a], D[d], width (RRRW)
:extr Rd2831,Rd0811,Rd2427,const1620Z is PCPMode=0 & Rd0811 & op0007=0x57 & op1215=0x0 ; Rd2427 & Rd2831 & const1620Z & op2123=0x2
{
	local shift:4 = zext(Rd2427[0,5]);
	local tmp:4 = (Rd0811 << (32 - shift - const1620Z)) s>> (32 - const1620Z);
	Rd2831 = tmp;
}

# EXTR.U D[c], D[a], E[d] (RRRR)
:extr.u Rd2831,Rd0811,Ree2427/Reo2427 is PCPMode=0 & Rd0811 & op0007=0x17 & op1215=0x0 ; Rd2831 & Ree2427 & Reo2427 & op1623=0x60
{
	local tmp:4 = Rd0811 >> Ree2427[0,5];
	local mask:4 = (1 << Reo2427[0,5]) - 1;
	Rd2831 = tmp & mask;
}

# EXTR.U D[c], D[a], pos, width (RRPW)
:extr.u Rd2831,Rd0811,const2327Z,const1620Z is PCPMode=0 & Rd0811 & op0007=0x37 & op1215=0x0 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local tmp:4 = Rd0811 >> const2327Z;
	local mask:4 = (1 << const1620Z) - 1;
	Rd2831 = tmp & mask;
}

# EXTR.U D[c], D[a], D[d], width (RRRW)
:extr.u Rd2831,Rd0811,Rd2427,const1620Z is PCPMode=0 & Rd0811 & op0007=0x57 & op1215=0x0 ; Rd2427 & Rd2831 & const1620Z & op2123=0x3
{
	local tmp:4 = Rd0811 >> Rd2427[0,5];
	local mask:4 = (1 << const1620Z) - 1;
	Rd2831 = tmp & mask;
}

@if defined(TRICORE_V2)
# FCALL disp24 (B)
:fcall off24pc is PCPMode=0 & ( op0007=0x61 ) ... & off24pc
{
	#TODO  call
	a10 = a10 - 4;
	*[ram]:4 a10 = a11;
	a11 = inst_next;
	call off24pc;
}
@endif

@if defined(TRICORE_V2)
# CALLA disp24 (B)
:fcalla off24abs is PCPMode=0 & ( op0007=0xe1 ) ... & off24abs
{
	#TODO  call
	a10 = a10 - 4;
	*[ram]:4 a10 = a11;
	a11 = inst_next;
	call off24abs;
}
@endif

@if defined(TRICORE_V2)
# FCALLI A[a] (RR)
:fcalli Ra0811 is PCPMode=0 & Ra0811 & op0007=0x2d & op1215=0x0 ; op1631=0x10
{
	#TODO  call
	a10 = a10 - 4;
	*[ram]:4 a10 = a11;
	a11 = inst_next;
	local tmp:4 = Ra0811 & 0xFFFFFFFE;
	call [tmp];
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FRET (SR)
:fret  is PCPMode=0 & op0007=0x0 & op0811=0x0 & op1215=0x7
{
	local tmp:4 = a11 & 0xFFFFFFFE;
	a11 = *[ram]:4 a10;
	a10 = a10 + 4;
	return [tmp];
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FRET (SYS)
:fret  is PCPMode=0 & op0007=0x0d & op0815=0x0 ; op1621=0x0 & op2227=0x3 & op2831=0x0
{
	local tmp:4 = a11 & 0xFFFFFFFE;
	a11 = *[ram]:4 a10;
	a10 = a10 + 4;
	return [tmp];
}
@endif


@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FTOI D[c], D[a] (RR)
:ftoi Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x101
{
	#TODO  float
	#TODO  flags
	Rd2831 = trunc(Rd0811);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FTOIZ D[c], D[a] (RR)
:ftoiz Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x131
{
	#TODO  float
	#TODO  flags
	#TODO  round
	Rd2831 = floor(trunc(Rd0811));
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FTOQ31 D[c], D[a], D[b] (RR)
:ftoq31 Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x111
{
	#TODO  float
	#TODO  flags
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FTOQ31Z D[c], D[a], D[b] (RR)
:ftoq31z Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x181
{
	#TODO  float
	#TODO  flags
	#TODO  round
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FTOU D[c], D[a] (RR)
:ftou Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x121
{
	#TODO  float
	#TODO  flags
	#TODO  unsigned
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# FTOUZ D[c], D[a] (RR)
:ftouz Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x171
{
	#TODO  float
	#TODO  flags
	#TODO  unsigned
	#TODO  round
}
@endif

# GE D[c], D[a], D[b] (RR)
:ge Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x140
{
	Rd2831 = zext(Rd0811 s>= Rd1215);
}

# GE D[c], D[a], const9 (RC)
:ge Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x14 ) & const1220S
{
	Rd2831 = zext(Rd0811 s>= const1220S);
}

# GE.A D[c], A[a], A[b] (RR)
:ge.a Rd2831,Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x1 ; Rd2831 & op1627=0x430
{
	Rd2831 = zext(Ra0811 >= Ra1215);
}

# GE.U D[c], D[a], D[b] (RR)
:ge.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x150
{
	Rd2831 = zext(Rd0811 >= Rd1215);
}

# GE.U D[c], D[a], const9 (RC)
:ge.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x15 ) & const1220Z
{
	Rd2831 = zext(Rd0811 >= const1220Z);
}

# IMASK E[c], D[b], pos, width (RRPW)
:imask Ree2831/Reo2831,Rd1215,const2327Z,const1620Z is PCPMode=0 & Rd1215 & op0007=0x37 & op0811=0x0 ; Ree2831 & Reo2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp:4 = 1;
	local tmp2:4 = Rd1215;
	tmp = (tmp << const1620Z) - 1;
	Reo2831 = tmp << const2327Z;
	Ree2831 = tmp2 << const2327Z;
}

# IMASK E[c], D[b], D[d], width (RRRW)
:imask Ree2831/Reo2831,Rd1215,Rd2427,const1620Z is PCPMode=0 & Rd1215 & op0007=0x57 & op0811=0x0 ; Rd2427 & Ree2831 & Reo2831 & const1620Z & op2123=0x1
{
	local tmp:4 = 1;
	local tmp2:4 = Rd1215;
	local tmp3:4 = Rd2427;
	tmp = (tmp << const1620Z) - 1;
	Reo2831 = tmp << tmp3[0,5];
	Ree2831 = tmp2 << tmp3[0,5];
}

# IMASK E[c], const4, pos, width (RCPW)
:imask Ree2831/Reo2831,const1215Z,const2327Z,const1620Z is PCPMode=0 & const1215Z & op0007=0xb7 & op0811=0x0 ; Ree2831 & Reo2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp:4 = 1;
	tmp = (tmp << const1620Z) - 1;
	Reo2831 = tmp << const2327Z;
	Ree2831 = const1215Z << const2327Z;
}

# IMASK E[c], const4, D[d], width (RCRW)
:imask Ree2831/Reo2831,const1215Z,Rd2427,const1620Z is PCPMode=0 & const1215Z & op0007=0xd7 & op0811=0x0 ; Rd2427 & Ree2831 & Reo2831 & const1620Z & op2123=0x1
{
	local tmp:4 = 1;
	local tmp2:4 = Rd2427;
	tmp = (tmp << const1620Z) - 1;
	Reo2831 = tmp << tmp2[0,5];
	Ree2831 = const1215Z << tmp2[0,5];
}

# INS.T D[c], D[a], pos1, D[b], pos2 (BIT)
:ins.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x67 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmp:4 = Rd0811 & ~(1 << const1620Z);
	Rd2831 = tmp | (((Rd1215 >> const2327Z) & 1) << const1620Z);
}

# INSERT D[c], D[a], D[b], E[d] (RRRR)
:insert Rd2831,Rd0811,Rd1215,Ree2427/Reo2427 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x17 ; Rd2831 & Ree2427 & Reo2427 & op1623=0x0
{
	local tmp:4 = 1;
	tmp = (tmp << Reo2427) - 1;
	tmp = tmp << Ree2427[0,5];
	Rd2831 = (Rd0811 & ~tmp) | ((Rd1215 << Ree2427[0,5]) & tmp);
}

# INSERT D[c], D[a], D[b], pos, width (RRPW)
:insert Rd2831,Rd0811,Rd1215,const2327Z,const1620Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x37 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmp:4 = 1;
	tmp = (tmp << const1620Z) - 1;
	tmp = tmp << const2327Z;
	Rd2831 = (Rd0811 & ~tmp) | ((Rd1215 << const2327Z) & tmp);
}

# INSERT D[c], D[a], D[b], D[d], width (RRRW)
:insert Rd2831,Rd0811,Rd1215,Rd2427,const1620Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x57 ; Rd2427 & Rd2831 & const1620Z & op2123=0x0
{
	local tmp:4 = 1;
	tmp = (tmp << const1620Z) - 1;
	tmp = tmp << Rd2427[0,5];
	Rd2831 = (Rd0811 & ~tmp) | ((Rd1215 << Rd2427[0,5]) & tmp);
}

# INSERT D[c], D[a], const4, E[d] (RCRR)
:insert Rd2831,Rd0811,const1215Z,Ree2427/Reo2427 is PCPMode=0 & Rd0811 & const1215Z & op0007=0x97 ; Rd2831 & Ree2427 & Reo2427 & op1623=0x0
{
	local tmp:4 = 1;
	tmp = (tmp << Reo2427) - 1;
	tmp = tmp << Ree2427[0,5];
	Rd2831 = (Rd0811 & ~tmp) | ((const1215Z << Ree2427[0,5]) & tmp);
}

# INSERT D[c], D[a], const4, pos, width (RCPW)
:insert Rd2831,Rd0811,const1215Z,const2327Z,const1620Z is PCPMode=0 & Rd0811 & const1215Z & op0007=0xb7 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmp:4 = 1;
	tmp = (tmp << const1620Z) - 1;
	tmp = tmp << const2327Z;
	Rd2831 = (Rd0811 & ~tmp) | ((const1215Z << const2327Z) & tmp);
}

# INSERT D[c], D[a], const4, D[d], width (RCRW)
:insert Rd2831,Rd0811,const1215Z,Rd2427,const1620Z is PCPMode=0 & Rd0811 & const1215Z & op0007=0xd7 ; Rd2427 & Rd2831 & const1620Z & op2123=0x0
{
	local tmp:4 = 1;
	tmp = (tmp << const1620Z) - 1;
	tmp = tmp << Rd2427[0,5];
	Rd2831 = (Rd0811 & ~tmp) | ((const1215Z << Rd2427[0,5]) & tmp);
}

# INSN.T D[c], D[a], pos1, D[b], pos2 (BIT)
:insn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x67 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp:4 = Rd0811 & ~(1 << const1620Z);
	Rd2831 = tmp | (((~Rd1215 >> const2327Z) & 1) << const1620Z);
}

# ISYNC (SYS)
:isync  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x4c0
{
	isync();
}

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ITOF D[c], D[a] (RR)
:itof Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x141
{
	#TODO  float
	#TODO  flags
	Rd2831 = int2float(Rd0811);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# IXMAX E[c], E[d], D[b] (RRR)
:ixmax Re2831,Re2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Re2427 & Re2831 & op1623=0xa0
{
	local tmp:8 = Re2427;
	local tmp2:4 = Rd1215;
	Re2831[0,16] = tmp[0,16] + 2;
	Re2831[48,16] = 0;
	local cond1 = (tmp2[0,16] s>= tmp2[16,16]) && (tmp2[0,16] s> tmp[32,16]);
	if (cond1) goto <_first>;
	local cond2 = (tmp2[16,16] s> tmp2[0,16]) && (tmp2[16,16] s> tmp[32,16]);
	if (cond2) goto <_second>;
	Re2831[32,16] = tmp[32,16];
	Re2831[16,16] = tmp[16,16];
	goto inst_next;
    <_first>
	Re2831[32,16] = tmp2[0,16];
	Re2831[16,16] = tmp[0,16];
	goto inst_next;
    <_second>
	Re2831[32,16] = tmp2[16,16];
	Re2831[16,16] = tmp[0,16] + 1;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# IXMAX.U E[c], E[d], D[b] (RRR)
:ixmax.u Re2831,Re2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Re2427 & Re2831 & op1623=0xb0
{
	local tmp:8 = Re2427;
	local tmp2:4 = Rd1215;
	Re2831[0,16] = tmp[0,16] + 2;
	Re2831[48,16] = 0;
	local cond1 = (tmp2[0,16] >= tmp2[16,16]) && (tmp2[0,16] > tmp[32,16]);
	if (cond1) goto <_first>;
	local cond2 = (tmp2[16,16] > tmp2[0,16]) && (tmp2[16,16] > tmp[32,16]);
	if (cond2) goto <_second>;
	Re2831[32,16] = tmp[32,16];
	Re2831[16,16] = tmp[16,16];
	goto inst_next;
    <_first>
	Re2831[32,16] = tmp2[0,16];
	Re2831[16,16] = tmp[0,16];
	goto inst_next;
    <_second>
	Re2831[32,16] = tmp2[16,16];
	Re2831[16,16] = tmp[0,16] + 1;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# IXMIN E[c], E[d], D[b] (RRR)
:ixmin Re2831,Re2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Re2427 & Re2831 & op1623=0x80
{
	local tmp:8 = Re2427;
	local tmp2:4 = Rd1215;
	Re2831[0,16] = tmp[0,16] + 2;
	Re2831[48,16] = 0;
	local cond1 = (tmp2[0,16] s<= tmp2[16,16]) && (tmp2[0,16] s< tmp[32,16]);
	if (cond1) goto <_first>;
	local cond2 = (tmp2[16,16] s< tmp2[0,16]) && (tmp2[16,16] s< tmp[32,16]);
	if (cond2) goto <_second>;
	Re2831[32,16] = tmp[32,16];
	Re2831[16,16] = tmp[16,16];
	goto inst_next;
    <_first>
	Re2831[32,16] = tmp2[0,16];
	Re2831[16,16] = tmp[0,16];
	goto inst_next;
    <_second>
	Re2831[32,16] = tmp2[16,16];
	Re2831[16,16] = tmp[0,16] + 1;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# IXMIN.U E[c], E[d], D[b] (RRR)
:ixmin.u Re2831,Re2427,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x6b & op0811=0x0 ; Re2427 & Re2831 & op1623=0x90
{
	local tmp:8 = Re2427;
	local tmp2:4 = Rd1215;
	Re2831[0,16] = tmp[0,16] + 2;
	Re2831[48,16] = 0;
	local cond1 = (tmp2[0,16] <= tmp2[16,16]) && (tmp2[0,16] < tmp[32,16]);
	if (cond1) goto <_first>;
	local cond2 = (tmp2[16,16] < tmp2[0,16]) && (tmp2[16,16] < tmp[32,16]);
	if (cond2) goto <_second>;
	Re2831[32,16] = tmp[32,16];
	Re2831[16,16] = tmp[16,16];
	goto inst_next;
    <_first>
	Re2831[32,16] = tmp2[0,16];
	Re2831[16,16] = tmp[0,16];
	goto inst_next;
    <_second>
	Re2831[32,16] = tmp2[16,16];
	Re2831[16,16] = tmp[0,16] + 1;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# J disp8 (SB)
:j off0815pc8s is PCPMode=0 & off0815pc8s & op0007=0x3c
{
	goto off0815pc8s;
}
@endif

# J disp24 (B)
:j off24pc is PCPMode=0 & ( op0007=0x1d ) ... & off24pc
{
	goto off24pc;
}

# JA disp24 (B)
:ja off24abs is PCPMode=0 & ( op0007=0x9d ) ... & off24abs
{
	goto off24abs;
}

@if defined(TRICORE_V2)
# JEQ D[15], D[b], disp4 (SBR)
:jeq d15,Rd1215,off0811pc4z16 is PCPMode=0 & Rd1215 & d15 & off0811pc4z16 & op0007=0xbe
{
	if (d15 == Rd1215) goto off0811pc4z16;
}
@endif

@if defined(TRICORE_V2)
# JEQ D[15], const4, disp4 (SBC)
:jeq d15,const1215S,off0811pc4z16 is PCPMode=0 & const1215S & d15 & off0811pc4z16 & op0007=0x9e
{
	if (d15 == const1215S) goto off0811pc4z16;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JEQ D[15], D[b], disp4 (SBR)
:jeq d15,Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & d15 & off0811pc4z & op0007=0x3e
{
	if (d15 == Rd1215) goto off0811pc4z;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JEQ D[15], const4, disp4 (SBC)
:jeq d15,const1215S,off0811pc4z is PCPMode=0 & const1215S & d15 & off0811pc4z & op0007=0x1e
{
	if (d15 == const1215S) goto off0811pc4z;
}
@endif

# JEQ D[a], D[b], disp15 (BRR)
:jeq Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x5f ; off1630pc15s & op3131=0x0
{
	if (Rd0811 == Rd1215) goto off1630pc15s;
}

# JEQ D[a], const4, disp15 (BRC)
:jeq Rd0811,const1215S,off1630pc15s is PCPMode=0 & Rd0811 & const1215S & op0007=0xdf ; off1630pc15s & op3131=0x0
{
	if (Rd0811 == const1215S) goto off1630pc15s;
}

# JEQ.A A[a], A[b], disp15 (BRR)
:jeq.a Ra0811,Ra1215,off1630pc15s is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x7d ; off1630pc15s & op3131=0x0
{
	if (Ra0811 == Ra1215) goto off1630pc15s;
}

# JGE D[a], D[b], disp15 (BRR)
:jge Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x7f ; off1630pc15s & op3131=0x0
{
	if (Rd0811 s>= Rd1215) goto off1630pc15s;
}

# JGE D[a], const4, disp15 (BRC)
:jge Rd0811,const1215S,off1630pc15s is PCPMode=0 & Rd0811 & const1215S & op0007=0xff ; off1630pc15s & op3131=0x0
{
	if (Rd0811 s>= const1215S) goto off1630pc15s;
}

# JGE.U D[a], D[b], disp15 (BRR)
:jge.u Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x7f ; off1630pc15s & op3131=0x1
{
	if (Rd0811 >= Rd1215) goto off1630pc15s;
}

# JGE.U D[a], const4, disp15 (BRC)
:jge.u Rd0811,const1215Z,off1630pc15s is PCPMode=0 & Rd0811 & const1215Z & op0007=0xff ; off1630pc15s & op3131=0x1
{
	if (Rd0811 >= const1215Z) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JGEZ D[b], disp4 (SBR)
:jgez Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & off0811pc4z & op0007=0xce
{
	if (Rd1215 s>= 0) goto off0811pc4z;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_RIDER_B) || defined(TRICORE_V2)
# JGTZ D[b], disp4 (SBR)
:jgtz Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & off0811pc4z & op0007=0x4e
{
	if (Rd1215 s> 0) goto off0811pc4z;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JI A[a] (SR)
:ji Ra0811 is PCPMode=0 & Ra0811 & op0007=0xdc & op1215=0x0
{
	local tmp:4 = Ra0811;
	tmp[0,1] = 0;
	goto [tmp];
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JI A[a] (RR)
:ji Ra0811 is PCPMode=0 & Ra0811 & op0007=0x2d & op1215=0x0 ; op1631=0x30
{
	local tmp:4 = Ra0811;
	tmp[0,1] = 0;
	goto [tmp];
}
@endif

# JL disp24 (B)
:jl off24pc is PCPMode=0 & ( op0007=0x5d ) ... & off24pc
{
	#TODO  is this just a call w/o context switching?
	a11 = inst_start + 4;
	call [off24pc];
}

# JLA disp24 (B)
:jla off24abs is PCPMode=0 & ( op0007=0xdd ) ... & off24abs
{
	#TODO  is this just a call w/o context switching?
	a11 = inst_start + 4;
	call [off24abs];
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JLEZ D[b], disp4 (SBR)
:jlez Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & off0811pc4z & op0007=0x8e
{
	if (Rd1215 s<= 0) goto off0811pc4z;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JLI A[a] (RR)
:jli Ra0811 is PCPMode=0 & Ra0811 & op0007=0x2d & op1215=0x0 ; op1631=0x20
{
	a11 = inst_start + 4;
	local tmp:4 = Ra0811 & 0xFFFFFFFE;
	call [tmp];
}
@endif

# JLT D[a], D[b], disp15 (BRR)
:jlt Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3f ; off1630pc15s & op3131=0x0
{
	if (Rd0811 s< Rd1215) goto off1630pc15s;
}

# JLT D[a], const4, disp15 (BRC)
:jlt Rd0811,const1215S,off1630pc15s is PCPMode=0 & Rd0811 & const1215S & op0007=0xbf ; off1630pc15s & op3131=0x0
{
	if (Rd0811 s< const1215S) goto off1630pc15s;
}

# JLT.U D[a], D[b], disp15 (BRR)
:jlt.u Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3f ; off1630pc15s & op3131=0x1
{
	if (Rd0811 < Rd1215) goto off1630pc15s;
}

# JLT.U D[a], const4, disp15 (BRC)
:jlt.u Rd0811,const1215Z,off1630pc15s is PCPMode=0 & Rd0811 & const1215Z & op0007=0xbf ; off1630pc15s & op3131=0x1
{
	if (Rd0811 < const1215Z) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_D) || defined(TRICORE_RIDER_B) || defined(TRICORE_V2)
# JLTZ D[b], disp4 (SBR)
:jltz Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & off0811pc4z & op0007=0xe
{
	if (Rd1215 s< 0) goto off0811pc4z;
}
@endif

@if defined(TRICORE_V2)
# JNE D[15], D[b], disp4 (SBR)
:jne d15,Rd1215,off0811pc4z16 is PCPMode=0 & Rd1215 & d15 & off0811pc4z16 & op0007=0xfe
{
	if (d15 != Rd1215) goto off0811pc4z16;
}
@endif

@if defined(TRICORE_V2)
# JNE D[15], const4, disp4 (SBC)
:jne d15,const1215S,off0811pc4z16 is PCPMode=0 & const1215S & d15 & off0811pc4z16 & op0007=0xde
{
	if (d15 != const1215S) goto off0811pc4z16;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JNE D[15], D[b], disp4 (SBR)
:jne d15,Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & d15 & off0811pc4z & op0007=0x7e
{
	if (d15 != Rd1215) goto off0811pc4z;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JNE D[15], const4, disp4 (SBC)
:jne d15,const1215S,off0811pc4z is PCPMode=0 & const1215S & d15 & off0811pc4z & op0007=0x5e
{
	if (d15 != const1215S) goto off0811pc4z;
}
@endif

# JNE D[a], D[b], disp15 (BRR)
:jne Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x5f ; off1630pc15s & op3131=0x1
{
	if (Rd0811 != Rd1215) goto off1630pc15s;
}

# JNE D[a], const4, disp15 (BRC)
:jne Rd0811,const1215S,off1630pc15s is PCPMode=0 & Rd0811 & const1215S & op0007=0xdf ; off1630pc15s & op3131=0x1
{
	if (Rd0811 != const1215S) goto off1630pc15s;
}

# JNE.A A[a], A[b], disp15 (BRR)
:jne.a Ra0811,Ra1215,off1630pc15s is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x7d ; off1630pc15s & op3131=0x1
{
	if (Ra0811 != Ra1215) goto off1630pc15s;
}

# JNED D[a], D[b], disp15 (BRR)
:jned Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x1f ; off1630pc15s & op3131=0x1
{
	local tmp = Rd0811;
	Rd0811 = Rd0811 - 1;
	if (tmp != Rd1215) goto off1630pc15s;
}

# JNED D[a], const4, disp15 (BRC)
:jned Rd0811,const1215S,off1630pc15s is PCPMode=0 & Rd0811 & const1215S & op0007=0x9f ; off1630pc15s & op3131=0x1
{
	local tmp = Rd0811;
	Rd0811 = Rd0811 - 1;
	if (tmp != const1215S) goto off1630pc15s;
}

# JNEI D[a], D[b], disp15 (BRR)
:jnei Rd0811,Rd1215,off1630pc15s is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x1f ; off1630pc15s & op3131=0x0
{
	local tmp = Rd0811;
	Rd0811 = Rd0811 + 1;
	if (tmp != Rd1215) goto off1630pc15s;
}

# JNEI D[a], const4, disp15 (BRC)
:jnei Rd0811,const1215S,off1630pc15s is PCPMode=0 & Rd0811 & const1215S & op0007=0x9f ; off1630pc15s & op3131=0x0
{
	local tmp = Rd0811;
	Rd0811 = Rd0811 - 1;
	if (tmp != const1215S) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JNZ D[15], disp8 (SB)
:jnz d15,off0815pc8s is PCPMode=0 & d15 & off0815pc8s & op0007=0xee
{
	if (d15 != 0) goto off0815pc8s;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JNZ D[b], disp4 (SBR)
:jnz Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & off0811pc4z & op0007=0xf6
{
	if (Rd1215 != 0) goto off0811pc4z;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_RIDER_B) || defined(TRICORE_V2)
# JNZ.A A[b], disp4 (SBR)
:jnz.a Ra1215,off0811pc4z is PCPMode=0 & Ra1215 & off0811pc4z & op0007=0x7c
{
	if (Ra1215 != 0) goto off0811pc4z;
}
@endif

# JNZ.A A[a], disp15 (BRR)
:jnz.a Ra0811,off1630pc15s is PCPMode=0 & Ra0811 & op0007=0xbd & op1215=0x0 ; off1630pc15s & op3131=0x1
{
	if (Ra0811 != 0) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JNZ.T D[15], n, disp4 (SBRN)
:jnz.t d15,const1215Z,off0811pc4z is PCPMode=0 & const1215Z & d15 & off0811pc4z & op0007=0xae
{
	local tmp = d15 & (1 << const1215Z);
	if (tmp != 0) goto off0811pc4z;
}
@endif

# JNZ.T D[a], n, disp15 (BRN)
:jnz.t Rd0811,Nbit,off1630pc15s is PCPMode=0 & Nbit & Rd0811 & op0006=0x6f ; off1630pc15s & op3131=0x1
{
	local tmp = Rd0811 & (1 << Nbit);
	if (tmp != 0) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JZ D[15], disp8 (SB)
:jz d15,off0815pc8s is PCPMode=0 & d15 & off0815pc8s & op0007=0x6e
{
	if (d15 == 0) goto off0815pc8s;
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_RIDER_B) || defined(TRICORE_V2)
# JZ D[b], disp4 (SBR)
:jz Rd1215,off0811pc4z is PCPMode=0 & Rd1215 & off0811pc4z & op0007=0x76
{
	if (Rd1215 == 0) goto off0811pc4z;
}
@endif

# JZ.A A[b], disp4 (SBR)
:jz.a Ra1215,off0811pc4z is PCPMode=0 & Ra1215 & off0811pc4z & op0007=0xbc
{
	if (Ra1215 == 0) goto off0811pc4z;
}

# JZ.A A[a], disp15 (BRR)
:jz.a Ra0811,off1630pc15s is PCPMode=0 & Ra0811 & op0007=0xbd & op1215=0x0 ; off1630pc15s & op3131=0x0
{
	if (Ra0811 == 0) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# JZ.T D[15], n, disp4 (SBRN)
:jz.t d15,const1215Z,off0811pc4z is PCPMode=0 & const1215Z & d15 & off0811pc4z & op0007=0x2e
{
	local tmp = d15 & (1 << const1215Z);
	if (tmp == 0) goto off0811pc4z;
}
@endif

# JZ.T D[a], n, disp15 (BRN)
:jz.t Rd0811,Nbit,off1630pc15s is PCPMode=0 & Nbit & Rd0811 & op0006=0x6f ; off1630pc15s & op3131=0x0
{
	local tmp = Rd0811 & (1 << Nbit);
	if (tmp == 0) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.A A[15], A[10], const8 (SC)
:ld.a a15,SC is PCPMode=0 & a15 & op0007=0xd8 & SC
{
	build SC;
	a15 = *[ram]:4 SC;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.A A[c], A[15], off4 (SLRO)
:ld.a Ra0811,SLRO is PCPMode=0 & Ra0811 & op0007=0xc8 & SLRO
{
	build SLRO;
	Ra0811 = *[ram]:4 SLRO;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.A A[15], A[b], off4 (SRO)
:ld.a a15,SRO is PCPMode=0 & a15 & op0007=0xcc & SRO
{
	build SRO;
	a15 = *[ram]:4 SRO;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.A A[c], A[b] (SLR)(Post-increment Addressing Mode)
# LD.A A[c], A[b] (SLR)
:ld.a Ra0811,SLR is PCPMode=0 & Ra0811 & op0607=0x3 & SLR
{
	build SLR;
	Ra0811 = *[ram]:4 SLR;
}
@endif

# LD.A A[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:ld.a Ra0811,BOL is PCPMode=0 & ( Ra0811 & op0007=0x99 ) ... & BOL
{
	build BOL;
	Ra0811 = *[ram]:4 BOL;
}

# LD.A A[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.A A[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.A A[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.A A[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.A A[a], P[b] (BO)(Index Addressing Mode)
:ld.a Ra0811,BO is PCPMode=0 & ( Ra0811 & op0607=0x0 ; op2225=0x6 ) & BO
{
	build BO;
	Ra0811 = *[ram]:4 BO;
}

# LD.A A[a], P[b], off10 (BO)(Circular Addressing Mode)
#:ld.a Ra0811,BO is PCPMode=0 & ( Ra0811 & op0007=0x29 ; op2227=0x16 ) & BO
:ld.a Ra0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Ra0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x16
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	Ra0811 = *[ram]:4 EA;
}

# LD.A A[a], off18 (ABS)(Absolute Addressing Mode)
:ld.a Ra0811,off18 is PCPMode=0 & ( Ra0811 & op0007=0x85 ; op2627=0x2 ) & off18
{
	Ra0811 = *[ram]:4 off18;
}

# LD.B D[a], off18 (ABS)(Absolute Addressing Mode)
:ld.b Rd0811,off18 is PCPMode=0 & ( Rd0811 & op0007=0x5 ; op2627=0x0 ) & off18
{
	Rd0811 = sext(*[ram]:1 off18);
}

# LD.B D[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.B D[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.B D[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.B D[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.B D[a], P[b] (BO)(Index Addressing Mode)
:ld.b Rd0811,BO is PCPMode=0 & ( Rd0811 & op0607=0x0 ; op2225=0x0 ) & BO
{
	build BO;
	Rd0811 = sext(*[ram]:1 BO);
}

# LD.B D[a], P[b], off10 (BO)(Circular Addressing Mode)
#:ld.b Rd0811,BO is PCPMode=0 & ( Rd0811 & op0007=0x29 ; op2227=0x10 ) & BO
:ld.b Rd0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x10
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	Rd0811 = sext(*[ram]:1 EA);
}

# LD.B D[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:ld.b Rd0811,BOL is PCPMode=0 & ( Rd0811 & op0007=0x79 ) ... & BOL
{
	build BOL;
	Rd0811 = sext(*[ram]:1 BOL);
}

# LD.BU D[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:ld.bu Rd0811,BOL is PCPMode=0 & ( Rd0811 & op0007=0x39 ) ... & BOL
{
	build BOL;
	Rd0811 = zext(*[ram]:1 BOL);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.BU D[c], A[b] (SLR)
# LD.BU D[c], A[b] (SLR)(Post-increment Addressing Mode)
:ld.bu Rd0811,SLR is PCPMode=0 & Rd0811 & op0607=0x0 & SLR
{
	build SLR;
	Rd0811 = zext(*[ram]:1 SLR);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.BU D[15], A[b], off4 (SRO)
:ld.bu d15,SRO is PCPMode=0 & d15 & op0007=0xc & SRO
{
	build SRO;
	d15 = zext(*[ram]:1 SRO);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.BU D[c], A[15], off4 (SLRO)
:ld.bu Rd0811,SLRO is PCPMode=0 & Rd0811 & op0007=0x8 & SLRO
{
	build SLRO;
	Rd0811 = zext(*[ram]:1 SLRO);
}
@endif

# LD.BU D[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.BU D[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.BU D[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.BU D[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.BU D[a], P[b] (BO)(Index Addressing Mode)
:ld.bu Rd0811,BO is PCPMode=0 & ( Rd0811 & op0607=0x0 ; op2225=0x1 ) & BO
{
	build BO;
	Rd0811 = zext(*[ram]:1 BO);
}

# LD.BU D[a], off18 (ABS)(Absolute Addressing Mode)
:ld.bu Rd0811,off18 is PCPMode=0 & ( Rd0811 & op0007=0x5 ; op2627=0x1 ) & off18
{
	Rd0811 = zext(*[ram]:1 off18);
}

# LD.BU D[a], P[b], off10 (BO)(Circular Addressing Mode)
#:ld.bu Rd0811,BO is PCPMode=0 & ( Rd0811 & op0007=0x29 ; op2227=0x11 ) & BO
:ld.bu Rd0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x11
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	Rd0811 = zext(*[ram]:1 EA);
}

# LD.D E[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.D E[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.D E[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.D E[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.D E[a], P[b] (BO)(Index Addressing Mode)
:ld.d Re0811,BO is PCPMode=0 & ( Re0811 & op0607=0x0 ; op2225=0x5 ) & BO
{
	build BO;
	Re0811 = *[ram]:8 BO;
}

# LD.D E[a], off18 (ABS)(Absolute Addressing Mode)
:ld.d Re0811,off18 is PCPMode=0 & ( Re0811 & op0007=0x85 ; op2627=0x1 ) & off18
{
	Re0811 = *[ram]:8 off18;
}

# LD.D E[a], P[b], off10 (BO)(Circular Addressing Mode)
#:ld.d Re0811,BO is PCPMode=0 & ( Re0811 & op0007=0x29 ; op2227=0x15 ) & BO
:ld.d Re0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Re0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x15
{
	local EA0:4;
	local EA2:4;
	local EA4:4;
	local EA6:4;
	CircularAddressingMode4(Rpe1215, Rpo1215, EA0, EA2, EA4, EA6, off10, 2);
	Re0811[48,16] = *[ram]:2 EA6;
	Re0811[32,16] = *[ram]:2 EA4;
	Re0811[16,16] = *[ram]:2 EA2;
	Re0811[0,16] = *[ram]:2 EA0;
}

# LD.DA P[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.DA P[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.DA P[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.DA P[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.DA P[a], P[b] (BO)(Index Addressing Mode)
:ld.da Rp0811,BO is PCPMode=0 & ( Rp0811 & op0607=0x0 ; op2225=0x7 ) & BO
{
	build BO;
	Rp0811 = *[ram]:8 BO;
}

# LD.DA P[a], P[b], off10 (BO)(Circular Addressing Mode)
#:ld.da Rpe0811/Rpo0811,BO is PCPMode=0 & ( Rpe0811 & Rpo0811 & op0007=0x29 ; op2227=0x17 ) & BO
:ld.da Rpe0811/Rpo0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rpe0811 & Rpo0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x17
{
	local EA0:4;
	local EA4:4;
	CircularAddressingMode2(Rpe1215, Rpo1215, EA0, EA4, off10, 4);
	Rpo0811 = *[ram]:4 EA4;
	Rpe0811 = *[ram]:4 EA0;
}

# LD.DA P[a], off18 (ABS)(Absolute Addressing Mode)
:ld.da Rp0811,off18 is PCPMode=0 & ( Rp0811 & op0007=0x85 ; op2627=0x3 ) & off18
{
	Rp0811 = *[ram]:8 off18;
}

@if defined(TRICORE_V2)
:ld.dd Re0811/ReN0811,BO is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x9 ; op2227=0x9 ) & BO
{
	build BO;
	Re0811 = *[ram]:8 BO;
	ReN0811 = *[ram]:8 BO+8;
}
@endif

@if defined(TRICORE_V2)
:ld.dd Re0811/ReN0811,BO is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x29 ; op1621=0x0 & op2227=0x09 & op2831=0x0 ) & BO
{
	build BO;
	Re0811 = *[ram]:8 BO;
	ReN0811 = *[ram]:8 BO+8;
}
@endif

@if defined(TRICORE_V2)
:ld.dd Re0811/ReN0811,BO is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x9 ; op2227=0x19 ) & BO
{
	build BO;
	Re0811 = *[ram]:8 BO;
	ReN0811 = *[ram]:8 BO+8;
}
@endif

@if defined(TRICORE_V2)
#:ld.dd Re0811/ReN0811,BO is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x29 ; op2227=0x19 ) & BO
:ld.dd Re0811/ReN0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Re0811 & ReN0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x19
{
	local EA0:4;
	local EA8:4;
	CircularAddressingMode2(Rpe1215, Rpo1215, EA0, EA8, off10, 8);
	Re0811 = *[ram]:8 EA0;
	ReN0811 = *[ram]:8 EA8;
}
@endif

@if defined(TRICORE_V2)
:ld.dd Re0811/ReN0811,BO is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x9 ; op2227=0x29 ) & BO
{
	build BO;
	Re0811 = *[ram]:8 BO;
	ReN0811 = *[ram]:8 BO+8;
}
@endif

@if defined(TRICORE_V2)
:ld.dd Re0811/ReN0811,BO is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x29 ; op1621=0x0 & op2227=0x29 & op2831=0x0 ) & BO
{
	build BO;
	Re0811 = *[ram]:8 BO;
	ReN0811 = *[ram]:8 BO+8;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.H D[c], A[b] (SLR)(Post-increment Addressing Mode)
# LD.H D[c], A[b] (SLR)
:ld.h Rd0811,SLR is PCPMode=0 & Rd0811 & op0607=0x2 & SLR
{
	build SLR;
	Rd0811 = sext(*[ram]:2 SLR);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.H D[15], A[b], off4 (SRO)
:ld.h d15,SRO is PCPMode=0 & d15 & op0007=0x8c & SRO
{
	build SRO;
	d15 = sext(*[ram]:2 SRO);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.H D[c], A[15], off4 (SLRO)
:ld.h Rd0811,SLRO is PCPMode=0 & Rd0811 & op0007=0x88 & SLRO
{
	build SLRO;
	Rd0811 = sext(*[ram]:2 SLRO);
}
@endif

# LD.H D[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.H D[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.H D[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.H D[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.H D[a], P[b] (BO)(Index Addressing Mode)
:ld.h Rd0811,BO is PCPMode=0 & ( Rd0811 & op0607=0x0 ; op2225=0x2 ) & BO
{
	build BO;
	Rd0811 = sext(*[ram]:2 BO);
}

# LD.H D[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:ld.h Rd0811,BOL is PCPMode=0 & ( Rd0811 & op0007=0xc9 ) ... & BOL
{
	build BOL;
	Rd0811 = sext(*[ram]:2 BOL);
}

#:ld.h Rd0811,BO is PCPMode=0 & ( Rd0811 & op0007=0x29 ; op2227=0x12 ) & BO
:ld.h Rd0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x12
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	Rd0811 = sext(*[ram]:2 EA);
}

# LD.H D[a], off18 (ABS)(Absolute Addressing Mode)
:ld.h Rd0811,off18 is PCPMode=0 & ( Rd0811 & op0007=0x5 ; op2627=0x2 ) & off18
{
	Rd0811 = sext(*[ram]:2 off18);
}

# LD.HU D[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.HU D[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.HU D[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.HU D[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.HU D[a], P[b] (BO)(Index Addressing Mode)
:ld.hu Rd0811,BO is PCPMode=0 & ( Rd0811 & op0607=0x0 ; op2225=0x3 ) & BO
{
	build BO;
	Rd0811 = zext(*[ram]:2 BO);
}

#:ld.hu Rd0811,BO is PCPMode=0 & ( Rd0811 & op0007=0x29 ; op2227=0x13 ) & BO
:ld.hu Rd0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x13
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	Rd0811 = zext(*[ram]:2 EA);
}

# LD.HU D[a], off18 (ABS)(Absolute Addressing Mode)
:ld.hu Rd0811,off18 is PCPMode=0 & ( Rd0811 & op0007=0x5 ; op2627=0x3 ) & off18
{
	Rd0811 = zext(*[ram]:2 off18);
}

# LD.HU D[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:ld.hu Rd0811,BOL is PCPMode=0 & ( Rd0811 & op0007=0xb9 ) ... & BOL
{
	build BOL;
	Rd0811 = zext(*[ram]:2 BOL);
}

# LD.Q D[a], off18 (ABS)(Absolute Addressing Mode)
:ld.q Rd0811,off18 is PCPMode=0 & ( Rd0811 & op0007=0x45 ; op2627=0x0 ) & off18
{
	Rd0811 = zext(*[ram]:2 off18) << 16;
}

# LD.Q D[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.Q D[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.Q D[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.Q D[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.Q D[a], P[b] (BO)(Index Addressing Mode)
:ld.q Rd0811,BO is PCPMode=0 & ( Rd0811 & op0607=0x0 ; op2225=0x8 ) & BO
{
	build BO;
	Rd0811 = zext(*[ram]:2 BO) << 16;
}

# LD.Q D[a], P[b], off10 (BO)(Circular Addressing Mode)
#:ld.q Rd0811,BO is PCPMode=0 & ( Rd0811 & op0007=0x29 ; op2227=0x18 ) & BO
:ld.q Rd0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x18
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	Rd0811 = zext(*[ram]:2 EA) << 16;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.W D[15], A[10], const8 (SC)
:ld.w d15,SC is PCPMode=0 & d15 & op0007=0x58 & SC
{
	build SC;
	d15 = *[ram]:4 SC;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.W D[c], A[b] (SLR)
# LD.W D[c], A[b] (SLR)(Post-increment Addressing Mode)
:ld.w Rd0811,SLR is PCPMode=0 & Rd0811 & op0607=0x1 & SLR
{
	build SLR;
	Rd0811 = *[ram]:4 SLR;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.W D[15], A[b], off4 (SRO)
:ld.w d15,SRO is PCPMode=0 & d15 & op0007=0x4c & SRO
{
	build SRO;
	d15 = *[ram]:4 SRO;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LD.W D[c], A[15], off4 (SLRO)
:ld.w Rd0811,SLRO is PCPMode=0 & Rd0811 & op0007=0x48 & SLRO
{
	build SLRO;
	Rd0811 = *[ram]:4 SLRO;
}
@endif

# LD.W D[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:ld.w Rd0811,BOL is PCPMode=0 & ( Rd0811 & op0007=0x19 ) ... & BOL
{
	build BOL;
	Rd0811 = *[ram]:4 BOL;
}

# LD.W D[a], off18 (ABS)(Absolute Addressing Mode)
:ld.w Rd0811,off18 is PCPMode=0 & ( Rd0811 & op0007=0x85 ; op2627=0x0 ) & off18
{
	Rd0811 = *[ram]:4 off18;
}

# LD.W D[a], A[b], off10 (BO)(Post-increment Addressing Mode)
# LD.W D[a], P[b] (BO)(Bit-reverse Addressing Mode)
# LD.W D[a], A[b], off10 (BO)(Pre-increment Addressing Mode)
# LD.W D[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
# LD.W D[a], P[b] (BO)(Index Addressing Mode)
:ld.w Rd0811,BO is PCPMode=0 & ( Rd0811 & op0607=0x0 ; op2225=0x4 ) & BO
{
	build BO;
	Rd0811 = *[ram]:4 BO;
}

#:ld.w Rd0811,BO is PCPMode=0 & ( Rd0811 & op0007=0x29 ; op2227=0x14 ) & BO
:ld.w Rd0811,[Rpe1215/Rpo1215^"+c"^]off10 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x29 ; off10 & op2227=0x14
{
	local EA0:4;
	local EA2:4;
	CircularAddressingMode2(Rpe1215, Rpo1215, EA0, EA2, off10, 2);
	Rd0811[16,16] = *[ram]:2 EA2;
	Rd0811[0,16] = *[ram]:2 EA0;
}

# LDLCX off18 (ABS)(Absolute Addressing Mode)
:ldlcx off18 is PCPMode=0 & ( op0007=0x15 & op0811=0x0 ; op2627=0x2 ) & off18
{
	#TODO  context
	load_lower_context(off18);
}

# LDLCX A[b], off10 (BO) (Base + Short Index Addressing Mode)
:ldlcx BO is PCPMode=0 & ( op0007=0x49 & op0811=0x0 ; off10 & op2227=0x24 ) & BO
{
	#TODO  context
	build BO;
	load_lower_context(BO);
}

# LDMST A[b], off10, E[a] (BO)(Post-increment Addressing Mode)
# LDMST P[b], E[a] (BO)(Bit-reverse Addressing Mode)
# LDMST A[b], off10, E[a] (BO)(Pre-increment Addressing Mode)
# LDMST A[b], off10, E[a] (BO)(Base + Short Offset Addressing Mode)
# LDMST P[b], E[a] (BO)(Index Addressing Mode)
:ldmst BO,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0607=0x1 ; op2225=0x1 ) & BO
{
	build BO;
	local tmp:4 = *[ram]:4 BO;
	*[ram]:4 BO = (tmp & ~Reo0811) | (Ree0811 & Reo0811);
}

# LDMST off18, E[a] (ABS)(Absolute Addressing Mode)
:ldmst off18,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0007=0xe5 ; op2627=0x1 ) & off18
{
	local tmp:4 = *[ram]:4 off18;
	*[ram]:4 off18 = (tmp & ~Reo0811) | (Ree0811 & Reo0811);
}

# LDMST P[b], off10, E[a] (BO)(Circular Addressing Mode)
#:ldmst BO,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0007=0x69 ; op2227=0x11 ) & BO
:ldmst [Rpe1215/Rpo1215^"+c"^]off10,Ree0811/Reo0811 is PCPMode=0 & Ree0811 & Reo0811 & Rpe1215 & Rpo1215 & op0007=0x69 ; off10 & op2227=0x11
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	*[ram]:4 EA = (*[ram]:4 EA & ~Reo0811) | (Ree0811 & Reo0811);
}

# LDUCX A[b], off10 (BO)(Base + Short Index Addressing Mode)
:lducx BO is PCPMode=0 & ( op0007=0x49 & op0811=0x0 ; off10 & op2227=0x25 ) & BO
{
	#TODO  context
	build BO;
	load_upper_context(BO);
}

# LDUCX off18 (ABS)(Absolute Addressing Mode)
:lducx off18 is PCPMode=0 & ( op0007=0x15 & op0811=0x0 ; op2627=0x3 ) & off18
{
	#TODO  context
	load_upper_context(off18);
}

# LEA A[a], off18 (ABS)(Absolute Addressing Mode)
:lea Ra0811,off18 is PCPMode=0 & ( Ra0811 & op0007=0xc5 ; op2627=0x0 ) & off18
{
	Ra0811 = off18;
}

# LEA A[a], A[b], off16 (BOL)(Base + Long Offset Addressing Mode)
:lea Ra0811,BOL is PCPMode=0 & ( Ra0811 & op0007=0xd9 ) ... & BOL
{
	build BOL;
	Ra0811 = BOL;
}

# LEA A[a], A[b], off10 (BO)(Base + Short Offset Addressing Mode)
:lea Ra0811,BO is PCPMode=0 & ( Ra0811 & op0007=0x49 ; op2227=0x28 ) & BO
{
	build BO;
	Ra0811 = BO;
}

# LOOP A[b], disp4 (SBR)
:loop Ra1215,off0811pc4o is PCPMode=0 & Ra1215 & off0811pc4o & op0007=0xfc
{
	local tmp:4 = Ra1215;
	Ra1215 = Ra1215 - 1;
	if (tmp != 0) goto off0811pc4o;
}

# LOOP A[b], disp15 (BRR)
:loop Ra1215,off1630pc15s is PCPMode=0 & Ra1215 & op0007=0xfd & op0811=0x0 ; off1630pc15s & op3131=0x0
{
	local tmp:4 = Ra1215;
	Ra1215 = Ra1215 - 1;
	if (tmp != 0) goto off1630pc15s;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# LOOPU disp15 (BRR)
:loopu off1630pc15s is PCPMode=0 & op0007=0xfd & op0815=0x0 ; off1630pc15s & op3131=0x1
{
	goto off1630pc15s;
}
@endif

# LT D[15], D[a], D[b] (SRR)
:lt d15,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x7a
{
	d15 = zext(Rd0811 s< Rd1215);
}

# LT D[15], D[a], const4 (SRC)
:lt d15,Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & d15 & op0007=0xfa
{
	d15 = zext(Rd0811 s< const1215S);
}

# LT D[c], D[a], D[b] (RR)
:lt Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x120
{
	Rd2831 = zext(Rd0811 s< Rd1215);
}

# LT D[c], D[a], const9 (RC)
:lt Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x12 ) & const1220S
{
	Rd2831 = zext(Rd0811 s< const1220S);
}

# LT.A D[c], A[a], A[b] (RR)
:lt.a Rd2831,Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x1 ; Rd2831 & op1627=0x420
{
	Rd2831 = zext(Ra0811 s< Ra1215);
}

# LT.B D[c], D[a], D[b] (RR)
:lt.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x520
{
	local result3:4 = 0xff * zext(Rd0811[24,8] s< Rd1215[24,8]);
	local result2:4 = 0xff * zext(Rd0811[16,8] s< Rd1215[16,8]);
	local result1:4 = 0xff * zext(Rd0811[8,8] s< Rd1215[8,8]);
	local result0:4 = 0xff * zext(Rd0811[0,8] s< Rd1215[0,8]);
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# LT.BU D[c], D[a], D[b] (RR)
:lt.bu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x530
{
	local result3:4 = 0xff * zext(Rd0811[24,8] < Rd1215[24,8]);
	local result2:4 = 0xff * zext(Rd0811[16,8] < Rd1215[16,8]);
	local result1:4 = 0xff * zext(Rd0811[8,8] < Rd1215[8,8]);
	local result0:4 = 0xff * zext(Rd0811[0,8] < Rd1215[0,8]);
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# LT.H D[c], D[a], D[b] (RR)
:lt.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x720
{
	result1:4 = 0xffff * zext(Rd0811[16,16] s< Rd1215[16,16]);
	result0:4 = 0xffff * zext(Rd0811[0,16] s< Rd1215[0,16]);
	Rd2831 = (result1 << 16) | (result0);
}

# LT.HU D[c], D[a], D[b] (RR)
:lt.hu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x730
{
	local result1:4 = 0xffff * zext(Rd0811[16,16] < Rd1215[16,16]);
	local result0:4 = 0xffff * zext(Rd0811[0,16] < Rd1215[0,16]);
	Rd2831 = (result1 << 16) | (result0);
}

# LT.U D[c], D[a], D[b] (RR)
:lt.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x130
{
	Rd2831 = zext(Rd0811 < Rd1215);
}

# LT.U D[c], D[a], const9 (RC)
:lt.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x13 ) & const1220Z
{
	Rd2831 = zext(Rd0811 < const1220Z);
}

# LT.W D[c], D[a], D[b] (RR)
:lt.w Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x920
{
	Rd2831 = 0xFFFFFFFF * zext(Rd0811 s< Rd1215);
}

# LT.WU D[c], D[a], D[b] (RR)
:lt.wu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x930
{
	Rd2831 = 0xFFFFFFFF * zext(Rd0811 < Rd1215);
}

# MADD D[c], D[d], D[a], D[b] (RRR2)
:madd Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Rd2427 & Rd2831 & op1623=0xa
{
	Rd2831 = Rd2427 + (Rd0811 * Rd1215);
	overflowflags(Rd2831);
}

# MADD D[c], D[d], D[a], const9 (RCR)
:madd Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Rd2427 & Rd2831 & op2123=0x1 ) & const1220S
{
	Rd2831 = Rd2427 + (Rd0811 * const1220S);
	overflowflags(Rd2831);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD E[c], E[d], D[a], const9 (RCR)
:madd Re2831,Re2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Re2427 & Re2831 & op2123=0x3 ) & const1220S
{
	Re2831 = Re2427 + sext(Rd0811 * const1220S);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD E[c], E[d], D[a], D[b] (RRR2)
:madd Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Re2427 & Re2831 & op1623=0x6a
{
	Re2831 = Re2427 + sext(Rd0811 * Rd1215);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.F D[c], D[d], D[a], D[b] (RRR)
:madd.f Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x6b ; Rd2427 & Rd2831 & op1623=0x61
{
	#TODO  float
	#TODO  flags
	Rd2831 = Rd2427 f+ (Rd0811 f* Rd1215);
}
@endif

macro packed_multiply_ul(mres1, mres0, rega, regb, n) {
	local sc1 = (rega[16,16] == 0x8000) && (regb[16,16] == 0x8000) && (n == 1);
	local sc0 = (rega[0,16] == 0x8000) && (regb[0,16] == 0x8000) && (n == 1);
	ternary(mres1, sc1, 0x7FFFFFFF, sext((rega[16,16] * regb[16,16]) << n));
	ternary(mres0, sc0, 0x7FFFFFFF, sext((rega[0,16] * regb[0,16]) << n));
}

macro packed_multiply_lu(mres1, mres0, rega, regb, n) {
	local sc1 = (rega[16,16] == 0x8000) && (regb[0,16] == 0x8000) && (n == 1);
	local sc0 = (rega[0,16] == 0x8000) && (regb[16,16] == 0x8000) && (n == 1);
	ternary(mres1, sc1, 0x7FFFFFFF, sext((rega[16,16] * regb[0,16]) << n));
	ternary(mres0, sc0, 0x7FFFFFFF, sext((rega[0,16] * regb[16,16]) << n));
}

macro packed_multiply_ll(mres1, mres0, rega, regb, n) {
	local sc1 = (rega[16,16] == 0x8000) && (regb[0,16] == 0x8000) && (n == 1);
	local sc0 = (rega[0,16] == 0x8000) && (regb[0,16] == 0x8000) && (n == 1);
	ternary(mres1, sc1, 0x7FFFFFFF, sext((rega[16,16] * regb[0,16]) << n));
	ternary(mres0, sc0, 0x7FFFFFFF, sext((rega[0,16] * regb[0,16]) << n));
}

macro packed_multiply_uu(mres1, mres0, rega, regb, n) {
	local sc1 = (rega[0,16] == 0x8000) && (regb[16,16] == 0x8000) && (n == 1);
	local sc0 = (rega[16,16] == 0x8000) && (regb[16,16] == 0x8000) && (n == 1);
	ternary(mres1, sc1, 0x7FFFFFFF, sext((rega[0,16] * regb[16,16]) << n));
	ternary(mres0, sc0, 0x7FFFFFFF, sext((rega[16,16] * regb[16,16]) << n));
}


macro multiply_l_l(mres0, rega, regb, n) {
	local sc0 = (rega[0,16] == 0x8000) && (regb[0,16] == 0x8000) && (n == 1);
	ternary(mres0, sc0, 0x7FFFFFFF, sext((rega[0,16] * regb[0,16]) << n));
}

macro multiply_u_u(mres0, rega, regb, n) {
	local sc0 = (rega[16,16] == 0x8000) && (regb[16,16] == 0x8000) && (n == 1);
	ternary(mres0, sc0, 0x7FFFFFFF, sext((rega[16,16] * regb[16,16]) << n));
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:madd.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x18
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:madd.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x19
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:madd.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:madd.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:madd.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x4
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	Rd2831 = Rd2427 + mres;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q D[c], D[d], D[a], D[b] U, n (RRR1)
:madd.q Rd2831,Rd2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x0
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[16,16]));
	tmp = (tmp << const1617Z) s>> 16;
	Rd2831 = Rd2427 + tmp[0,32];
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q D[c], D[d], D[a], D[b] L, n (RRR1)
:madd.q Rd2831,Rd2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x1
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[0,16]));
	tmp = (tmp << const1617Z) s>> 16;
	Rd2831 = Rd2427 + tmp[0,32];
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q D[c], D[d], D[a], D[b], n (RRR1)
:madd.q Rd2831,Rd2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2
{
	local tmp:8 = sext(Rd0811 * Rd1215);
	tmp = (tmp << const1617Z) s>> 32;
	Rd2831 = Rd2427 + tmp[0,32];
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:madd.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x5
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	Rd2831 = Rd2427 + mres;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q E[c], E[d], D[a], D[b] U, n (RRR1)
:madd.q Re2831,Re2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x18
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[16,16]));
	Re2831 = Re2427 + (tmp << const1617Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q E[c], E[d], D[a], D[b] L, n (RRR1)
:madd.q Re2831,Re2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x19
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[0,16]));
	Re2831 = Re2427 + (tmp << const1617Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q E[c], E[d], D[a], D[b], n (RRR1)
:madd.q Re2831,Re2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x1b
{
	local tmp:8 = sext(Rd0811 * Rd1215);
	Re2831 = Re2427 + (tmp << const1617Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q E[c], E[d], D[a] U, D[b] U, n (RRR1)
:madd.q Re2831,Re2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x1c
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext(mres << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.Q E[c], E[d], D[a] L, D[b] L, n (RRR1)
:madd.q Re2831,Re2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x1d
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + (sext(mres) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.U E[c], E[d], D[a], const9 (RCR)
:madd.u Re2831,Re2427,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Re2427 & Re2831 & op2123=0x2 ) & const1220Z
{
	Re2831 = Re2427 + zext(Rd0811 * const1220Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADD.U E[c], E[d], D[a], D[b] (RRR2)
:madd.u Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Re2427 & Re2831 & op1623=0x68
{
	Re2831 = Re2427 + zext(Rd0811 * Rd1215);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDM.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:maddm.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x1c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 + mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDM.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:maddm.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x1d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 + mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDM.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:maddm.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 + mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDM.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:maddm.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x1f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 + mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDMS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:maddms.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x3c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 + mres0) << 16);
	ssov(Re2831, result, 64);
	overflowflagsd(result);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDMS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:maddms.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x3d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 + mres0) << 16);
	ssov(Re2831, result, 64);
	overflowflagsd(result);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDMS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:maddms.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x3e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 + mres0) << 16);
	ssov(Re2831, result, 64);
	overflowflagsd(result);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDMS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:maddms.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Re2427 & Re2831 & const1617Z & op1823=0x3f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 + mres0) << 16);
	ssov(Re2831, result, 64);
	overflowflagsd(result);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.H D[c], E[d], D[a], D[b] UL, n (RRR1)
:maddr.h Rd2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2831 & Ree2427 & Reo2427 & const1617Z & op1823=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 + mres1 + 0x8000;
	local res0:4 = Ree2427 + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:maddr.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0xc
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:maddr.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0xd
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:maddr.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0xe
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:maddr.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0xf
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:maddr.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x6
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 + mres + 0x8000;
	Rd2831 = zext(res[16,16]) << 16;
	overflowflags(res);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDR.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:maddr.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x7
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 + mres + 0x8000;
	Rd2831 = zext(res[16,16]) << 16;
	overflowflags(res);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.H D[c], E[d], D[a], D[b] UL, n (RRR1)
:maddrs.h Rd2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2831 & Ree2427 & Reo2427 & const1617Z & op1823=0x3e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 + mres1 + 0x8000;
	local res0:4 = Ree2427 + mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:maddrs.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = mres1 + 0x8000;
	local res0:4 = mres0 + 0x8000;
	res1[16,16] = res1[16,16] + Rd2427[16,16];
	res0[16,16] = res0[16,16] + Rd2427[0,16];
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:maddrs.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = mres1 + 0x8000;
	local res0:4 = mres0 + 0x8000;
	res1[16,16] = res1[16,16] + Rd2427[16,16];
	res0[16,16] = res0[16,16] + Rd2427[0,16];
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:maddrs.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = mres1 + 0x8000;
	local res0:4 = mres0 + 0x8000;
	res1[16,16] = res1[16,16] + Rd2427[16,16];
	res0[16,16] = res0[16,16] + Rd2427[0,16];
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:maddrs.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = mres1 + 0x8000;
	local res0:4 = mres0 + 0x8000;
	res1[16,16] = res1[16,16] + Rd2427[16,16];
	res0[16,16] = res0[16,16] + Rd2427[0,16];
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:maddrs.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x26
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 + mres + 0x8000;
	overflowflags(res);
	ssov(res, res, 32);
	Rd2831 = zext(res[16,16]) << 16;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDRS.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:maddrs.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x27
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 + mres + 0x8000;
	overflowflags(res);
	ssov(res, res, 32);
	Rd2831 = zext(res[16,16]) << 16;
}
@endif

# MADDS D[c], D[d], D[a], D[b] (RRR2)
:madds Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Rd2427 & Rd2831 & op1623=0x8a
{
	local result:4 = Rd2427 + (Rd0811 * Rd1215);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# MADDS D[c], D[d], D[a], const9 (RCR)
:madds Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Rd2427 & Rd2831 & op2123=0x5 ) & const1220S
{
	local result:4 = Rd2427 + (Rd0811 * const1220S);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS E[c], E[d], D[a], const9 (RCR)
:madds Re2831,Re2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Re2427 & Re2831 & op2123=0x7 ) & const1220S
{
	local result:8 = Re2427 + sext(Rd0811 * const1220S);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS E[c], E[d], D[a], D[b] (RRR2)
:madds Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Re2427 & Re2831 & op1623=0xea
{
	local result:8 = Re2427 + sext(Rd0811 * Rd1215);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:madds.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x38
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:madds.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x39
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:madds.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:madds.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x83 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 + mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:madds.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x24
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local result:4 = Rd2427 + mres;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q D[c], D[d], D[a], D[b] U, n (RRR1)
:madds.q Rd2831,Rd2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x20
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[16,16]));
	tmp = (tmp << const1617Z) s>> 16;
	local result:4 = Rd2427 + tmp[0,32];
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q D[c], D[d], D[a], D[b] L, n (RRR1)
:madds.q Rd2831,Rd2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x21
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[0,16]));
	tmp = (tmp << const1617Z) s>> 16;
	local result:4 = Rd2427 + tmp[0,32];
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q D[c], D[d], D[a], D[b], n (RRR1)
:madds.q Rd2831,Rd2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x22
{
	local tmp:8 = sext(Rd0811 * Rd1215);
	tmp = (tmp << const1617Z) s>> 32;
	local result:4 = Rd2427 + tmp[0,32];
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:madds.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Rd2427 & Rd2831 & const1617Z & op1823=0x25
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local result:4 = Rd2427 + mres;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.QE[c], E[d], D[a], D[b] U, n (RRR1)
:madds.q Re2831,Re2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x38
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[16,16]));
	local result:8 = Re2427 + (tmp << const1617Z);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q E[c], E[d], D[a], D[b] L, n (RRR1)
:madds.q Re2831,Re2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x39
{
	local tmp:8 = sext(Rd0811 * sext(Rd1215[0,16]));
	local result:8 = Re2427 + (tmp << const1617Z);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q E[c], E[d], D[a], D[b], n (RRR1)
:madds.q Re2831,Re2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x3b
{
	local tmp:8 = sext(Rd0811 * Rd1215);
	tmp = tmp << const1617Z;
	local result:8 = Re2427 + tmp;
	overflowflags(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q E[c], E[d], D[a] U, D[b] U, n (RRR1)
:madds.q Re2831,Re2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x3c
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext(mres << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.Q E[c], E[d], D[a] L, D[b] L, n (RRR1)
:madds.q Re2831,Re2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x43 ; Re2427 & Re2831 & const1617Z & op1823=0x3d
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext(mres << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

# MADDS.U D[c], D[d], D[a], const9 (RCR)
:madds.u Rd2831,Rd2427,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Rd2427 & Rd2831 & op2123=0x4 ) & const1220Z
{
	local result:4 = Rd2427 + (Rd0811 * const1220Z);
	overflowflags(result);
	suov(Rd2831, result, 32);
}

# MADDS.U D[c], D[d], D[a], D[b] (RRR2)
:madds.u Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Rd2427 & Rd2831 & op1623=0x88
{
	local result:4 = Rd2427 + (Rd0811 * Rd1215);
	overflowflags(result);
	suov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.U E[c], E[d], D[a], const9 (RCR)
:madds.u Re2831,Re2427,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x13 ; Re2427 & Re2831 & op2123=0x6 ) & const1220Z
{
	local result:8 = Re2427 + zext(Rd0811 * const1220Z);
	overflowflagsd(result);
	suov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDS.U E[c], E[d], D[a], D[b] (RRR2)
:madds.u Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x3 ; Re2427 & Re2831 & op1623=0xe8
{
	local result:8 = Re2427 + zext(Rd0811 * Rd1215);
	overflowflags(result);
	suov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSU.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:maddsu.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x18
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSU.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:maddsu.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x19
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSU.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:maddsu.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSU.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:maddsu.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUM.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:maddsum.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x1c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUM.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:maddsum.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x1d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUM.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:maddsum.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUM.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:maddsum.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x1f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUMS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:maddsums.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x3c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUMS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:maddsums.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x3d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUMS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:maddsums.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x3e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUMS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:maddsums.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Re2427 & Re2831 & const1617Z & op1823=0x3f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 + sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUR.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:maddsur.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xc
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUR.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:maddsur.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xd
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUR.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:maddsur.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xe
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUR.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:maddsur.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xf
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSURS.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:maddsurs.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSURS.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:maddsurs.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSURS.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:maddsurs.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSURS.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:maddsurs.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) + mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:maddsus.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x38
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:maddsus.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x39
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	ssov(Reo2831, Reo2427 + mres1, 32);
	ssov(Ree2831, Ree2427 - mres0, 32);
	overflowflagsww(Reo2427 + mres1, Ree2427 - mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:maddsus.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MADDSUS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:maddsus.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 + mres1;
	local result0:4 = Ree2427 - mres0;
	ssov(Reo2831, result1, 32);
	ssov(Ree2831, result0, 32);
	overflowflagsww(result1, result0);
}
@endif

# MAX D[c], D[a], D[b] (RR)
:max Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x1a0
{
	ternary(Rd2831, Rd0811 s> Rd1215, Rd0811, Rd1215);
}

# MAX D[c], D[a], const9 (RC)
:max Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x1a ) & const1220S
{
	ternary(Rd2831, Rd0811 s> const1220S, Rd0811, const1220S);
}

# MAX.B D[c], D[a], D[b] (RR)
:max.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x5a0
{
	local result3:4;
	local result2:4;
	local result1:4;
	local result0:4;
	ternary(result3, (Rd0811[24,8] s> Rd1215[24,8]), zext(Rd0811[24,8]), zext(Rd1215[24,8]));
	ternary(result2, (Rd0811[16,8] s> Rd1215[16,8]), zext(Rd0811[16,8]), zext(Rd1215[16,8]));
	ternary(result1, (Rd0811[8,8] s> Rd1215[8,8]), zext(Rd0811[8,8]), zext(Rd1215[8,8]));
	ternary(result0, (Rd0811[0,8] s> Rd1215[0,8]), zext(Rd0811[0,8]), zext(Rd1215[0,8]));
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# MAX.BU D[c], D[a], D[b] (RR)
:max.bu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x5b0
{
	local result3:4;
	local result2:4;
	local result1:4;
	local result0:4;
	ternary(result3, (Rd0811[24,8] > Rd1215[24,8]), zext(Rd0811[24,8]), zext(Rd1215[24,8]));
	ternary(result2, (Rd0811[16,8] > Rd1215[16,8]), zext(Rd0811[16,8]), zext(Rd1215[16,8]));
	ternary(result1, (Rd0811[8,8] > Rd1215[8,8]), zext(Rd0811[8,8]), zext(Rd1215[8,8]));
	ternary(result0, (Rd0811[0,8] > Rd1215[0,8]), zext(Rd0811[0,8]), zext(Rd1215[0,8]));
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# MAX.H D[c], D[a], D[b] (RR)
:max.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x7a0
{
	local result1:4;
	local result0:4;
	ternary(result1, (Rd0811[16,16] s> Rd1215[16,16]), zext(Rd0811[16,16]), zext(Rd1215[16,16]));
	ternary(result0, (Rd0811[0,16] s> Rd1215[0,16]), zext(Rd0811[0,16]), zext(Rd1215[0,16]));
	Rd2831 = (result1 << 16) | (result0);
}

# MAX.HU D[c], D[a], D[b] (RR)
:max.hu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x7b0
{
	local result1:4;
	local result0:4;
	ternary(result1, (Rd0811[16,16] > Rd1215[16,16]), zext(Rd0811[16,16]), zext(Rd1215[16,16]));
	ternary(result0, (Rd0811[0,16] > Rd1215[0,16]), zext(Rd0811[0,16]), zext(Rd1215[0,16]));
	Rd2831 = (result1 << 16) | (result0);
}

# MAX.U D[c], D[a], D[b] (RR)
:max.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x1b0
{
	ternary(Rd2831, Rd0811 > Rd1215, Rd0811, Rd1215);
}

# MAX.U D[c], D[a], const9 (RC)
:max.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x1b ) & const1220Z
{
	ternary(Rd2831, Rd0811 > const1220Z, Rd0811, const1220Z);
}

# MFCR D[c], const16 (RLC)
:mfcr Rd2831,const1227Z is PCPMode=0 & ( op0007=0x4d & op0811=0x0 ; Rd2831 ) & const1227Z
{
	Rd2831 = *[register]:4 const1227Z;
}

@if defined(TRICORE_V2)
:mffr Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x1d1
{
	Rd2831 = *[register]:4 Rd0811;
}
@endif

# MIN D[c], D[a], D[b] (RR)
:min Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x180
{
	ternary(Rd2831, Rd0811 s< Rd1215, Rd0811, Rd1215);
}

# MIN D[c], D[a], const9 (RC)
:min Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x18 ) & const1220S
{
	ternary(Rd2831, Rd0811 s< const1220S, Rd0811, const1220S);
}

# MIN.B D[c], D[a], D[b] (RR)
:min.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x580
{
	local result3:4;
	local result2:4;
	local result1:4;
	local result0:4;
	ternary(result3, (Rd0811[24,8] s< Rd1215[24,8]), zext(Rd0811[24,8]), zext(Rd1215[24,8]));
	ternary(result2, (Rd0811[16,8] s< Rd1215[16,8]), zext(Rd0811[16,8]), zext(Rd1215[16,8]));
	ternary(result1, (Rd0811[8,8] s< Rd1215[8,8]), zext(Rd0811[8,8]), zext(Rd1215[8,8]));
	ternary(result0, (Rd0811[0,8] s< Rd1215[0,8]), zext(Rd0811[0,8]), zext(Rd1215[0,8]));
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# MIN.BU D[c], D[a], D[b] (RR)
:min.bu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x590
{
	local result3:4;
	local result2:4;
	local result1:4;
	local result0:4;
	ternary(result3, (Rd0811[24,8] < Rd1215[24,8]), zext(Rd0811[24,8]), zext(Rd1215[24,8]));
	ternary(result2, (Rd0811[16,8] < Rd1215[16,8]), zext(Rd0811[16,8]), zext(Rd1215[16,8]));
	ternary(result1, (Rd0811[8,8] < Rd1215[8,8]), zext(Rd0811[8,8]), zext(Rd1215[8,8]));
	ternary(result0, (Rd0811[0,8] < Rd1215[0,8]), zext(Rd0811[0,8]), zext(Rd1215[0,8]));
	Rd2831 = (result3 << 24) | (result2 << 16) | (result1 << 8) | (result0);
}

# MIN.H D[c], D[a], D[b] (RR)
:min.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x780
{
	local result1:4;
	local result0:4;
	ternary(result1, (Rd0811[16,16] s< Rd1215[16,16]), zext(Rd0811[16,16]), zext(Rd1215[16,16]));
	ternary(result0, (Rd0811[0,16] s< Rd1215[0,16]), zext(Rd0811[0,16]), zext(Rd1215[0,16]));
	Rd2831 = (result1 << 16) | (result0);
}

# MIN.HU D[c], D[a], D[b] (RR)
:min.hu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x790
{
	local result1:4;
	local result0:4;
	ternary(result1, (Rd0811[16,16] < Rd1215[16,16]), zext(Rd0811[16,16]), zext(Rd1215[16,16]));
	ternary(result0, (Rd0811[0,16] < Rd1215[0,16]), zext(Rd0811[0,16]), zext(Rd1215[0,16]));
	Rd2831 = (result1 << 16) | (result0);
}

# MIN.U D[c], D[a], D[b] (RR)
:min.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x190
{
	ternary(Rd2831, Rd0811 < Rd1215, Rd0811, Rd1215);
}

# MIN.U D[c], D[a], const9 (RC)
:min.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x19 ) & const1220Z
{
	ternary(Rd2831, Rd0811 < const1220Z, Rd0811, const1220Z);
}

# MOV D[a], D[b] (SRR)
:mov Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2
{
	Rd0811 = Rd1215;
}

# MOV D[a], const4 (SRC)
:mov Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & op0007=0x82
{
	Rd0811 = const1215S;
}

@if defined(TRICORE_V2)
# MOV E[a], const4 (SRC)
:mov Re0811,const1215S is PCPMode=0 & Re0811 & const1215S & op0007=0xd2
{
	Re0811 = sext(const1215S);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MOV D[15], const8 (SC)
:mov d15,const0815Z is PCPMode=0 & const0815Z & d15 & op0007=0xda
{
	d15 = const0815Z;
}
@endif

# MOV D[c], const16 (RLC)
:mov Rd2831,const1227S is PCPMode=0 & ( op0007=0x3b & op0811=0x0 ; Rd2831 ) & const1227S
{
	Rd2831 = const1227S;
}

# MOV D[c], D[b] (RR)
:mov Rd2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Rd2831 & op1627=0x1f0
{
	Rd2831 = Rd1215;
}

@if defined(TRICORE_V2)
# MOV E[c], const16 (RLC)
:mov Re2831,const1227S is PCPMode=0 & ( op0007=0xfb & op0811=0x0 ; Re2831 ) & const1227S
{
	Re2831 = sext(const1227S);
}
@endif

@if defined(TRICORE_V2)
# MOV E[c], D[b] (RR)
:mov Re2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0xb & op0811=0 ; Re2831 & op1627=0x800
{
	Re2831 = sext(Rd1215);
}
@endif

@if defined(TRICORE_V2)
# MOV E[c], D[a], D[b] (RR)
:mov Ree2831/Reo2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Ree2831 & Reo2831 & op1627=0x810
{
	local tmp1 = Rd0811;
	local tmp0 = Rd1215;
	Reo2831 = tmp1;
	Ree2831 = tmp0;
}
@endif


@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MOV.A A[a], const4 (SRC)
:mov.a Ra0811,const1215Z is PCPMode=0 & Ra0811 & const1215Z & op0007=0xa0
{
	Ra0811 = const1215Z;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MOV.A A[a], D[b] (SRR)
:mov.a Ra0811,Rd1215 is PCPMode=0 & Ra0811 & Rd1215 & op0007=0x60
{
	Ra0811 = Rd1215;
}
@endif

# MOV.A A[c], D[b] (RR)
:mov.a Ra2831,Rd1215 is PCPMode=0 & Rd1215 & op0007=0x1 & op0811=0x0 ; Ra2831 & op1627=0x630
{
	Ra2831 = Rd1215;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MOV.AA A[a], A[b] (SRR)
:mov.aa Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x40
{
	Ra0811 = Ra1215;
}
@endif

# MOV.AA A[c], A[b] (RR)
:mov.aa Ra2831,Ra1215 is PCPMode=0 & Ra1215 & op0007=0x1 & op0811=0x0 ; Ra2831 & op1627=0x0
{
	Ra2831 = Ra1215;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MOV.D D[a], A[b] (SRR)
:mov.d Rd0811,Ra1215 is PCPMode=0 & Ra1215 & Rd0811 & op0007=0x80
{
	Rd0811 = Ra1215;
}
@endif

# MOV.D D[c], A[b] (RR)
:mov.d Rd2831,Ra1215 is PCPMode=0 & Ra1215 & op0007=0x1 & op0811=0x0 ; Rd2831 & op1627=0x4c0
{
	Rd2831 = Ra1215;
}

# MOV.U D[c], const16 (RLC)
:mov.u Rd2831,const1227Z is PCPMode=0 & ( op0007=0xbb & op0811=0x0 ; Rd2831 ) & const1227Z
{
	Rd2831 = const1227Z;
}

# MOVH D[c], const16 (RLC)
:movh Rd2831,const1227Z is PCPMode=0 & ( op0007=0x7b & op0811=0x0 ; Rd2831 ) & const1227Z
{
	Rd2831 = const1227Z << 16;
}

# MOVH.A A[c], const16 (RLC)
:movh.a Ra2831,const1227Z is PCPMode=0 & ( op0007=0x91 & op0811=0x0 ; Ra2831 ) & const1227Z
{
	Ra2831 = const1227Z << 16;
}

#MSUB D[c], D[d], D[a], D[b] (RRR2)
:msub Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Rd2427 & Rd2831 & op1623=0xa
{
	Rd2831 = Rd2427 - (Rd0811 * Rd1215);
	overflowflags(Rd2831);
}

# MSUB D[c], D[d], D[a], const9 (RCR)
:msub Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Rd2427 & Rd2831 & op2123=0x1 ) & const1220S
{
	Rd2831 = Rd2427 - (Rd0811 * const1220S);
	overflowflags(Rd2831);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB E[c], E[d], D[a], const9 (RCR)
:msub Re2831,Re2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Re2427 & Re2831 & op2123=0x3 ) & const1220S
{
	Re2831 = Re2427 - sext(Rd0811 * const1220S);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB E[c], E[d], D[a], D[b] (RRR2)
:msub Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Re2427 & Re2831 & op1623=0x6a
{
	Re2831 = Re2427 - sext(Rd0811 * Rd1215);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.F D[c], D[d], D[a], D[b] (RRR)
:msub.f Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x6b ; Rd2427 & Rd2831 & op1623=0x71
{
	#TODO  float
	#TODO  flags
	Rd2831 = Rd2427 f- (Rd0811 f* Rd1215);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msub.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x18
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 - mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msub.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x19
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 - mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msub.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 - mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msub.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result1:4 = Reo2427 - mres1;
	local result0:4 = Ree2427 - mres0;
	Reo2831 = result1;
	Ree2831 = result0;
	overflowflagsww(result1, result0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:msub.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x4
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	Rd2831 = Rd2427 - mres;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q D[c], D[d], D[a], D[b] U, n (RRR1)
:msub.q Rd2831,Rd2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x0
{
	Rd2831 = Rd2427 - (((Rd0811 * sext(Rd1215[16,16])) << const1617Z) s>> 16);
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q D[c], D[d], D[a], D[b] L, n (RRR1)
:msub.q Rd2831,Rd2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x1
{
	Rd2831 = Rd2427 - (((Rd0811 * sext(Rd1215[0,16])) << const1617Z) s>> 16);
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q D[c], D[d], D[a], D[b], n (RRR1)
:msub.q Rd2831,Rd2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2
{
	Rd2831 = Rd2427 - (((Rd0811 * Rd1215) << const1617Z) s>> 32);
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:msub.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x5
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	Rd2831 = Rd2427 - mres;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q E[c], E[d], D[a], D[b] U, n (RRR1)
:msub.q Re2831,Re2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x18
{
	Re2831 = Re2427 - sext((Rd0811 * sext(Rd1215[16,16])) << const1617Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q E[c], E[d], D[a], D[b] L, n (RRR1)
:msub.q Re2831,Re2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x19
{
	Re2831 = Re2427 - sext((Rd0811 * sext(Rd1215[0,16])) << const1617Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q E[c], E[d], D[a], D[b], n (RRR1)
:msub.q Re2831,Re2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x1b
{
	Re2831 = Re2427 - sext((Rd0811 * Rd1215) << const1617Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.Q E[c], E[d], D[a] U, D[b] U, n (RRR1)
:msub.q Re2831,Re2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x1c
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 - sext(mres << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SUB.Q E[c], E[d], D[a] L, D[b] L, n (RRR1)
:msub.q Re2831,Re2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x1d
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 - sext(mres << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.U E[c], E[d], D[a], const9 (RCR)
:msub.u Re2831,Re2427,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Re2427 & Re2831 & op2123=0x2 ) & const1220Z
{
	Re2831 = Re2427 - zext(Rd0811 * const1220Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUB.U E[c], E[d], D[a], D[b] (RRR2)
:msub.u Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Re2427 & Re2831 & op1623=0x68
{
	Re2831 = Re2427 - zext(Rd0811 * Rd1215);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBAD.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubad.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x18
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	Reo2831 = res1;
	Ree2831 = res0;
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBAD.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubad.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x19
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	Reo2831 = res1;
	Ree2831 = res0;
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBAD.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubad.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	Reo2831 = res1;
	Ree2831 = res0;
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBAD.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubad.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x1b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	Reo2831 = res1;
	Ree2831 = res0;
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADM.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubadm.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x1c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADM.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubadm.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x1d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADM.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubadm.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADM.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubadm.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x1f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADMS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubadms.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x3c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADMS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubadms.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x3d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADMS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubadms.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x3e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADMS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubadms.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Re2427 & Re2831 & const1617Z & op1823=0x3f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local result:8 = Re2427 - sext((mres1 - mres0) << 16);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADR.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:msubadr.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xc
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:msubadr.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xd
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADR.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:msubadr.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xe
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADR.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:msubadr.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xf
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
	overflowflagsww(res1, res0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADRS.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:msubadrs.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADRS.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:msubadrs.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADRS.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:msubadrs.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADRS.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:msubadrs.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) + mres0 + 0x8000;
	overflowflagsww(res1, res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubads.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x38
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubads.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x39
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubads.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBADS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubads.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 + mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBM.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubm.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x1c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	Re2831 = res;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBM.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubm.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x1d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	Re2831 = res;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBM.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubm.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	Re2831 = res;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBM.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubm.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x1f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	Re2831 = res;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBMS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubms.h Re2831,Re2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x3c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	ssov(Re2427, res, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBMS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubms.h Re2831,Re2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x3d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	ssov(Re2427, res, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBMS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubms.h Re2831,Re2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x3e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	ssov(Re2427, res, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBMS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubms.h Re2831,Re2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Re2427 & Re2831 & const1617Z & op1823=0x3f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - (sext(mres1 + mres0) << 16);
	overflowflagsd(res);
	ssov(Re2427, res, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.H D[c], E[d], D[a], D[b] UL, n (RRR1)
:msubr.h Rd2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2831 & Ree2427 & Reo2427 & const1617Z & op1823=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1 + 0x8000;
	local res0:4 = Ree2427 - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:msubr.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xc
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:msubr.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xd
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:msubr.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xe
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:msubr.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0xf
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:msubr.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x6
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 - mres + 0x8000;
	overflowflags(res);
	Rd2831 = zext(res[16,16]) << 16;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBR.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:msubr.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x7
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 - mres + 0x8000;
	overflowflags(res);
	Rd2831 = zext(res[16,16]) << 16;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.H D[c], E[d], D[a], D[b] UL, n (RRR1)
:msubrs.h Rd2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2831 & Ree2427 & Reo2427 & const1617Z & op1823=0x3e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1 + 0x8000;
	local res0:4 = Ree2427 - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.H D[c], D[d], D[a], D[b] UL, n (RRR1)
:msubrs.h Rd2831,Rd2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.H D[c], D[d], D[a], D[b] LU, n (RRR1)
:msubrs.h Rd2831,Rd2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.H D[c], D[d], D[a], D[b] LL, n (RRR1)
:msubrs.h Rd2831,Rd2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.H D[c], D[d], D[a], D[b] UU, n (RRR1)
:msubrs.h Rd2831,Rd2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Rd2427 & Rd2831 & const1617Z & op1823=0x2f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = sext(Rd2427[16,16] << 16) - mres1 + 0x8000;
	local res0:4 = sext(Rd2427[0,16] << 16) - mres0 + 0x8000;
	overflowflagsww(res1,res0);
	ssov(res1, res1, 32);
	ssov(res0, res0, 32);
	Rd2831 = (zext(res1[16,16]) << 16) | zext(res0[16,16]);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:msubrs.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x26
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 - mres + 0x8000;
	overflowflags(res);
	ssov(res, res, 32);
	Rd2831 = zext(res[16,16]) << 16;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBRS.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:msubrs.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x27
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 - mres + 0x8000;
	overflowflags(res);
	ssov(res, res, 32);
	Rd2831 = zext(res[16,16]) << 16;
}
@endif

# MSUBS D[c], D[d], D[a], D[b] (RRR2)
:msubs Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Rd2427 & Rd2831 & op1623=0x8a
{
	Rd2831 = Rd2427 - (Rd0811 - Rd1215);
	overflowflags(Rd2831);
	ssov(Rd2831, Rd2831, 32);
}

# MSUBS D[c], D[d], D[a], const9 (RCR)
:msubs Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Rd2427 & Rd2831 & op2123=0x5 ) & const1220S
{
	local result:4 = Rd2427 - (Rd0811 - const1220S);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS E[c], E[d], D[a], const9 (RCR)
:msubs Re2831,Re2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Re2427 & Re2831 & op2123=0x7 ) & const1220S
{
	local result:8 = Re2427 - sext(Rd0811 - const1220S);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS E[c], E[d], D[a], D[b] (RRR2)
:msubs Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Re2427 & Re2831 & op1623=0xea
{
	local result:8 = Re2427 - sext(Rd0811 - Rd1215);
	overflowflags(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.H E[c], E[d], D[a], D[b] UL, n (RRR1)
:msubs.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x38
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 - mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.H E[c], E[d], D[a], D[b] LU, n (RRR1)
:msubs.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x39
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 - mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.H E[c], E[d], D[a], D[b] LL, n (RRR1)
:msubs.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 - mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.H E[c], E[d], D[a], D[b] UU, n (RRR1)
:msubs.h Ree2831/Reo2831,Ree2427/Reo2427,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa3 ; Ree2427 & Reo2427 & Ree2831 & Reo2831 & const1617Z & op1823=0x3b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	local res1:4 = Reo2427 - mres1;
	local res0:4 = Ree2427 - mres0;
	overflowflagsww(res1, res0);
	ssov(Reo2831, res1, 32);
	ssov(Ree2831, res0, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q D[c], D[d], D[a] U, D[b] U, n (RRR1)
:msubs.q Rd2831,Rd2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x24
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 - mres;
	overflowflags(res);
	ssov(Rd2831, res, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q D[c], D[d], D[a], D[b] U, n (RRR1)
:msubs.q Rd2831,Rd2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x20
{
	local result:4 = Rd2427 - (((Rd0811 * sext(Rd1215[16,16])) << const1617Z) s>> 16);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q D[c], D[d], D[a], D[b] L, n (RRR1)
:msubs.q Rd2831,Rd2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x21
{
	local result:4 = Rd2427 - (((Rd0811 * sext(Rd1215[0,16])) << const1617Z) s>> 16);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q D[c], D[d], D[a], D[b], n (RRR1)
:msubs.q Rd2831,Rd2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x22
{
	local result:4 = Rd2427 - (((Rd0811 * Rd1215) << const1617Z) s>> 32);
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q D[c], D[d], D[a] L, D[b] L, n (RRR1)
:msubs.q Rd2831,Rd2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Rd2427 & Rd2831 & const1617Z & op1823=0x25
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local res:4 = Rd2427 - mres;
	overflowflags(res);
	ssov(Rd2831, res, 32);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q E[c], E[d], D[a], D[b] U, n (RRR1)
:msubs.q Re2831,Re2427,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x38
{
	local result:8 = Re2427 - sext((Rd0811 * sext(Rd1215[16,16])) << const1617Z);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q E[c], E[d], D[a], D[b] L, n (RRR1)
:msubs.q Re2831,Re2427,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x39
{
	local result:8 = Re2427 - sext((Rd0811 * sext(Rd1215[0,16])) << const1617Z);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q E[c], E[d], D[a], D[b], n (RRR1)
:msubs.q Re2831,Re2427,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x3b
{
	local result:8 = Re2427 - sext((Rd0811 * Rd1215) << const1617Z);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q E[c], E[d], D[a] U, D[b] U, n (RRR1)
:msubs.q Re2831,Re2427,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x3c
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - sext(mres << 16);
	overflowflagsd(res);
	ssov(Re2831, res, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.Q E[c], E[d], D[a] L, D[b] L, n (RRR1)
:msubs.q Re2831,Re2427,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x63 ; Re2427 & Re2831 & const1617Z & op1823=0x3d
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	local res:8 = Re2427 - sext(mres << 16);
	overflowflagsd(res);
	ssov(Re2831, res, 64);
}
@endif

# MSUBS.U D[c], D[d], D[a], const9 (RCR)
:msubs.u Rd2831,Rd2427,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Rd2427 & Rd2831 & op2123=0x4 ) & const1220Z
{
	local result:4 = Rd2427 - (Rd0811 - const1220Z);
	overflowflags(result);
	suov(Rd2831, result, 32);
}

# MSUBS.U D[c], D[d], D[a], D[b] (RRR2)
:msubs.u Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Rd2427 & Rd2831 & op1623=0x88
{
	local result:4 = Rd2427 - (Rd0811 - Rd1215);
	overflowflags(result);
	suov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.U E[c], E[d], D[a], const9 (RCR)
:msubs.u Re2831,Re2427,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x33 ; Re2427 & Re2831 & op2123=0x6 ) & const1220Z
{
	local result:8 = Re2427 - zext(Rd0811 - const1220Z);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MSUBS.U E[c], E[d], D[a], D[b] (RRR2)
:msubs.u Re2831,Re2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x23 ; Re2427 & Re2831 & op1623=0xe8
{
	local result:8 = Re2427 - zext(Rd0811 - Rd1215);
	overflowflagsd(result);
	ssov(Re2831, result, 64);
}
@endif

# MTCR const16, D[a] (RLC)
:mtcr const1227Z,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xcd ; op2831=0x0 ) & const1227Z
{
	*[register]:4 const1227Z = Rd0811;
}

@if defined(TRICORE_V2)
:mtfr Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; op1631=0x1c1
{
	*[register]:4 Rd1215 = Rd0811;
}
@endif

# MUL D[a], D[b] (SRR)
:mul Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xe2
{
	Rd0811 = Rd0811 * Rd1215;
	overflowflags(Rd0811);
}

# MUL D[c], D[a], const9 (RC)
:mul Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x53 ; Rd2831 & op2127=0x1 ) & const1220S
{
	Rd2831 = Rd0811 * const1220S;
	overflowflags(Rd2831);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL D[c], D[a], D[b] (RR2)
:mul Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x73 ; Rd2831 & op1627=0xa
{
	Rd2831 = Rd0811 * Rd1215;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL E[c], D[a], const9 (RC)
:mul Re2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x53 ; Re2831 & op2127=0x3 ) & const1220S
{
	Re2831 = sext(Rd0811 * const1220S);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL E[c], D[a], D[b] (RR2)
:mul Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x73 ; Re2831 & op1627=0x6a
{
	Re2831 = sext(Rd0811 * Rd1215);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.F D[c], D[a], D[b] (RR)
:mul.f Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x41
{
	#TODO  float
	#TODO  flags
	Rd2831 = Rd0811 f* Rd1215;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.H E[c], D[a], D[b] UL, n (RR1)
:mul.h Ree2831/Reo2831,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Ree2831 & Reo2831 & const1617Z & op1827=0x18
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Reo2831 = mres1;
	Ree2831 = mres0;
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.H E[c], D[a], D[b] LU, n (RR1)
:mul.h Ree2831/Reo2831,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Ree2831 & Reo2831 & const1617Z & op1827=0x19
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Reo2831 = mres1;
	Ree2831 = mres0;
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.H E[c], D[a], D[b] LL, n (RR1)
:mul.h Ree2831/Reo2831,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Ree2831 & Reo2831 & const1617Z & op1827=0x1a
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Reo2831 = mres1;
	Ree2831 = mres0;
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.H E[c], D[a], D[b] UU, n (RR1)
:mul.h Ree2831/Reo2831,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Ree2831 & Reo2831 & const1617Z & op1827=0x1b
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Reo2831 = mres1;
	Ree2831 = mres0;
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q D[c], D[a], D[b] U, n (RR1)
:mul.q Rd2831,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x0
{
	Rd2831 = ((Rd0811 * sext(Rd1215[16,16])) << const1617Z) s>> 16;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q D[c], D[a], D[b] L, n (RR1)
:mul.q Rd2831,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x1
{
	Rd2831 = ((Rd0811 * sext(Rd1215[0,16])) << const1617Z) s>> 16;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q D[c], D[a], D[b], n (RR1)
:mul.q Rd2831,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x2
{
	Rd2831 = ((Rd0811 * Rd1215) << const1617Z) s>> 32;
	overflowflags(Rd2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q D[c], D[a] U, D[b] U, n (RR1)
:mul.q Rd2831,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x4
{
	local mres:4;
	multiply_u_u(mres, Rd0811, Rd1215, const1617Z);
	overflowflags(mres);
	Rd2831 = mres;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q D[c], D[a] L, D[b] L, n (RR1)
:mul.q Rd2831,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x5
{
	local mres:4;
	multiply_l_l(mres, Rd0811, Rd1215, const1617Z);
	overflowflags(mres);
	Rd2831 = mres;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q E[c], D[a], D[b] U, n (RR1)
:mul.q Re2831,Rd0811,Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Re2831 & const1617Z & op1827=0x18
{
	Re2831 = sext(Rd0811 * sext(Rd1215[16,16])) << const1617Z;
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q E[c], D[a], D[b] L, n (RR1)
:mul.q Re2831,Rd0811,Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Re2831 & const1617Z & op1827=0x19
{
	Re2831 = sext(Rd0811 * sext(Rd1215[0,16])) << const1617Z;
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.Q E[c], D[a], D[b], n (RR1)
:mul.q Re2831,Rd0811,Rd1215,const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Re2831 & const1617Z & op1827=0x1b
{
	Re2831 = sext(Rd0811 * Rd1215) << const1617Z;
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.U E[c], D[a], const9 (RC)
:mul.u Re2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x53 ; Re2831 & op2127=0x2 ) & const1220Z
{
	Re2831 = zext(Rd0811 * const1220Z);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MUL.U E[c], D[a], D[b] (RR2)
:mul.u Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x73 ; Re2831 & op1627=0x68
{
	Re2831 = zext(Rd0811 * Rd1215);
	overflowflagsd(Re2831);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULM.H E[c], D[a], D[b] UL, n (RR1)
:mulm.h Re2831,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Re2831 & const1617Z & op1827=0x1c
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ul(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = sext(mres1 + mres0) << 16;
	$(PSW_V) = 0;
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULM.H E[c], D[a], D[b] LU, n (RR1)
:mulm.h Re2831,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Re2831 & const1617Z & op1827=0x1d
{
	local mres1:4;
	local mres0:4;
	packed_multiply_lu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = sext(mres1 + mres0) << 16;
	$(PSW_V) = 0;
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULM.H E[c], D[a], D[b] LL, n (RR1)
:mulm.h Re2831,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Re2831 & const1617Z & op1827=0x1e
{
	local mres1:4;
	local mres0:4;
	packed_multiply_ll(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = sext(mres1 + mres0) << 16;
	$(PSW_V) = 0;
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULM.H E[c], D[a], D[b] UU, n (RR1)
:mulm.h Re2831,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Re2831 & const1617Z & op1827=0x1f
{
	local mres1:4;
	local mres0:4;
	packed_multiply_uu(mres1, mres0, Rd0811, Rd1215, const1617Z);
	Re2831 = sext(mres1 + mres0) << 16;
	$(PSW_V) = 0;
	$(PSW_AV) = 0;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULR.H D[c], D[a], D[b] UL, n (RR1)
:mulr.h Rd2831,Rd0811,Rd1215^"ul",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Rd2831 & const1617Z & op1827=0xc
{
	local sc1 = (Rd0811[16,16] == 0x8000) && (Rd1215[16,16] == 0x8000) && (const1617Z == 1);
	local sc0 = (Rd0811[0,16] == 0x8000) && (Rd1215[0,16] == 0x8000) && (const1617Z == 1);
	local mres1:4;
	local mres0:4;
	ternary(mres1, sc1, 0x7FFFFFFF, sext(((Rd0811[16,16] * Rd1215[16,16]) << const1617Z) + 0x8000));
	ternary(mres0, sc0, 0x7FFFFFFF, sext(((Rd0811[0,16] * Rd1215[0,16]) << const1617Z) + 0x8000));
	Rd2831 = (zext(mres1[16,16]) << 16) | zext(mres0[16,16]);
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULR.H D[c], D[a], D[b] LU, n (RR1)
:mulr.h Rd2831,Rd0811,Rd1215^"lu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Rd2831 & const1617Z & op1827=0xd
{
	local sc1 = (Rd0811[16,16] == 0x8000) && (Rd1215[0,16] == 0x8000) && (const1617Z == 1);
	local sc0 = (Rd0811[0,16] == 0x8000) && (Rd1215[16,16] == 0x8000) && (const1617Z == 1);
	local mres1:4;
	local mres0:4;
	ternary(mres1, sc1, 0x7FFFFFFF, sext(((Rd0811[16,16] * Rd1215[0,16]) << const1617Z) + 0x8000));
	ternary(mres0, sc0, 0x7FFFFFFF, sext(((Rd0811[0,16] * Rd1215[16,16]) << const1617Z) + 0x8000));
	Rd2831 = (zext(mres1[16,16]) << 16) | zext(mres0[16,16]);
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# # MULR.H D[c], D[a], D[b] LL, n (RR1)
:mulr.h Rd2831,Rd0811,Rd1215^"ll",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Rd2831 & const1617Z & op1827=0xe
{
	local sc1 = (Rd0811[16,16] == 0x8000) && (Rd1215[0,16] == 0x8000) && (const1617Z == 1);
	local sc0 = (Rd0811[0,16] == 0x8000) && (Rd1215[0,16] == 0x8000) && (const1617Z == 1);
	local mres1:4;
	local mres0:4;
	ternary(mres1, sc1, 0x7FFFFFFF, sext(((Rd0811[16,16] * Rd1215[0,16]) << const1617Z) + 0x8000));
	ternary(mres0, sc0, 0x7FFFFFFF, sext(((Rd0811[0,16] * Rd1215[0,16]) << const1617Z) + 0x8000));
	Rd2831 = (zext(mres1[16,16]) << 16) | zext(mres0[16,16]);
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULR.H D[c], D[a], D[b] UU, n (RR1)
:mulr.h Rd2831,Rd0811,Rd1215^"uu",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb3 ; Rd2831 & const1617Z & op1827=0xf
{
	local sc1 = (Rd0811[0,16] == 0x8000) && (Rd1215[16,16] == 0x8000) && (const1617Z == 1);
	local sc0 = (Rd0811[16,16] == 0x8000) && (Rd1215[16,16] == 0x8000) && (const1617Z == 1);
	local mres1:4;
	local mres0:4;
	ternary(mres1, sc1, 0x7FFFFFFF, sext(((Rd0811[0,16] * Rd1215[16,16]) << const1617Z) + 0x8000));
	ternary(mres0, sc0, 0x7FFFFFFF, sext(((Rd0811[16,16] * Rd1215[16,16]) << const1617Z) + 0x8000));
	Rd2831 = (zext(mres1[16,16]) << 16) | zext(mres0[16,16]);
	advoverflowflagsww(mres1, mres0);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULR.Q D[c], D[a] U, D[b] U, n (RR1)
:mulr.q Rd2831,Rd0811^"u",Rd1215^"u",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x6
{
	local sc = (Rd0811[16,16] == 0x8000) && (Rd1215[16,16] == 0x8000) && (const1617Z == 1);
	local res:4;
	ternary(res, sc, 0x7FFFFFFF, ((sext(Rd0811[16,16] * Rd1215[16,16]) << const1617Z) + 0x8000));
	Rd2831 = zext(res[16,16] << 16);
	advoverflowflags(res);
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULR.Q D[c], D[a] L, D[b] L, n (RR1)
:mulr.q Rd2831,Rd0811^"l",Rd1215^"l",const1617Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x93 ; Rd2831 & const1617Z & op1827=0x7
{
	local sc = (Rd0811[0,16] == 0x8000) && (Rd1215[0,16] == 0x8000) && (const1617Z == 1);
	local res:4;
	ternary(res, sc, 0x7FFFFFFF, ((sext(Rd0811[0,16] * Rd1215[0,16]) << const1617Z) + 0x8000));
	Rd2831 = zext(res[16,16] << 16);
	advoverflowflags(res);
}
@endif

# MULS D[c], D[a], const9 (RC)
:muls Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x53 ; Rd2831 & op2127=0x5 ) & const1220S
{
	local result:4 = Rd0811 * const1220S;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULS D[c], D[a], D[b] (RR2)
:muls Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x73 ; Rd2831 & op1627=0x8a
{
	local result:4 = Rd0811 * Rd1215;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}
@endif

# MULS.U D[c], D[a], const9 (RC)
:muls.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x53 ; Rd2831 & op2127=0x4 ) & const1220Z
{
	local result:4 = Rd0811 * const1220Z;
	overflowflags(result);
	suov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# MULS.U D[c], D[a], D[b] (RR2)
:muls.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x73 ; Rd2831 & op1627=0x88
{
	local result:4 = Rd0811 * Rd1215;
	overflowflags(result);
	suov(Rd2831, result, 32);
}
@endif

# NAND D[c], D[a], D[b] (RR)
:nand Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x90
{
	Rd2831 = ~(Rd0811 & Rd1215);
}

# NAND D[c], D[a], const9 (RC)
:nand Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x9 ) & const1220Z
{
	Rd2831 = ~(Rd0811 & const1220Z);
}

# NAND.T D[c], D[a], pos1, D[b], pos2 (BIT)
:nand.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x7 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmp1:4 = (Rd0811 >> const1620Z) & 1;
	local tmp2:4 = (Rd1215 >> const2327Z) & 1;
	Rd2831 = zext(!(tmp1[0,1] & tmp2[0,1]));
}

# NE D[c], D[a], D[b] (RR)
:ne Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x110
{
	Rd2831 = zext(Rd0811 != Rd1215);
}

# NE D[c], D[a], const9 (RC)
:ne Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x11 ) & const1220S
{
	Rd2831 = zext(Rd0811 != const1220S);
}

# NE.A D[c], A[a], A[b] (RR)
:ne.a Rd2831,Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x1 ; Rd2831 & op1627=0x410
{
	Rd2831 = zext(Ra0811 != Ra1215);
}

# NEZ.A D[c], A[a] (RR)
:nez.a Rd2831,Ra0811 is PCPMode=0 & Ra0811 & op0007=0x1 & op1215=0x0 ; Rd2831 & op1627=0x490
{
	Rd2831 = zext(Ra0811 != 0);
}

# NOP (SR)
:nop  is PCPMode=0 & op0007=0x0 & op0815=0x0
{
	local NOP:1 = 0:1;
	NOP = NOP;
}

# NOP (SYS)
:nop  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x0
{
	local NOP:1 = 0:1;
	NOP = NOP;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# NOT D[a] (SR)
:not Rd0811 is PCPMode=0 & Rd0811 & op0007=0x46 & op1215=0x0
{
	Rd0811 = ~Rd0811;
}
@endif

# NOR D[c], D[a], D[b] (RR)
:nor Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0xb0
{
	Rd2831 = ~(Rd0811 | Rd1215);
}

# NOR D[c], D[a], const9 (RC)
:nor Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0xb ) & const1220Z
{
	Rd2831 = ~(Rd0811 | const1220Z);
}

# NOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:nor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x87 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local tmp = (Rd0811 >> const1620Z) & 1;
	local tmp2 = (Rd1215 >> const2327Z) & 1;
	Rd2831 = ~(tmp | tmp2);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# OR D[a], D[b] (SRR)
:or Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa6
{
	Rd0811 = Rd0811 | Rd1215;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# OR D[15], const8 (SC)
:or d15,const0815Z is PCPMode=0 & const0815Z & d15 & op0007=0x96
{
	d15 = d15 | const0815Z;
}
@endif

# OR D[c], D[a], D[b] (RR)
:or Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0xa0
{
	Rd2831 = Rd0811 | Rd1215;
}

# OR D[c], D[a], const9 (RC)
:or Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0xa ) & const1220Z
{
	Rd2831 = Rd0811 | const1220Z;
}

# OR.AND.T D[c], D[a], pos1, D[b], pos2 (BIT)
:or.and.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc7 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmp = (Rd0811 >> const1620Z) & 1;
	local tmp2 = (Rd1215 >> const2327Z) & 1;
	local tmp3 = zext(Rd2831[0,1]);
	tmp3 = tmp3 | (tmp & tmp2);
	Rd2831[0,1] = tmp3[0,1];
}

# OR.ANDN.T D[c], D[a], pos1, D[b], pos2 (BIT)
:or.andn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc7 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local tmp = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp2 = ((Rd1215 >> const2327Z) & 1) == 0;
	local tmp3 = (Rd2831 & 1) == 1;
	tmp3 = tmp3 | (tmp & tmp2);
	Rd2831[0,1] = tmp3;
}

# OR.EQ D[c], D[a], D[b] (RR)
:or.eq Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x270
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 == Rd1215);
}

# OR.EQ D[c], D[a], const9 (RC)
:or.eq Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x27 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 == const1220S);
}

# OR.GE D[c], D[a], D[b] (RR)
:or.ge Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x2b0
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 s>= Rd0811);
}

# OR.GE D[c], D[a], const9 (RC)
:or.ge Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x2b ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 s>= const1220S);
}

# OR.GE.U D[c], D[a], D[b] (RR)
:or.ge.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x2c0
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 >= Rd1215);
}

# OR.GE.U D[c], D[a], const9 (RC)
:or.ge.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x2c ) & const1220Z
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 >= const1220Z);
}

# OR.LT D[c], D[a], D[b] (RR)
:or.lt Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x290
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 s< Rd0811);
}

# OR.LT D[c], D[a], const9 (RC)
:or.lt Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x29 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 s< const1220S);
}

# OR.LT.U D[c], D[a], D[b] (RR)
:or.lt.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x2a0
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 < Rd0811);
}

# OR.LT.U D[c], D[a], const9 (RC)
:or.lt.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x2a ) & const1220Z
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 < const1220Z);
}

# OR.NE D[c], D[a], D[b] (RR)
:or.ne Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x280
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 != Rd0811);
}

# OR.NE D[c], D[a], const9 (RC)
:or.ne Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x28 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] | (Rd0811 != const1220S);
}

# OR.NOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:or.nor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc7 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local tmp = (Rd0811 >> const1620Z) & 1;
	local tmp2 = (Rd1215 >> const2327Z) & 1;
	local tmp3 = zext(Rd2831[0,1]);
	tmp3 = tmp3 | ~(tmp | tmp2);
	Rd2831[0,1] = tmp3[0,1];
}

# OR.OR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:or.or.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc7 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp = (Rd0811 >> const1620Z) & 1;
	local tmp2 = (Rd1215 >> const2327Z) & 1;
	local tmp3 = zext(Rd2831[0,1]);
	tmp3 = tmp3 | (tmp | tmp2);
	Rd2831[0,1] = tmp3[0,1];
}

# OR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:or.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x87 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp = (Rd0811 >> const1620Z) & 1;
	local tmp2 = (Rd1215 >> const2327Z) & 1;
	Rd2831 = tmp | tmp2;
}

# ORN D[c], D[a], D[b] (RR)
:orn Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0xf0
{
	Rd2831 = Rd0811 | ~Rd1215;
}

# ORN D[c], D[a], const9 (RC)
:orn Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0xf ) & const1220Z
{
	Rd2831 = Rd0811 | ~const1220Z;
}

# ORN.T D[c], D[a], pos1, D[b], pos2 (BIT)
:orn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x7 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp2 = ((Rd1215 >> const2327Z) & 1) == 0;
	Rd2831 = zext(tmp | tmp2);
}

# PACK D[c], E[d], D[a] (RRR)
:pack Rd2831,Ree2427/Reo2427,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x6b & op1215=0x0 ; Rd2831 & Ree2427 & Reo2427 & op1623=0x0
{
	#TODO  o=exp e=mantissa D[a][31]=sign
	# int_exp = E[d][63:32];
	# int_mant = E[d][31:0];
	# flag_rnd = int_mant[7] AND (int_mant[8] OR int_mant[6:0] OR PSW.C);
	# if ((int_mant[31] == 0) AND (int_exp == +255)) then {
	# // Infinity or NaN
	# fp_exp = +255;
	# fp_frac = int_mant[30:8];
	# } else if ((int_mant[31] == 1) AND (int_exp >= +127)) then {
	# // Overflow ? Infinity.
	# fp_exp = +255;
	# fp_frac = 0;
	# } else if ((int_mant[31] == 1) AND (int_exp <= -128)) then {
	# // Underflow ? Zero
	# fp_exp = 0;
	# fp_frac = 0;
	# } else if (int_mant == 0) then {
	# // Zero
	# fp_exp = 0;
	# fp_frac = 0;
	# } else {
	# if (int_mant[31] == 0) then {
	# // Denormal
	# temp_exp = 0;
	# } else {
	# // Normal
	# temp_exp = int_exp + 128;
	# }
	# fp_exp_frac[30:0] = {tmp_exp[7:0], int_mant[30:8]} + flag_rnd;
	# fp_exp = fp_exp_frac[30:23];
	# fp_frac = fp_exp_frac[22:0];
	# }
	# D[c][31] = D[a][31];
	# D[c][30:23] = fp_exp;
	# D[c][22:0] = fp_frac;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# PARITY D[c], D[a] (RR)
:parity Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x20
{
	local result3:1 = Rd0811[24,1] ^ Rd0811[25,1] ^ Rd0811[26,1] ^ Rd0811[27,1] ^ Rd0811[28,1] ^ Rd0811[29,1] ^Rd0811[30,1] ^ Rd0811[31,1];
	local result2:1 = Rd0811[16,1] ^ Rd0811[17,1] ^ Rd0811[18,1] ^ Rd0811[19,1] ^ Rd0811[20,1] ^ Rd0811[21,1] ^Rd0811[22,1] ^ Rd0811[23,1];
	local result1:1 = Rd0811[8,1] ^ Rd0811[9,1] ^ Rd0811[10,1] ^ Rd0811[11,1] ^ Rd0811[12,1] ^ Rd0811[13,1] ^Rd0811[14,1] ^ Rd0811[15,1];
	local result0:1 = Rd0811[0,1] ^ Rd0811[1,1] ^ Rd0811[2,1] ^ Rd0811[3,1] ^ Rd0811[4,1] ^ Rd0811[5,1] ^ Rd0811[6,1] ^ Rd0811[7,1];
	Rd2831 = zext(result3 << 24) | zext(result2 << 16) | zext(result1 << 8) | zext(result0);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# Q31TOF D[c], D[a], D[b] (RR)
:q31tof Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x4b ; Rd2831 & op1627=0x151
{
	#TODO  float
	#TODO  flags
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# QSEED.F D[c], D[a] (RR)
:qseed.f Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x191
{
	#TODO  float
	#TODO  flags
	Rd2831 = 1 f/ sqrt(Rd0811);
}
@endif

@if defined(TRICORE_V2)
# RESTORE D[a] (SYS)
:restore Rd0811 is PCPMode=0 & Rd0811 & op0007=0xd & op1215=0x0 ; op1631=0x380
{
	$(ICR_IE) = Rd0811[0,1];
}
@endif

# RET (SR)
:ret  is PCPMode=0 & op0007=0x0 & op0815=0x90
{
	#TODO  ret
	# if (PSW.CDE) then if (cdc_decrement()) then trap(CDU);
	# if (PCXI[19:0] == 0) then trap(CSU);
	# if (PCXI.UL == 0) then trap(CTYP);
	# PC = {A[11] [31:1], 1b0};
	# EA = {PCXI.PCXS, 6'b0, PCXI.PCXO, 6'b0};
	# {new_PCXI, new_PSW, a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15} = M(EA, 16 * word);
	# M(EA, word) = FCX;
	# FCX[19:0] = PCXI[19:0];
	# PCXI = new_PCXI;
	# PSW = {new_PSW[31:26], PSW[25:24], new_PSW[23:0]};

	local tmp:4 = a11 & 0xFFFFFFFE;
	restoreCallerState(FCX, LCX, PCXI);
	return [tmp];
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# RET (SYS)
:ret  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x180
{
	#TODO  ret
	# if (PSW.CDE) then if (cdc_decrement()) then trap(CDU);
	# if (PCXI[19:0] == 0) then trap(CSU);
	# if (PCXI.UL == 0) then trap(CTYP);
	# PC = {A[11] [31:1], 1b0};
	# EA = {PCXI.PCXS, 6'b0, PCXI.PCXO, 6'b0};
	# {new_PCXI, new_PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15} = M(EA, 16 * word);
	# M(EA, word) = FCX;
	# FCX[19:0] = PCXI[19:0];
	# PCXI = new_PCXI;
	# PSW = {new_PSW[31:26], PSW[25:24], new_PSW[23:0]};

	local tmp:4 = a11 & 0xFFFFFFFE;
	restoreCallerState(FCX, LCX, PCXI);
	return [tmp];
}
@endif

# RFE (SR)
:rfe  is PCPMode=0 & op0007=0x0 & op0815=0x80
{
	#TODO  ret
	# if (PCXI[19:0] == 0) then trap(CSU);
	# if (PCXI.UL == 0) then trap(CTYP);
	# if (!cdc_zero() AND PSW.CDE) then trap(NEST);
	# PC = {A[11] [31:1], 1b0};
	# ICR.IE = PCXI.PIE;
	# ICR.CCPN = PCXI.PCPN;
	# EA = {PCXI.PCXS, 6'b0, PCXI.PCXO, 6'b0};
	# {new_PCXI,PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15}=M(EA,16*word);
	# M(EA, word) = FCX;
	# FCX[19:0] = PCXI[19:0];
	# PCXI = new_PCXI;

	local tmp:4 = a11 & 0xFFFFFFFE;
	restoreCallerState(FCX, LCX, PCXI);
	return [tmp];
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# RFE (SYS)
:rfe  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x1c0
{
	#TODO  ret
	# if (PCXI[19:0] == 0) then trap(CSU);
	# if (PCXI.UL == 0) then trap(CTYP);
	# if (!cdc_zero() AND PSW.CDE) then trap(NEST);
	# PC = {A[11] [31:1], 1b0};
	# ICR.IE = PCXI.PIE;
	# ICR.CCPN = PCXI.PCPN;
	# EA = {PCXI.PCXS, 6'b0, PCXI.PCXO, 6'b0};
	# {new_PCXI,PSW,a10,a11,d8,d9,d10,d11,a12,a13,a14,a15,d12,d13,d14,d15}=M(EA,16*word);
	# M(EA, word) = FCX;
	# FCX[19:0] = PCXI[19:0];
	# PCXI = new_PCXI;

	local tmp:4 = a11 & 0xFFFFFFFE;
	restoreCallerState(FCX, LCX, PCXI);
	return [tmp];
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# RFM (SYS)
:rfm  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x140
{
	#TODO  ret
	# if (PSW.IO != 2b10) then trap (PRIV);
	# if (DBGSR.DE) then{
	# PC = {A[11] [31:1], 1b0};
	# ICR.IE = PCXI.IE;
	# ICR.CCPN = PCXI.PCPN;
	# EA = DCX;
	# {PCXI, PSW, A[10], A[11]} = M(EA, 4 * word);
	# DBGTCR.DTA = 0;
	# }else{
	# NOP
	# }

	local tmp:4 = a11 & 0xFFFFFFFE;
	restoreCallerState(FCX, LCX, PCXI);
	return [tmp];
}
@endif

# RSLCX (SYS)
:rslcx  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x240
{
	#TODO  context
	# if(PCXI[19:0] == 0) then trap(CSU);
	# if(PCXI.UL == 1) then trap(CTYP);
	# EA = {PCXI.PCXS, 6'b0, PCXI.PCXO, 6'b0};
	# {new_PCXI, A[11], A[2], A[3], D[0], D[1], D[2], D[3], A[4], A[5], A[6], A[7], D[4], D[5], D[6], D[7]} = M(EA, 16*word);
	# M(EA, word) = FCX;
	# FCX[19:0] = PCXI[19:0];
	# PCXI = new_PCXI;
}

# RSTV (SYS)
:rstv  is PCPMode=0 & op0007=0x2f & op0815=0x0 ; op1631=0x0
{
      $(PSW_V) = 0;
      $(PSW_SV) = 0;
      $(PSW_AV) = 0;
      $(PSW_SAV) = 0;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# RSUB D[a] (SR)
:rsub Rd0811 is PCPMode=0 & Rd0811 & op0007=0x32 & op1215=0x5
{
	Rd0811 = 0 - Rd0811;
	overflowflags(Rd0811);
}
@endif

# RSUB D[c], D[a], const9 (RC)
:rsub Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x8 ) & const1220S
{
	Rd2831 = const1220S - Rd0811;
	overflowflags(Rd2831);
}

# RSUBS D[c], D[a], const9 (RC)
:rsubs Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0xa ) & const1220S
{
	local result:4 = const1220S - Rd0811;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# RSUBS.U D[c], D[a], const9 (RC)
:rsubs.u Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0xb ) & const1220S
{
	local result:4 = const1220S - Rd0811;
	overflowflags(result);
	suov(Rd2831, result, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SAT.B D[a] (SR)
:sat.b Rd0811 is PCPMode=0 & Rd0811 & op0007=0x32 & op1215=0x0
{
	local sat_neg:4;
	ternary(sat_neg, Rd0811 s< -0x80, -0x80, Rd0811);
	ternary(Rd0811, sat_neg s> 0x7f, 0x7f, sat_neg);
}
@endif

# SAT.B D[c], D[a] (RR)
:sat.b Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xb & op1215=0x0 ; Rd2831 & op1627=0x5e0
{
	local sat_neg:4;
	ternary(sat_neg, Rd0811 s< -0x80, -0x80, Rd0811);
	ternary(Rd2831, sat_neg s> 0x7f, 0x7f, sat_neg);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SAT.BU D[a] (SR)
:sat.bu Rd0811 is PCPMode=0 & Rd0811 & op0007=0x32 & op1215=0x1
{
	ternary(Rd0811, Rd0811 > 0xff, 0xff, Rd0811);
}
@endif

# SAT.BU D[c], D[a] (RR)
:sat.bu Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xb & op1215=0x0 ; Rd2831 & op1627=0x5f0
{
	ternary(Rd2831, Rd0811 > 0xff, 0xff, Rd0811);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SAT.H D[a] (SR)
:sat.h Rd0811 is PCPMode=0 & Rd0811 & op0007=0x32 & op1215=0x2
{
	local sat_neg:4;
	ternary(sat_neg, Rd0811 s< -0x8000, -0x8000, Rd0811);
	ternary(Rd0811, sat_neg s> 0x7fff, 0x7fff, sat_neg);
}
@endif

# SAT.H D[c], D[a] (RR)
:sat.h Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xb & op1215=0x0 ; Rd2831 & op1627=0x7e0
{
	local sat_neg:4;
	ternary(sat_neg, Rd0811 s< -0x8000, -0x8000, Rd0811);
	ternary(Rd2831, sat_neg s> 0x7fff, 0x7fff, sat_neg);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SAT.HU D[a] (SR)
:sat.hu Rd0811 is PCPMode=0 & Rd0811 & op0007=0x32 & op1215=0x3
{
	ternary(Rd0811, Rd0811 > 0xffff, 0xffff, Rd0811);
}
@endif

# SAT.HU D[c], D[a] (RR)
:sat.hu Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xb & op1215=0x0 ; Rd2831 & op1627=0x7f0
{
	ternary(Rd2831, Rd0811 > 0xffff, 0xffff, Rd0811);
}

# SEL D[c], D[d], D[a], D[b] (RRR)
:sel Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2b ; Rd2427 & Rd2831 & op1623=0x40
{
	ternary(Rd2831, Rd2427 != 0, Rd0811, Rd1215);
}

# SEL D[c], D[d], D[a], const9 (RCR)
:sel Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0xab ; Rd2427 & Rd2831 & op2123=0x4 ) & const1220S
{
	ternary(Rd2831, Rd2427 != 0, Rd0811, const1220S);
}

# SELN D[c], D[d], D[a], D[b] (RRR)
:seln Rd2831,Rd2427,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x2b ; Rd2427 & Rd2831 & op1623=0x50
{
	ternary(Rd2831, Rd2427 == 0, Rd0811, Rd1215);
}

# SELN D[c], D[d], D[a], const9 (RCR)
:seln Rd2831,Rd2427,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0xab ; Rd2427 & Rd2831 & op2123=0x5 ) & const1220S
{
	ternary(Rd2831, Rd2427 == 0, Rd0811, const1220S);
}


@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SH D[a], const4 (SRC)
:sh Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & op0007=0x6 & op1515=1
{
	local tmp = -const1215S;
	Rd0811 = Rd0811 >> tmp;
}

# SH D[a], const4 (SRC)
:sh Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & op0007=0x6 & op1515=0
{
	Rd0811 = Rd0811 << const1215S;
}
@endif

# SH D[c], D[a], D[b] (RR)
:sh Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x0
{
	local shift_count:4 = sext(Rd1215[0,6]);
	shift_count = (shift_count << (32 - 6)) s>> (32 - 6);
	ternary(Rd2831, shift_count s>= 0, Rd0811 << shift_count, Rd0811 >> -shift_count);
}

# SHD[c], D[a], const9 (RC)
:sh Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x0 & op2020=1) & const1220S
{
	local tmp = -const1220S;
	Rd2831 = Rd0811 >> tmp[0,6];
}

# SHD[c], D[a], const9 (RC)
:sh Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x0 & op2020=0 ) & const1220S
{
	Rd2831 = Rd0811 << const1220S[0,6];
}

# SH.AND.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.and.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x27 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local pos1 = (Rd0811 >> const1620Z) & 1;
	local pos2 = (Rd1215 >> const2327Z) & 1;
	local tmp = pos1 & pos2;
	Rd2831 = (Rd2831 << 1) | zext(tmp[0,1]);
}

# SH.ANDN.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.andn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x27 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local pos1 = (Rd0811 >> const1620Z) & 1;
	local pos2 = (Rd1215 >> const2327Z) & 1;
	local tmp = pos1 & ~pos2;
	Rd2831 = (Rd2831 << 1) | zext(tmp[0,1]);
}

# SH.EQ D[c], D[a], D[b] (RR)
:sh.eq Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x370
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 == Rd1215);
}

# SH.EQ D[c], D[a], const9 (RC)
:sh.eq Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x37 ) & const1220S
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 == const1220S);
}

# SH.GE D[c], D[a], D[b] (RR)
:sh.ge Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x3b0
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 s>= Rd1215);
}

# SH.GE D[c], D[a], const9 (RC)
:sh.ge Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x3b ) & const1220S
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 s>= const1220S);
}

# SH.GE.U D[c], D[a], D[b] (RR)
:sh.ge.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x3c0
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 >= Rd1215);
}

# SH.GE.U D[c], D[a], const9 (RC)
:sh.ge.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x3c ) & const1220Z
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 >= const1220Z);
}

# SH.H D[c], D[a], D[b] (RR)
:sh.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x400
{
	local res1:2;
	local res0:2;
	local shift_count:4 = sext(Rd1215[0,5]);
	shift_count = (shift_count << (16 - 5)) s>> (16 - 5);
	ternary(res1, (shift_count s>= 0), Rd0811[16,16] << shift_count, Rd0811[16,16] >> -shift_count);
	ternary(res0, (shift_count s>= 0), Rd0811[0,16] << shift_count, Rd0811[0,16] >> -shift_count);
	Rd2831 = zext(res1 << 16) | zext(res0);
}

# SH.H D[c], D[a], const9 (RC)
:sh.h Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x40 ) & const1220S
{
	local res1:2;
	local res0:2;
	local shift_count = sext(const1220S[0,5]);
	shift_count = (shift_count << (16 - 5)) s>> (16 - 5);
	ternary(res1, (shift_count s>= 0), Rd0811[16,16] << shift_count, Rd0811[16,16] >> -shift_count);
	ternary(res0, (shift_count s>= 0), Rd0811[0,16] << shift_count, Rd0811[0,16] >> -shift_count);
	Rd2831 = zext(res1 << 16) | zext(res0);
}

# SH.LT D[c], D[a], D[b] (RR)
:sh.lt Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x390
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 s< Rd1215);
}

# SH.LT D[c], D[a], const9 (RC)
:sh.lt Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x39 ) & const1220S
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 s< const1220S);
}

# SH.LT.U D[c], D[a], D[b] (RR)
:sh.lt.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x3a0
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 < Rd1215);
}

# SH.LT.U D[c], D[a], const9 (RC)
:sh.lt.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x3a ) & const1220Z
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 < const1220Z);
}

# SH.NAND.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.nand.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa7 ; Rd2831 & const1620Z & const2327Z & op2122=0x0
{
	local tmp1 = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp0 = ((Rd1215 >> const2327Z) & 1) == 1;
	local res = !(tmp1 && tmp0);
	Rd2831 = (Rd2831 << 1) | zext(res);
}

# SH.NE D[c], D[a], D[b] (RR)
:sh.ne Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x380
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 != Rd1215);
}

# SH.NE D[c], D[a], const9 (RC)
:sh.ne Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x38 ) & const1220S
{
	Rd2831 = (Rd2831 << 1) | zext(Rd0811 != const1220S);
}

# SH.NOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.nor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x27 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local tmp1 = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp0 = ((Rd1215 >> const2327Z) & 1) == 1;
	local res = !(tmp1 || tmp0);
	Rd2831 = (Rd2831 << 1) | zext(res);
}

# SH.OR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.or.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x27 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp1 = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp0 = ((Rd1215 >> const2327Z) & 1) == 1;
	local res = tmp1 || tmp0;
	Rd2831 = (Rd2831 << 1) | zext(res);
}

# SH.ORN.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.orn.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa7 ; Rd2831 & const1620Z & const2327Z & op2122=0x1
{
	local tmp1 = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp0 = ((Rd1215 >> const2327Z) & 1) == 1;
	local res = tmp1 || !tmp0;
	Rd2831 = (Rd2831 << 1) | zext(res);
}

# SH.XNOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.xnor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa7 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local tmp1 = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp0 = ((Rd1215 >> const2327Z) & 1) == 1;
	local res = !(tmp1 ^ tmp0);
	Rd2831 = (Rd2831 << 1) | zext(res);
}

# SH.XOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:sh.xor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa7 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local tmp1 = ((Rd0811 >> const1620Z) & 1) == 1;
	local tmp0 = ((Rd1215 >> const2327Z) & 1) == 1;
	local res = tmp1 ^ tmp0;
	Rd2831 = (Rd2831 << 1) | zext(res);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SHA D[a], const4 (SRC)
:sha Rd0811,const1215S is PCPMode=0 & Rd0811 & const1215S & op0007=0x86
{
	local shift_count:4 = sext(const1215S[0,4]);
	shift_count = (shift_count << (32 - 4)) s>> (32 - 4);
	local res:4 = Rd0811;
	local shift_dir:1 = shift_count s< 0;
	res = (Rd0811 << shift_count) * zext(shift_dir == 0) | (Rd0811 s>> (-shift_count)) * zext(shift_dir == 1);
	overflowflags(res);
	Rd0811 = res;
}
@endif

# SHA D[c], D[a], D[b] (RR)
:sha Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x10
{
	local shift_count:4 = sext(Rd1215[0,6]);
	shift_count = (shift_count << (32 - 6)) s>> (32 - 6);
	local res:4 = Rd0811;
	local shift_dir:1 = shift_count s< 0;
	res = (Rd0811 << shift_count) * zext(shift_dir == 0) | (Rd0811 s>> (-shift_count)) * zext(shift_dir == 1);
	overflowflags(res);
	Rd2831 = res;
}

# SHA D[c], D[a], const9 (RC)
:sha Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x1 ) & const1220S
{
	local shift_count:4 = sext(const1220S[0,6]);
	shift_count = (shift_count << (32 - 6)) s>> (32 - 6);
	local res:4 = Rd0811;
	local shift_dir:1 = shift_count s< 0;
	res = (Rd0811 << shift_count) * zext(shift_dir == 0) | (Rd0811 s>> (-shift_count)) * zext(shift_dir == 1);
	overflowflags(res);
	Rd2831 = res;
}

# SHA.H D[c], D[a], D[b] (RR)
:sha.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x410
{
	local shift_count:4 = sext(Rd1215[0,5]);
	local res1:4 = sext(Rd0811[16,16]);
	local res0:4 = sext(Rd0811[0,16]);
	if (shift_count s> 0) goto <shift_left>;
	if (shift_count == 0) goto <shift_exit>;
	shift_count = 0 - shift_count;
	local msk:4;
	ternary(msk, Rd0811[31,1] != 0, (((1 << shift_count) - 1) << (16 - shift_count)), 0);
	res1 = msk | sext(Rd0811[16,16] s>> shift_count);
	res0 = msk | sext(Rd0811[0,16] s>> shift_count);
	goto <shift_exit>;
    <shift_left>
	res1 = sext(Rd0811[16,16] << shift_count);
	res0 = sext(Rd0811[0,16] << shift_count);
    <shift_exit>
	Rd2831 = zext(res1[0,16] << 16) | zext(res0[0,16]);
}

# SHA.H D[c], D[a], const9 (RC)
:sha.h Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x41 ) & const1220S
{
	local shift_count:4 = sext(const1220S[0,5]);
	local res1:4 = sext(Rd0811[16,16]);
	local res0:4 = sext(Rd0811[0,16]);
	if (shift_count s> 0) goto <shift_left>;
	if (shift_count == 0) goto <shift_exit>;
	shift_count = 0 - shift_count;
	local msk:4;
	ternary(msk, Rd0811[31,1] != 0, (((1 << shift_count) - 1) << (16 - shift_count)), 0);
	res1 = msk | sext(Rd0811[16,16] s>> shift_count);
	res0 = msk | sext(Rd0811[0,16] s>> shift_count);
	goto <shift_exit>;
    <shift_left>
	res1 = sext(Rd0811[16,16] << shift_count);
	res0 = sext(Rd0811[0,16] << shift_count);
    <shift_exit>
	Rd2831 = (zext(res1[0,16]) << 16) | zext(res0[0,16]);
}

# SHAS D[c], D[a], D[b] (RR)
:shas Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0x20
{
	local shift_count:4 = sext(Rd1215[0,6]);
	shift_count = (shift_count << (32 - 6)) s>> (32 - 6);
	local res:4 = Rd0811;
	local shift_dir:1 = shift_count s< 0;
	res = (Rd0811 << shift_count) * zext(shift_dir == 0) | (Rd0811 s>> (-shift_count)) * zext(shift_dir == 1);
	overflowflags(res);
	ssov(Rd2831, res, 32);
}

# SHAS D[c], D[a], const9 (RC)
:shas Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0x2 ) & const1220S
{
	local shift_count:4 = sext(const1220S[0,6]);
	shift_count = (shift_count << (32 - 6)) s>> (32 - 6);
	local res:4 = Rd0811;
	local shift_dir:1 = shift_count s< 0;
	res = (Rd0811 << shift_count) * zext(shift_dir == 0) | (Rd0811 s>> (-shift_count)) * zext(shift_dir == 1);
	overflowflags(res);
	ssov(Rd2831, res, 32);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.A A[10], const8, A[15] (SC)
:st.a SC,a15 is PCPMode=0 & a15 & op0007=0xf8 & SC
{
	build SC;
	*[ram]:4 SC = a15;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.A A[b], off4, A[15] (SRO)
:st.a SRO,a15 is PCPMode=0 & a15 & op0007=0xec & SRO
{
	build SRO;
	*[ram]:4 SRO = a15;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.A A[15], off4, A[a] (SSRO)
:st.a SSRO,Ra0811 is PCPMode=0 & Ra0811 & op0007=0xe8 & SSRO
{
	build SSRO;
	*[ram]:4 SSRO = Ra0811;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.A A[b], A[a] (SSR)(Post-increment Addressing Mode)
# ST.A A[b], A[a] (SSR)
:st.a SSR,Ra0811 is PCPMode=0 & Ra0811 & op0607=0x3 & SSR
{
	build SSR;
	*[ram]:4 SSR = Ra0811;
}

# ST.A A[b], off10, A[a] (BO)(Post-increment Addressing Mode)
# ST.A P[b], A[a] (BO)(Bit-reverse Addressing Mode)
# ST.A A[b], off10, A[a] (BO)(Pre-increment Addressing Mode)
# ST.A A[b], off10, A[a] (BO)(Base + Short Offset Addressing Mode)
# ST.A P[b], A[a] (BO)(Index Addressing Mode)
:st.a BO,Ra0811 is PCPMode=0 & ( Ra0811 & op0607=0x2 ; op2225=0x6 ) & BO
{
	build BO;
	*[ram]:4 BO = Ra0811;
}

# ST.A P[b], off10, A[a] (BO)(Circular Addressing Mode)
#:st.a BO,Ra0811 is PCPMode=0 & ( Ra0811 & op0007=0xa9 ; op2227=0x16 ) & BO
:st.a [Rpe1215/Rpo1215^"+c"^]off10,Ra0811 is PCPMode=0 & Ra0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x16
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	*[ram]:4 EA = Ra0811;
}

# ST.A off18, A[a] (ABS)(Absolute Addressing Mode)
:st.a off18,Ra0811 is PCPMode=0 & ( Ra0811 & op0007=0xa5 ; op2627=0x2 ) & off18
{
	*[ram]:4 off18 = Ra0811;
}

# ST.A A[b], off16, A[a] (BOL)(Base + Long Offset Addressing Mode)
:st.a BOL,Ra0811 is PCPMode=0 & ( Ra0811 & op0007=0xb5 ) ... & BOL
{
	build BOL;
	*[ram]:4 BOL = Ra0811;
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.B A[b], D[a] (SSR)
# ST.B A[b], D[a] (SSR)(Post-increment Addressing Mode)
:st.b SSR,Rd0811 is PCPMode=0 & Rd0811 & op0607=0x0 & SSR
{
	build SSR;
	*[ram]:1 SSR = Rd0811[0,8];
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.B A[15], off4, D[a] (SSRO)
:st.b SSRO,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x28 & SSRO
{
	build SSRO;
	*[ram]:1 SSRO = Rd0811[0,8];
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.B A[b], off4, D[15] (SRO)
:st.b SRO,d15 is PCPMode=0 & d15 & op0007=0x2c & SRO
{
	build SRO;
	*[ram]:1 SRO = d15[0,8];
}
@endif

# ST.B off18, D[a] (ABS)(Absolute Addressing Mode)
:st.b off18,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0x25 ; op2627=0x0 ) & off18
{
	*[ram]:1 off18 = Rd0811[0,8];
}

# ST.B A[b], off16, D[a] (BOL)(Base + Long Offset Addressing Mode)
:st.b BOL,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xe9 ) ... & BOL
{
	build BOL;
	*[ram]:1 BOL = Rd0811[0,8];
}

# ST.B A[b], off10, D[a] (BO)(Post-increment Addressing Mode)
# ST.B P[b], D[a] (BO)(Bit-reverse Addressing Mode)
# ST.B A[b], off10, D[a] (BO)(Pre-increment Addressing Mode)
# ST.B A[b], off10, D[a] (BO)(Base + Short Offset Addressing Mode)
# ST.B P[b], D[a] (BO)(Index Addressing Mode)
:st.b BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0607=0x2 ; op2225=0x0 ) & BO
{
	build BO;
	*[ram]:1 BO = Rd0811[0,8];
}

# ST.B P[b], off10, D[a] (BO)(Circular Addressing Mode)
#:st.b BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xa9 ; op2227=0x10 ) & BO
:st.b [Rpe1215/Rpo1215^"+c"^]off10,Rd0811 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x10
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	*[ram]:1 EA = Rd0811[0,8];
}

# ST.D A[b], off10, E[a] (BO)(Post-increment Addressing Mode)
# ST.D P[b], E[a] (BO)(Bit-reverse Addressing Mode)
# ST.D A[b], off10, E[a] (BO)(Pre-increment Addressing Mode)
# ST.D A[b], off10, E[a] (BO)(Base + Short Offset Addressing Mode)
# ST.D P[b], E[a] (BO)(Index Addressing Mode)
:st.d BO,Re0811 is PCPMode=0 & ( Re0811 & op0607=0x2 ; op2225=0x5 ) & BO
{
	build BO;
	*[ram]:8 BO = Re0811;
}

# ST.D off18, E[a] (ABS)(Absolute Addressing Mode)
:st.d off18,Re0811 is PCPMode=0 & ( Re0811 & op0007=0xa5 ; op2627=0x1 ) & off18
{
	*[ram]:8 off18 = Re0811;
}

# ST.D P[b], off10, E[a] (BO)(Circular Addressing Mode)
#:st.d BO,Re0811 is PCPMode=0 & ( Re0811 & op0007=0xa9 ; op2227=0x15 ) & BO
:st.d [Rpe1215/Rpo1215^"+c"^]off10,Re0811 is PCPMode=0 & Re0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x15
{
	local EA0:4;
	local EA2:4;
	local EA4:4;
	local EA6:4;
	CircularAddressingMode4(Rpe1215, Rpo1215, EA0, EA2, EA4, EA6, off10, 2);
	*[ram]:2 EA6 = Re0811[48,16];
	*[ram]:2 EA4 = Re0811[32,16];
	*[ram]:2 EA2 = Re0811[16,16];
	*[ram]:2 EA0 = Re0811[0,16];
}

# ST.DA A[b], off10, P[a] (BO)(Post-increment Addressing Mode)
# ST.DA P[b], P[a] (BO)(Bit-reverse Addressing Mode)
# ST.DA A[b], off10, P[a] (BO)(Pre-increment Addressing Mode)
# ST.DA A[b], off10, P[a] (BO)(Base + Short Offset Addressing Mode)
# ST.DA P[b], P[a] (BO)(Index Addressing Mode)
:st.da BO,Rp0811 is PCPMode=0 & ( Rp0811 & op0607=0x2 ; op2225=0x7 ) & BO
{
	build BO;
	*[ram]:8 BO = Rp0811;
}

# ST.DA P[b], off10, P[a] (BO)(Circular Addressing Mode)
#:st.da BO,Rp0811 is PCPMode=0 & ( Rp0811 & op0007=0xa9 ; op2227=0x17 ) & BO
:st.da [Rpe1215/Rpo1215^"+c"^]off10,Rp0811 is PCPMode=0 & Rp0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x17
{
	local EA0:4;
	local EA4:4;
	CircularAddressingMode2(Rpe1215, Rpo1215, EA0, EA4, off10, 4);
	*[ram]:2 EA0 = Rp0811[0,32];
	*[ram]:2 EA4 = Rp0811[32,32];
}

# ST.DA off18, P[a] (ABS)(Absolute Addressing Mode)
:st.da off18,Rp0811 is PCPMode=0 & ( Rp0811 & op0007=0xa5 ; op2627=0x3 ) & off18
{
	*[ram]:8 off18 = Rp0811;
}

@if defined(TRICORE_V2)
:st.dd BO,Re0811/ReN0811 is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x89 ; op2227=0x9 ) & BO
{
	build BO;
	*[ram]:8 BO = Re0811;
	*[ram]:8 BO+8 = ReN0811;
}
@endif

@if defined(TRICORE_V2)
:st.dd BO,Re0811/ReN0811 is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0xa9 ; op1621=0x0 & op2227=0x09 & op2831=0x0 ) & BO
{
	build BO;
	*[ram]:8 BO = Re0811;
	*[ram]:8 BO+8 = ReN0811;
}
@endif

@if defined(TRICORE_V2)
:st.dd BO,Re0811/ReN0811 is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x89 ; op2227=0x19 ) & BO
{
	build BO;
	*[ram]:8 BO = Re0811;
	*[ram]:8 BO+8 = ReN0811;
}
@endif

@if defined(TRICORE_V2)
#:st.dd BO,Re0811/ReN0811 is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0xa9 ; op2227=0x19 ) & BO
:st.dd [Rpe1215/Rpo1215^"+c"^]off10,Re0811/ReN0811 is PCPMode=0 & Re0811 & ReN0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x19
{
	local EA0:4;
	local EA8:4;
	CircularAddressingMode2(Rpe1215, Rpo1215, EA0, EA8, off10, 8);
	*[ram]:8 EA0 = Re0811;
	*[ram]:8 EA8 = ReN0811;
}
@endif

@if defined(TRICORE_V2)
:st.dd BO,Re0811/ReN0811 is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0x89 ; op2227=0x29 ) & BO
{
	build BO;
	*[ram]:8 BO = Re0811;
	*[ram]:8 BO+8 = ReN0811;
}
@endif

@if defined(TRICORE_V2)
:st.dd BO,Re0811/ReN0811 is PCPMode=0 & ( Re0811 & ReN0811 & op0007=0xa9 ; op1621=0x0 & op2227=0x29 & op2831=0x0 ) & BO
{
	build BO;
	*[ram]:8 BO = Re0811;
	*[ram]:8 BO+8 = ReN0811;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.H A[b], D[a] (SSR)(Post-increment Addressing Mode)
# ST.H A[b], D[a] (SSR)
:st.h SSR,Rd0811 is PCPMode=0 & Rd0811 & op0607=0x2 & SSR
{
	build SSR;
	*[ram]:2 SSR = Rd0811[0,16];
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.H A[15], off4, D[a] (SSRO)
:st.h SSRO,Rd0811 is PCPMode=0 & Rd0811 & op0007=0xa8 & SSRO
{
	build SSRO;
	*[ram]:2 SSRO = Rd0811[0,16];
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.H A[b], off4, D[15] (SRO)
:st.h SRO,d15 is PCPMode=0 & d15 & op0007=0xac & SRO
{
	build SRO;
	*[ram]:2 SRO = d15[0,16];
}
@endif

# ST.H A[b], off10, D[a] (BO)(Post-increment Addressing Mode)
# ST.H P[b], D[a] (BO)(Bit-reverse Addressing Mode)
# ST.H A[b], off10, D[a] (BO)(Pre-increment Addressing Mode)
# ST.H A[b], off10, D[a] (BO)(Base + Short Offset Addressing Mode)
# ST.H P[b], D[a] (BO)(Index Addressing Mode)
:st.h BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0607=0x2 ; op2225=0x2 ) & BO
{
	build BO;
	*[ram]:2 BO = Rd0811[0,16];
}

# ST.H A[b], off16, D[a] (BOL)(Base + Long Offset Addressing Mode)
:st.h BOL,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xf9 ) ... & BOL
{
	build BOL;
	*[ram]:2 BOL = Rd0811[0,16];
}

# ST.H P[b], off10, D[a] (BO)(Circular Addressing Mode)
#:st.h BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xa9 ; op2227=0x12 ) & BO
:st.h [Rpe1215/Rpo1215^"+c"^]off10,Rd0811 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x12
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	*[ram]:2 EA = Rd0811[0,16];
}

# ST.H off18, D[a] (ABS)(Absolute Addressing Mode)
:st.h off18,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0x25 ; op2627=0x2 ) & off18
{
	*[ram]:2 off18 = Rd0811[0,16];
}

# ST.Q off18, D[a] (ABS)(Absolute Addressing Mode)
:st.q off18,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0x65 ; op2627=0x0 ) & off18
{
	*[ram]:2 off18 = Rd0811[16,16];
}

# ST.Q A[b], off10, D[a] (BO)(Post-increment Addressing Mode)
# ST.Q P[b], D[a] (BO)(Bit-reverse Addressing Mode)
# ST.Q A[b], off10, D[a] (BO)(Pre-increment Addressing Mode)
# ST.Q A[b], off10, D[a] (BO)(Base + Short Offset Addressing Mode)
# ST.Q P[b], D[a] (BO)(Index Addressing Mode)
:st.q BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0607=0x2 ; op2225=0x8 ) & BO
{
	build BO;
	*[ram]:2 BO = Rd0811[16,16];
}

#:st.q BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xa9 ; op2227=0x18 ) & BO
:st.q [Rpe1215/Rpo1215^"+c"^]off10,Rd0811 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x18
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	*[ram]:2 EA = Rd0811[16,16];
}

# ST.T off18, bpos3, b (ABSB)
:st.t off18,const0810Z,const1111Z is PCPMode=0 & ( const0810Z & const1111Z & op0007=0xd5 ; op2627=0x0 ) & off18
{
	local tmp:4 = 1 << const0810Z;
	tmp = tmp | (const1111Z << const0810Z);
	*[ram]:1 off18 = *[ram]:1 off18 & ~tmp[0,8];
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.W A[10], const8, D[15] (SC)
:st.w SC,d15 is PCPMode=0 & d15 & op0007=0x78 & SC
{
	build SC;
	*[ram]:4 SC = d15;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.W A[b], D[a] (SSR)
# ST.W A[b], D[a] (SSR)(Post-increment Addressing Mode)
:st.w SSR,Rd0811 is PCPMode=0 & Rd0811 & op0607=0x1 & SSR
{
	build SSR;
	*[ram]:4 SSR = Rd0811;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.W A[15], off4, D[a] (SSRO)
:st.w SSRO,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x68 & SSRO
{
	build SSRO;
	*[ram]:4 SSRO = Rd0811;
}
@endif

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# ST.W A[b], off4, D[15] (SRO)
:st.w SRO,d15 is PCPMode=0 & d15 & op0007=0x6c & SRO
{
	build SRO;
	*[ram]:4 SRO = d15;
}
@endif

# ST.W A[b], off16, D[a] (BOL)(Base + Long Offset Addressing Mode)
:st.w BOL,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0x59 ) ... & BOL
{
	build BOL;
	*[ram]:4 BOL = Rd0811;
}

# ST.W off18, D[a] (ABS)(Absolute Addressing Mode)
:st.w off18,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xa5 ; op2627=0x0 ) & off18
{
	*[ram]:4 off18 = Rd0811;
}

# ST.W A[b], off10, D[a] (BO)(Post-increment Addressing Mode)
# ST.W P[b], D[a] (BO)(Bit-reverse Addressing Mode)
# ST.W A[b], off10, D[a] (BO)(Pre-increment Addressing Mode)
# ST.W A[b], off10, D[a] (BO)(Base + Short Offset Addressing Mode)
# ST.W P[b], D[a] (BO)(Index Addressing Mode)
:st.w BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0607=0x2 ; op2225=0x4 ) & BO
{
	build BO;
	*[ram]:4 BO = Rd0811;
}

# ST.W P[b], off10, D[a] (BO)(Circular Addressing Mode)
#:st.w BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xa9 ; op2227=0x14 ) & BO
:st.w [Rpe1215/Rpo1215^"+c"^]off10,Rd0811 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0xa9 ; off10 & op2227=0x14
{
	local EA0:4;
	local EA2:4;
	CircularAddressingMode2(Rpe1215, Rpo1215, EA0, EA2, off10, 2);
	*[ram]:2 EA2 = Rd0811[16,16];
	*[ram]:2 EA0 = Rd0811[0,16];
}

# STLCX off18 (ABS)(Absolute Addressing Mode)
:stlcx off18 is PCPMode=0 & ( op0007=0x15 & op0811=0x0 ; op2627=0x0 ) & off18
{
	#TODO  context
	store_lower_context(off18);
}

# STLCX A[b], off10 (BO)(Base + Short Index Addressing Mode)
:stlcx BO is PCPMode=0 & ( op0007=0x49 & op0811=0x0 ; op2227=0x26 ) & BO
{
	#TODO  context
	build BO;
	store_lower_context(BO);
}

# STUCX off18 (ABS)(Absolute Addressing Mode)
:stucx off18 is PCPMode=0 & ( op0007=0x15 & op0811=0x0 ; op2627=0x1 ) & off18
{
	#TODO  context
	store_upper_context(off18);
}

# STUCX A[b], off10 (BO)(Base + Short Index Addressing Mode)
:stucx BO is PCPMode=0 & ( op0007=0x49 & op0811=0x0 ; op2227=0x27 ) & BO
{
	#TODO  context
	build BO;
	store_upper_context(BO);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SUB D[a], D[15], D[b] (SRR)
:sub Rd0811,d15,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x52
{
	Rd0811 = d15 - Rd1215;
	overflowflags(Rd0811);
}
@endif

# SUB D[15], D[a], D[b] (SRR)
:sub d15,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & d15 & op0007=0x5a
{
	d15 = Rd0811 - Rd1215;
	overflowflags(d15);
}

# SUB D[a], D[b] (SRR)
:sub Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xa2
{
	Rd0811 = Rd0811 - Rd1215;
	overflowflags(Rd0811);
}

# SUB D[c], D[a], D[b] (RR)
:sub Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x80
{
	Rd2831 = Rd0811 - Rd1215;
	overflowflags(Rd2831);
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SUB.A A[10], const8 (SC)
:sub.a a10,const0815Z is PCPMode=0 & a10 & const0815Z & op0007=0x20
{
	a10 = a10 - const0815Z;
}
@endif

# SUB.A A[c], A[a], A[b] (RR)
:sub.a Ra2831,Ra0811,Ra1215 is PCPMode=0 & Ra0811 & Ra1215 & op0007=0x1 ; Ra2831 & op1627=0x20
{
	Ra2831 = Ra0811 - Ra1215;
}

# SUB.B D[c], D[a], D[b] (RR)
:sub.b Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x480
{
	local result3:4 = zext(Rd0811[24,8] - Rd1215[24,8]);
	local result2:4 = zext(Rd0811[16,8] - Rd1215[16,8]);
	local result1:4 = zext(Rd0811[8,8] - Rd1215[8,8]);
	local result0:4 = zext(Rd0811[0,8] - Rd1215[0,8]);
	overflowflagsb(result3, result2, result1, result0);
	Rd2831 = zext(result3[0,8] << 24) | zext(result2[0,8] << 16) | zext(result1[0,8] << 8) | zext(result0[0,8]);
}

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# SUB.F D[c], D[d], D[a] (RRR)
:sub.f Rd2831,Rd2427,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x6b & op1215=0x0 ; Rd2427 & Rd2831 & op1623=0x31
{
	#TODO  float
	#TODO  flags
	Rd2831 = Rd2427 f- Rd0811;
}
@endif

# SUB.H D[c], D[a], D[b] (RR)
:sub.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x680
{
	local result1:4 = zext(Rd0811[16,16] - Rd1215[16,16]);
	local result0:4 = zext(Rd0811[0,16] - Rd1215[0,16]);
	overflowflagsh(result1, result0);
	Rd2831 = (zext(result1[0,16]) << 16) | zext(result0[0,16]);
}

# SUBC D[c], D[a], D[b] (RR)
:subc Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0xd0
{
	local tmp:5 = zext(Rd0811) - zext(Rd1215) + zext($(PSW_C)) - 1;
	Rd2831 = tmp[0,32];
	$(PSW_C) = tmp[32,1];
	overflowflags(Rd2831);
}

# SUBS D[a], D[b] (SRR)
:subs Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x62
{
	local result:4 = Rd0811 - Rd1215;
	overflowflags(result);
	ssov(Rd0811, result, 32);
}

# SUBS D[c], D[a], D[b] (RR)
:subs Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0xa0
{
	local result:4 = Rd0811 - Rd1215;
	overflowflags(result);
	ssov(Rd2831, result, 32);
}

# SUBS.H D[c], D[a], D[b] (RR)
:subs.h Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x6a0
{
	local result1:4 = zext(Rd0811[16,16] - Rd1215[16,16]);
	local result0:4 = zext(Rd0811[0,16] - Rd1215[0,16]);
	overflowflagsh(result1, result0);
	ssov(Rd2831[16,16], result1[0,16], 16);
	ssov(Rd2831[0,16], result0[0,16], 16);
}

# SUBS.HU D[c], D[a], D[b] (RR)
:subs.hu Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x6b0
{
	local result1:4 = zext(Rd0811[16,16] - Rd1215[16,16]);
	local result0:4 = zext(Rd0811[0,16] - Rd1215[0,16]);
	overflowflagsh(result1, result0);
	suov(Rd2831[16,16], result1[0,16], 16);
	suov(Rd2831[0,16], result0[0,16], 16);
}

# SUBS.U D[c], D[a], D[b] (RR)
:subs.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0xb0
{
	local result:4 = Rd0811 - Rd1215;
	overflowflags(result);
	suov(Rd2831, result, 32);
}

# SUBX D[c], D[a], D[b] (RR)
:subx Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0xc0
{
	Rd2831 = Rd0811 - Rd1215;
	local tmp:5 = zext(Rd0811) + ~zext(Rd1215) + 1;
	$(PSW_C) = tmp[32,1];
	overflowflags(Rd2831);
}

# SVLCX (SYS)
:svlcx  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x200
{
	#TODO  context
	# if (FCX == 0) trap(FCU);
	# tmp_FCX = FCX;
	# EA = {FCX.FCXS, 6'b0, FCX.FCXO, 6'b0};
	# new_FCX = M(EA, word);
	# M(EA, 16 * word) = {PCXI, A[11], A[2], A[3], D[0], D[1], D[2], D[3], A[4], A[5], A[6], A[7], D[4], D[5], D[6], D[7]};
	# PCXI.PCPN = ICR.CCPN
	# PCXI.PIE = ICR.IE;
	# PCXI.UL = 0;
	# PCXI[19:0] = FCX[19:0];
	# FCX[19:0] = new_FCX[19:0];
	# if (tmp_FCX == LCX) trap(FCD);
}

# SWAP.W A[b], off10, D[a] (BO)(Base + Short Offset Addressing Mode)
# SWAP.W P[b], D[a] (BO)(Bit-reverse Addressing Mode)
# SWAP.W A[b], off10, D[a] (BO)(Pre-increment Addressing Mode)
# SWAP.W A[b], off10, D[a] (BO)(Base + Short Offset Addressing Mode)
# SWAP.W P[b], D[a] (BO)(Index Addressing Mode)
:swap.w BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0607=0x1 ; op2225=0x0 ) & BO
{
	build BO;
	local tmp:4 = *[ram]:4 BO;
	*[ram]:4 BO = Rd0811;
	Rd0811 = tmp;
}

# SWAP.W off18, D[a] (ABS)(Absolute Addressing Mode)
:swap.w off18,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0xe5 ; op2627=0x0 ) & off18
{
	local tmp:4 = *[ram]:4 off18;
	*[ram]:4 off18 = Rd0811;
	Rd0811 = tmp;
}

# SWAP.W P[b], off10, D[a] (BO)(Circular Addressing Mode)
#:swap.w BO,Rd0811 is PCPMode=0 & ( Rd0811 & op0007=0x69 ; op2227=0x10 ) & BO
:swap.w [Rpe1215/Rpo1215^"+c"^]off10,Rd0811 is PCPMode=0 & Rd0811 & Rpe1215 & Rpo1215 & op0007=0x69 ; off10 & op2227=0x10
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	local tmp:4 = *[ram]:4 EA;
	*[ram]:4 EA = Rd0811;
	Rd0811 = tmp;
}

@if defined(TRICORE_V2)
# SWAPMSK.W A[b], off10, E[a] (BO)(Post-increment Addressing Mode)
# SWAPMSK.W P[b], E[a] (BO)(Bit-reverse Addressing Mode)
# SWAPMSK.W A[b], off10, E[a] (BO)(Pre-increment Addressing Mode)
# SWAPMSK.W A[b], off10, E[a] (BO)(Base + Short Offset Addressing Mode)
# SWAPMSK.W P[b], E[a] (BO)(Index Addressing Mode)
:swapmsk.w BO,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0607=0x1 ; op2225=0x2 ) & BO
{
	build BO;
	local tmp:4 = *[ram]:4 BO;
	*[ram]:4 BO = (tmp & ~Reo0811) | (Ree0811 & Reo0811);
}

# SWAPMSK.W P[b], off10, E[a] (BO)(Circular Addressing Mode)
#:swapmsk.w BO,Ree0811/Reo0811 is PCPMode=0 & ( Ree0811 & Reo0811 & op0007=0x69 ; op2227=0x12 ) & BO
:swapmsk.w [Rpe1215/Rpo1215^"+c"^]off10,Ree0811/Reo0811 is PCPMode=0 & Ree0811 & Reo0811 & Rpe1215 & Rpo1215 & op0007=0x69 ; off10 & op2227=0x12
{
	local EA:4;
	CircularAddressingMode(Rpe1215, Rpo1215, EA, off10);
	local tmp:4 = *[ram]:4 EA;
	*[ram]:4 EA = (tmp & ~Reo0811) | (Ree0811 & Reo0811);
}
@endif

# SYSCALL const9 (RC)
:syscall const1220Z is PCPMode=0 & ( op0007=0xad & op0811=0x0 ; op2131=0x4 ) & const1220Z
{
	#TODO  TIN SYS
	trap(const1220Z[0,8]);
}

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:tlbdemap Rd0811 is PCPMode=0 & Rd0811 & op0007=0x75 & op1215=0x0 ; op1631=0x0
{
	tlbdemap(Rd0811);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:tlbflush.a  is PCPMode=0 & op0007=0x75 & op0815=0x0 ; op1631=0x40
{
	tlbflusha();
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:tlbflush.b  is PCPMode=0 & op0007=0x75 & op0815=0x0 ; op1631=0x50
{
	tlbflushb();
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:tlbmap Re0811 is PCPMode=0 & Re0811 & op0007=0x75 & op1215=0x0 ; op1631=0x400
{
	tlbmap(Re0811);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:tlbprobe.a Rd0811 is PCPMode=0 & Rd0811 & op0007=0x75 & op1215=0x0 ; op1631=0x80
{
	tlbprobea(Rd0811);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
:tlbprobe.i Rd0811 is PCPMode=0 & Rd0811 & op0007=0x75 & op1215=0x0 ; op1631=0x90
{
	tlbprobei(Rd0811);
}
@endif

# TRAPSV (SYS)
:trapsv  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x540
{
	#TODO  TIN SOVF
	if ($(PSW_SV) == 0) goto inst_next;
	trap();
}

# TRAPV (SYS)
:trapv  is PCPMode=0 & op0007=0xd & op0815=0x0 ; op1631=0x500
{
	#TODO  TIN OVF
	if ($(PSW_V) == 0) goto inst_next;
	trap();
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# UNPACK E[c], D[a] (RR)
:unpack Re2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Re2831 & op1627=0x80
{
	#TODO
	#TODO  float En+1 = exp and En = mantissa
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# UPDFL D[a] (RR)
:updfl Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; op1631=0xc1
{
	$(PSW_FS) = ($(PSW_FS) & ~Rd0811[15,1]) | (Rd0811[7,1] & Rd0811[15,1]);
	$(PSW_FI) = ($(PSW_FI) & ~Rd0811[14,1]) | (Rd0811[6,1] & Rd0811[14,1]);
	$(PSW_FV) = ($(PSW_FV) & ~Rd0811[13,1]) | (Rd0811[5,1] & Rd0811[13,1]);
	$(PSW_FZ) = ($(PSW_FZ) & ~Rd0811[12,1]) | (Rd0811[4,1] & Rd0811[12,1]);
	$(PSW_FU) = ($(PSW_FU) & ~Rd0811[11,1]) | (Rd0811[3,1] & Rd0811[11,1]);
	$(PSW_FX) = ($(PSW_FX) & ~Rd0811[10,1]) | (Rd0811[2,1] & Rd0811[10,1]);
	$(PSW_RM) = ($(PSW_RM) & ~Rd0811[8,2]) | (Rd0811[0,2] & Rd0811[8,2]);
}
@endif

@if defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# UTOF D[c], D[a] (RR)
:utof Rd2831,Rd0811 is PCPMode=0 & Rd0811 & op0007=0x4b & op1215=0x0 ; Rd2831 & op1627=0x161
{
	#TODO  float
	#TODO  flags
	#TODO  unsigned
	# Rd2831 = int2float(Rd0811);
}
@endif

@if defined(TRICORE_V2)
# WAIT (SYS)
:wait  is PCPMode=0 & op0007=0xd & op0815=0 ; op1621=0 & op2227=0x16 & op2831=0
{
	wait();
}
@endif

# XNOR D[c], D[a], D[b] (RR)
:xnor Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0xd0
{
	Rd2831 = ~(Rd0811 ^ Rd1215);
}

# XNOR D[c], D[a], const9 (RC)
:xnor Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0xd ) & const1220Z
{
	Rd2831 = ~(Rd0811 ^ const1220Z);
}

# XNOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:xnor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x7 ; Rd2831 & const1620Z & const2327Z & op2122=0x2
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831 = zext(!(tmpa[0,1] ^ tmpb[0,1]));
}

@if defined(TRICORE_RIDER_B) || defined(TRICORE_RIDER_D) || defined(TRICORE_V2)
# XOR D[a], D[b] (SRR)
:xor Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xc6
{
	Rd0811 = Rd0811 ^ Rd1215;
}
@endif

# XOR D[c], D[a], D[b] (RR)
:xor Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xf ; Rd2831 & op1627=0xc0
{
	Rd2831 = Rd0811 ^ Rd1215;
}

# XOR D[c], D[a], const9 (RC)
:xor Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8f ; Rd2831 & op2127=0xc ) & const1220Z
{
	Rd2831 = Rd0811 ^ const1220Z;
}

# XOR.EQ D[c], D[a], D[b] (RR)
:xor.eq Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x2f0
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 == Rd1215);
}

# XOR.EQ D[c], D[a], const9 (RC)
:xor.eq Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x2f ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 == const1220S);
}

# XOR.GE D[c], D[a], D[b] (RR)
:xor.ge Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x330
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 s>= Rd1215);
}

# XOR.GE D[c], D[a], const9 (RC)
:xor.ge Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x33 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 s>= const1220S);
}

# XOR.GE.U D[c], D[a], D[b] (RR)
:xor.ge.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x340
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 >= Rd1215);
}

# XOR.GE.U D[c], D[a], const9 (RC)
:xor.ge.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x34 ) & const1220Z
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 >= const1220Z);
}

# XOR.LT D[c], D[a], D[b] (RR)
:xor.lt Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x310
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 s< Rd1215);
}

# XOR.LT D[c], D[a], const9 (RC)
:xor.lt Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x31 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 s< const1220S);
}

# XOR.LT.U D[c], D[a], D[b] (RR)
:xor.lt.u Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x320
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 < Rd1215);
}

# XOR.LT.U D[c], D[a], const9 (RC)
:xor.lt.u Rd2831,Rd0811,const1220Z is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x32 ) & const1220Z
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 < const1220Z);
}

# XOR.NE D[c], D[a], D[b] (RR)
:xor.ne Rd2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Rd2831 & op1627=0x300
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 != Rd1215);
}

# XOR.NE D[c], D[a], const9 (RC)
:xor.ne Rd2831,Rd0811,const1220S is PCPMode=0 & ( Rd0811 & op0007=0x8b ; Rd2831 & op2127=0x30 ) & const1220S
{
	Rd2831[0,1] = Rd2831[0,1] ^ (Rd0811 != const1220S);
}

# XOR.T D[c], D[a], pos1, D[b], pos2 (BIT)
:xor.t Rd2831,Rd0811,const1620Z,Rd1215,const2327Z is PCPMode=0 & Rd0811 & Rd1215 & op0007=0x7 ; Rd2831 & const1620Z & const2327Z & op2122=0x3
{
	local tmpa = (Rd0811 >> const1620Z) & 1;
	local tmpb = (Rd1215 >> const2327Z) & 1;
	Rd2831 = zext(tmpa[0,1] ^ tmpb[0,1]);
}

@if defined(TRICORE_V2)
:xpose.b Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Re2831 & op1627=0x830
{
	Re2831 = zext(Rd0811[24,8] << 56)|zext(Rd1215[24,8] << 48)|zext(Rd0811[8,8] << 40)|zext(Rd1215[8,8] << 32)|zext(Rd0811[16,8] << 24)|zext(Rd1215[16,8] << 16)|zext(Rd0811[0,8] << 8)|zext(Rd1215[0,8]);
}
@endif

@if defined(TRICORE_V2)
:xpose.h Re2831,Rd0811,Rd1215 is PCPMode=0 & Rd0811 & Rd1215 & op0007=0xb ; Re2831 & op1627=0x820
{
	Re2831 = zext(Rd0811[16,16] << 48)|zext(Rd1215[16,16] << 32)|zext(Rd0811[0,16] << 16)|zext(Rd1215[0,16]);
}
@endif

# @if defined(TRICORE_V2)
# :yield
# {
# }
# @endif


@include "tricore.pcp.sinc"