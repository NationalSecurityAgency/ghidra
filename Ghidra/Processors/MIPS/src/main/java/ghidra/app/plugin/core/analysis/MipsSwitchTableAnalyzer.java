/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ghidra.app.plugin.core.analysis;

import java.util.ArrayList;
import java.util.List;

import ghidra.app.plugin.core.disassembler.AddressTable;
import ghidra.app.services.AbstractAnalyzer;
import ghidra.app.services.AnalysisPriority;
import ghidra.app.services.AnalyzerType;
import ghidra.app.util.PseudoDisassembler;
import ghidra.app.util.importer.MessageLog;
import ghidra.framework.options.Options;
import ghidra.program.disassemble.Disassembler;
import ghidra.program.model.address.*;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.*;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.pcode.JumpTable;
import ghidra.program.model.scalar.Scalar;
import ghidra.program.model.symbol.*;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Enhanced MIPS switch table analyzer that detects and analyzes jump tables
 * generated by various compilers (GCC, LLVM, Green Hills) with support for
 * both PIC and non-PIC code, and inline case handlers.
 * 
 * This analyzer improves upon the basic switch table detection in MipsAddressAnalyzer
 * by supporting:
 * - Multiple compiler patterns (GCC -O2/-O3, LLVM, etc.)
 * - PIC code with $gp-relative addressing
 * - Inline case handlers in data regions
 * - Larger table sizes (up to 1024 entries)
 * - More flexible pattern matching
 */
public class MipsSwitchTableAnalyzer extends AbstractAnalyzer {
	
	private static final String NAME = "MIPS Switch Table Analyzer";
	private static final String DESCRIPTION = 
		"Detects and analyzes MIPS switch tables (jump tables) including " +
		"GCC, LLVM, and other compiler patterns with support for PIC code and inline handlers.";
	
	private static final String OPTION_NAME_ENABLE = "Enable Enhanced Switch Table Detection";
	private static final String OPTION_DESCRIPTION_ENABLE = 
		"Enable enhanced switch table detection for MIPS binaries";
	
	private static final String OPTION_NAME_MAX_TABLE_SIZE = "Maximum Table Size";
	private static final String OPTION_DESCRIPTION_MAX_TABLE_SIZE = 
		"Maximum number of entries allowed in a switch table (default: 1024)";
	
	private static final String OPTION_NAME_DETECT_INLINE = "Detect Inline Handlers";
	private static final String OPTION_DESCRIPTION_DETECT_INLINE = 
		"Detect and disassemble inline case handlers in data regions";
	
	private static final boolean OPTION_DEFAULT_ENABLE = true;
	private static final int OPTION_DEFAULT_MAX_TABLE_SIZE = 1024;
	private static final boolean OPTION_DEFAULT_DETECT_INLINE = true;
	
	private static final int MAX_SEARCH_DISTANCE = 30; // instructions to search backward
	
	private boolean enableEnhancedDetection = OPTION_DEFAULT_ENABLE;
	private int maxTableSize = OPTION_DEFAULT_MAX_TABLE_SIZE;
	private boolean detectInlineHandlers = OPTION_DEFAULT_DETECT_INLINE;
	
	private Register gpRegister;
	
	public MipsSwitchTableAnalyzer() {
		super(NAME, DESCRIPTION, AnalyzerType.INSTRUCTION_ANALYZER);
		setPriority(AnalysisPriority.BLOCK_ANALYSIS.after());
		setDefaultEnablement(true);
	}
	
	@Override
	public boolean canAnalyze(Program program) {
		return program.getLanguage().getProcessor().equals(
			Processor.findOrPossiblyCreateProcessor("MIPS"));
	}
	
	@Override
	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
			throws CancelledException {
		
		if (!enableEnhancedDetection) {
			return false;
		}
		
		// Initialize registers
		gpRegister = program.getRegister("gp");
		
		Listing listing = program.getListing();
		InstructionIterator instructions = listing.getInstructions(set, true);
		
		int tablesFound = 0;
		
		while (instructions.hasNext() && !monitor.isCancelled()) {
			Instruction instruction = instructions.next();
			
			// Look for jr (jump register) instructions - potential switch statements
			String mnemonic = instruction.getMnemonicString();
			if (mnemonic.equals("jr") || mnemonic.equals("_jr")) {
				monitor.setMessage("Analyzing potential switch at " + instruction.getAddress());
				
				SwitchTableInfo tableInfo = detectSwitchTable(program, instruction, monitor);
				if (tableInfo != null) {
					if (createSwitchTable(program, tableInfo, monitor, log)) {
						tablesFound++;
						Msg.info(this, "Found switch table at " + instruction.getAddress() + 
							" with " + tableInfo.getTableSize() + " entries");
					}
				}
			}
		}
		
		if (tablesFound > 0) {
			Msg.info(this, "MIPS Switch Table Analyzer: Found " + tablesFound + " switch tables");
		}
		
		return tablesFound > 0;
	}
	
	/**
	 * Detect if a jr instruction is part of a switch table pattern
	 */
	private SwitchTableInfo detectSwitchTable(Program program, Instruction jrInstr, 
			TaskMonitor monitor) {
		
		// Step 1: Find bounds check
		BoundsCheckInfo boundsCheck = findBoundsCheck(program, jrInstr);
		if (boundsCheck == null) {
			return null;
		}
		
		// Validate table size
		if (boundsCheck.tableSize < 2 || boundsCheck.tableSize > maxTableSize) {
			return null;
		}
		
		// Step 2: Find table base address
		Address tableBase = findTableBase(program, jrInstr, boundsCheck);
		if (tableBase == null) {
			return null;
		}
		
		// Step 3: Extract and validate jump targets
		List<Address> targets = extractTargets(program, tableBase, boundsCheck.tableSize, monitor);
		if (targets == null || targets.isEmpty()) {
			return null;
		}
		
		// Step 4: Check for inline handlers if enabled
		if (detectInlineHandlers) {
			checkAndDisassembleInlineHandlers(program, targets, monitor);
		}
		
		return new SwitchTableInfo(jrInstr.getAddress(), tableBase, targets, 
			boundsCheck.tableSize, boundsCheck.indexRegister);
	}
	
	/**
	 * Find the bounds check instruction that determines the table size
	 * Supports: sltiu, sltu, bne, beq patterns
	 */
	private BoundsCheckInfo findBoundsCheck(Program program, Instruction jrInstr) {
		Listing listing = program.getListing();
		Instruction current = jrInstr;

		for (int i = 0; i < MAX_SEARCH_DISTANCE; i++) {
			// Navigate backward through control flow
			Address fallFrom = current.getFallFrom();
			if (fallFrom == null) {
				// Try to find via references
				ReferenceIterator refs = current.getReferenceIteratorTo();
				if (refs.hasNext()) {
					Reference ref = refs.next();
					if (!ref.getReferenceType().isCall()) {
						fallFrom = ref.getFromAddress();
					}
				}
			}

			if (fallFrom == null) {
				break;
			}

			current = listing.getInstructionContaining(fallFrom);
			if (current == null) {
				break;
			}

			String mnemonic = current.getMnemonicString();

			// Pattern 1: GCC sltiu (set less than immediate unsigned)
			// Example: sltiu $v0, $s1, 7
			if (mnemonic.equals("sltiu") || mnemonic.equals("_sltiu")) {
				Scalar scalar = current.getScalar(2);
				if (scalar != null) {
					int tableSize = (int) scalar.getUnsignedValue();
					Register indexReg = current.getRegister(1);
					return new BoundsCheckInfo(tableSize, indexReg, current.getAddress());
				}
			}

			// Pattern 2: LLVM sltu (set less than unsigned) - register comparison
			// Example: sltu $v0, $s1, $t0  (where $t0 holds table size)
			if (mnemonic.equals("sltu") || mnemonic.equals("_sltu")) {
				// Try to find the table size from a previous li (load immediate)
				Register sizeReg = current.getRegister(2);
				if (sizeReg != null) {
					int tableSize = findRegisterConstant(program, current, sizeReg);
					if (tableSize > 0) {
						Register indexReg = current.getRegister(1);
						return new BoundsCheckInfo(tableSize, indexReg, current.getAddress());
					}
				}
			}

			// Pattern 3: Direct comparison with beq/bne
			// Example: beq $s1, $t0, default  (if index == size, goto default)
			if (mnemonic.equals("beq") || mnemonic.equals("_beq") ||
			    mnemonic.equals("bne") || mnemonic.equals("_bne")) {
				// Check if one operand is a constant
				Scalar scalar = current.getScalar(1);
				if (scalar != null) {
					int tableSize = (int) scalar.getUnsignedValue();
					Register indexReg = current.getRegister(0);
					return new BoundsCheckInfo(tableSize, indexReg, current.getAddress());
				}
			}
		}

		return null;
	}

	/**
	 * Find a constant value loaded into a register
	 * Searches backward for li (load immediate) or addiu from $zero
	 */
	private int findRegisterConstant(Program program, Instruction fromInstr, Register targetReg) {
		Listing listing = program.getListing();
		Instruction current = fromInstr;

		for (int i = 0; i < 10; i++) {  // Search up to 10 instructions back
			Address fallFrom = current.getFallFrom();
			if (fallFrom == null) {
				break;
			}

			current = listing.getInstructionContaining(fallFrom);
			if (current == null) {
				break;
			}

			String mnemonic = current.getMnemonicString();
			Register destReg = current.getRegister(0);

			// Check if this instruction writes to our target register
			if (destReg != null && destReg.equals(targetReg)) {
				// Pattern: li $reg, immediate (pseudo-instruction, usually addiu $reg, $zero, imm)
				if (mnemonic.equals("addiu") || mnemonic.equals("_addiu")) {
					Register srcReg = current.getRegister(1);
					if (srcReg != null && srcReg.getName().equals("zero")) {
						Scalar scalar = current.getScalar(2);
						if (scalar != null) {
							return (int) scalar.getUnsignedValue();
						}
					}
				}

				// Pattern: ori $reg, $zero, immediate (alternative li encoding)
				if (mnemonic.equals("ori") || mnemonic.equals("_ori")) {
					Register srcReg = current.getRegister(1);
					if (srcReg != null && srcReg.getName().equals("zero")) {
						Scalar scalar = current.getScalar(2);
						if (scalar != null) {
							return (int) scalar.getUnsignedValue();
						}
					}
				}

				// If we found a write to the register but couldn't extract constant, give up
				break;
			}
		}

		return -1;  // Not found
	}
	
	/**
	 * Find the base address of the jump table
	 * Supports: lui/addiu pairs, $gp-relative loads, direct references
	 */
	private Address findTableBase(Program program, Instruction jrInstr, BoundsCheckInfo boundsCheck) {
		Listing listing = program.getListing();
		Instruction current = jrInstr;
		Register targetRegister = null;

		// Search backward for table address calculation
		for (int i = 0; i < MAX_SEARCH_DISTANCE; i++) {
			Address fallFrom = current.getFallFrom();
			if (fallFrom == null) {
				ReferenceIterator refs = current.getReferenceIteratorTo();
				if (refs.hasNext()) {
					Reference ref = refs.next();
					if (!ref.getReferenceType().isCall()) {
						fallFrom = ref.getFromAddress();
					}
				}
			}

			if (fallFrom == null) {
				break;
			}

			current = listing.getInstructionContaining(fallFrom);
			if (current == null) {
				break;
			}

			String mnemonic = current.getMnemonicString();

			// Pattern 1: Look for addiu with reference (after lui/addiu pair)
			if (mnemonic.equals("addiu") || mnemonic.equals("_addiu")) {
				if (targetRegister == null || targetRegister.equals(current.getRegister(0))) {
					Reference[] refs = current.getReferencesFrom();
					if (refs != null && refs.length > 0) {
						// Found table address from lui/addiu pair
						return refs[0].getToAddress();
					}
				}
			}

			// Pattern 2: Look for lw with $gp-relative addressing (PIC code)
			if ((mnemonic.equals("lw") || mnemonic.equals("_lw")) && gpRegister != null) {
				Register baseReg = current.getRegister(1);
				if (baseReg != null && baseReg.equals(gpRegister)) {
					Reference[] refs = current.getReferencesFrom();
					if (refs != null && refs.length > 0) {
						// Found table address from $gp-relative load
						return refs[0].getToAddress();
					}
				}
			}

			// Track which register might hold the table base
			if (mnemonic.equals("addu") || mnemonic.equals("_addu")) {
				targetRegister = current.getRegister(2);
			}

			// Stop if we've gone too far back
			if (current.getAddress().compareTo(boundsCheck.checkAddress) < 0) {
				break;
			}
		}

		return null;
	}
	
	/**
	 * Extract jump targets from the table
	 */
	private List<Address> extractTargets(Program program, Address tableBase, int tableSize,
			TaskMonitor monitor) {

		List<Address> targets = new ArrayList<>();
		int pointerSize = program.getDefaultPointerSize();

		try {
			for (int i = 0; i < tableSize; i++) {
				Address entryAddr = tableBase.add(i * pointerSize);

				// Read the pointer value from the table
				long offset;
				if (pointerSize == 4) {
					offset = program.getMemory().getInt(entryAddr) & 0xFFFFFFFFL;
				} else if (pointerSize == 8) {
					offset = program.getMemory().getLong(entryAddr);
				} else {
					Msg.error(this, "Unsupported pointer size: " + pointerSize);
					return null;
				}

				// Check if this looks like ASCII text (string data, not a code address)
				// This happens when the switch table is followed by string data
				if (isLikelyAsciiString(offset)) {
					// Hit string data - end of switch table
					break;
				}

				// Create address from offset
				Address target = program.getAddressFactory().getDefaultAddressSpace().getAddress(offset);

				// Validate the target address
				if (!isValidCodeAddress(program, target)) {
					// Invalid address - likely end of table or bad data
					// Don't warn, just stop reading the table
					break;
				}

				targets.add(target);
			}
		} catch (Exception e) {
			Msg.error(this, "Error reading switch table at " + tableBase + ": " + e.getMessage());
			return null;
		}

		return targets.isEmpty() ? null : targets;
	}

	/**
	 * Check if an address is valid for code
	 */
	private boolean isValidCodeAddress(Program program, Address addr) {
		if (addr == null) {
			return false;
		}

		MemoryBlock block = program.getMemory().getBlock(addr);
		if (block == null) {
			return false;
		}

		// Must be in an initialized, executable block
		if (!block.isInitialized() || block.isExternalBlock()) {
			return false;
		}

		// Must be executable - don't allow data sections
		if (!block.isExecute()) {
			return false;
		}

		// Additional validation: check if there's actually an instruction at this address
		Instruction instr = program.getListing().getInstructionAt(addr);
		if (instr == null) {
			// No instruction - might be data or undefined
			return false;
		}

		return true;
	}

	/**
	 * Check if a value looks like ASCII text (likely a string, not a code address)
	 */
	private boolean isLikelyAsciiString(long value) {
		// Extract 4 bytes
		byte b0 = (byte) (value & 0xFF);
		byte b1 = (byte) ((value >> 8) & 0xFF);
		byte b2 = (byte) ((value >> 16) & 0xFF);
		byte b3 = (byte) ((value >> 24) & 0xFF);

		// Count printable ASCII characters
		int printableCount = 0;
		if (isPrintableAscii(b0)) printableCount++;
		if (isPrintableAscii(b1)) printableCount++;
		if (isPrintableAscii(b2)) printableCount++;
		if (isPrintableAscii(b3)) printableCount++;

		// If 3 or more bytes are printable ASCII, it's likely a string
		return printableCount >= 3;
	}

	/**
	 * Check if a byte is printable ASCII (space to ~)
	 */
	private boolean isPrintableAscii(byte b) {
		return b >= 0x20 && b <= 0x7E;
	}
	
	/**
	 * Check if targets are in data regions and disassemble if they look like code
	 */
	private void checkAndDisassembleInlineHandlers(Program program, List<Address> targets,
			TaskMonitor monitor) {

		Listing listing = program.getListing();
		PseudoDisassembler pseudoDis = new PseudoDisassembler(program);

		for (Address target : targets) {
			// Check if this address is already disassembled
			if (listing.getInstructionAt(target) != null) {
				continue; // Already has instructions
			}

			// Check if it's in a data region
			Data data = listing.getDataAt(target);
			if (data == null || !data.isDefined()) {
				// Undefined data - check if it looks like code
				if (pseudoDis.isValidSubroutine(target, true)) {
					// Looks like valid MIPS code - disassemble it
					Msg.info(this, "Disassembling inline handler at " + target);
					Disassembler dis = Disassembler.getDisassembler(program, monitor, null);
					AddressSet disSet = dis.disassemble(target, null);
					if (disSet != null && !disSet.isEmpty()) {
						Msg.info(this, "Successfully disassembled inline handler at " + target);
					}
				}
			}
		}
	}

	/**
	 * Create the switch table structure in the program
	 */
	private boolean createSwitchTable(Program program, SwitchTableInfo tableInfo,
			TaskMonitor monitor, MessageLog log) {

		try {
			int pointerSize = program.getDefaultPointerSize();

			// Convert target list to array
			Address[] targetArray = tableInfo.targets.toArray(new Address[0]);

			// Create AddressTable object
			AddressTable table = new AddressTable(tableInfo.tableBase, targetArray,
				pointerSize, 0, false);

			// Get the jump instruction
			Instruction jumpInstr = program.getListing().getInstructionAt(tableInfo.jumpAddress);
			if (jumpInstr == null) {
				Msg.error(this, "Jump instruction not found at " + tableInfo.jumpAddress);
				return false;
			}

			// Create the switch table with references and labels
			table.createSwitchTable(program, jumpInstr, 1, false, monitor);

			// Add references from jump instruction to all targets
			ReferenceManager refMgr = program.getReferenceManager();
			for (Address target : tableInfo.targets) {
				refMgr.addMemoryReference(tableInfo.jumpAddress, target,
					RefType.COMPUTED_JUMP, SourceType.ANALYSIS, CodeUnit.MNEMONIC);
			}

			// Register the switch table with the decompiler
			// This creates a JumpTable override that informs the decompiler about the switch structure
			registerSwitchTableWithDecompiler(program, tableInfo);

			Msg.info(this, "Created switch table at " + tableInfo.tableBase +
				" with " + tableInfo.tableSize + " entries");

			return true;

		} catch (Exception e) {
			Msg.error(this, "Error creating switch table: " + e.getMessage(), e);
			log.appendException(e);
			return false;
		}
	}

	/**
	 * Register the switch table with the decompiler.
	 * This creates a JumpTable override that informs the decompiler about the switch structure,
	 * allowing it to properly decompile the switch statement.
	 *
	 * @param program the program
	 * @param tableInfo the switch table information
	 */
	private void registerSwitchTableWithDecompiler(Program program, SwitchTableInfo tableInfo) {
		try {
			// Get the function containing the switch
			Function function = program.getFunctionManager().getFunctionContaining(tableInfo.jumpAddress);
			if (function == null) {
				Msg.warn(this, "No function found containing switch at " + tableInfo.jumpAddress);
				return;
			}

			// Create a JumpTable override with the switch address and target list
			// The 'true' parameter indicates this is an override (user-defined/analyzer-defined)
			java.util.ArrayList<Address> targetList = new java.util.ArrayList<>(tableInfo.targets);
			JumpTable jumpTable = new JumpTable(tableInfo.jumpAddress, targetList, true);

			// Write the override to the function
			// This creates labels in the "override/jmp_<address>" namespace that the decompiler reads
			jumpTable.writeOverride(function);

			Msg.info(this, "Registered switch table with decompiler for function " +
				function.getName() + " at " + tableInfo.jumpAddress);

		} catch (InvalidInputException e) {
			Msg.warn(this, "Could not register switch table with decompiler: " + e.getMessage());
		} catch (Exception e) {
			Msg.error(this, "Error registering switch table with decompiler: " + e.getMessage(), e);
		}
	}
	
	@Override
	public void registerOptions(Options options, Program program) {
		options.registerOption(OPTION_NAME_ENABLE, enableEnhancedDetection, null,
			OPTION_DESCRIPTION_ENABLE);
		options.registerOption(OPTION_NAME_MAX_TABLE_SIZE, maxTableSize, null,
			OPTION_DESCRIPTION_MAX_TABLE_SIZE);
		options.registerOption(OPTION_NAME_DETECT_INLINE, detectInlineHandlers, null,
			OPTION_DESCRIPTION_DETECT_INLINE);
	}
	
	@Override
	public void optionsChanged(Options options, Program program) {
		enableEnhancedDetection = options.getBoolean(OPTION_NAME_ENABLE, enableEnhancedDetection);
		maxTableSize = options.getInt(OPTION_NAME_MAX_TABLE_SIZE, maxTableSize);
		detectInlineHandlers = options.getBoolean(OPTION_NAME_DETECT_INLINE, detectInlineHandlers);
	}
	
	/**
	 * Information about a bounds check instruction
	 */
	private static class BoundsCheckInfo {
		final int tableSize;
		final Register indexRegister;
		final Address checkAddress;
		
		BoundsCheckInfo(int tableSize, Register indexRegister, Address checkAddress) {
			this.tableSize = tableSize;
			this.indexRegister = indexRegister;
			this.checkAddress = checkAddress;
		}
	}
	
	/**
	 * Information about a detected switch table
	 */
	private static class SwitchTableInfo {
		final Address jumpAddress;
		final Address tableBase;
		final List<Address> targets;
		final int tableSize;
		final Register indexRegister;
		
		SwitchTableInfo(Address jumpAddress, Address tableBase, List<Address> targets,
				int tableSize, Register indexRegister) {
			this.jumpAddress = jumpAddress;
			this.tableBase = tableBase;
			this.targets = targets;
			this.tableSize = tableSize;
			this.indexRegister = indexRegister;
		}
		
		int getTableSize() {
			return tableSize;
		}
	}
}

