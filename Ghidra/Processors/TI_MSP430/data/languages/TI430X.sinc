###################################################################################
#
#	20bit Address Instructions
#
# The original way of using sub-tables to breakout the addressing modes does not
# work for these instructions

#constructor recognizing the presence of an extension word
:^instruction							is opext_11_5=0x3 & ctx_haveext=0 & dest_0_4 & src_ext & al & zc & ad; instruction [ ctx_haveext=1; ctx_ctregdest=dest_0_4; ctx_regsrc=src_ext; ctx_al=al; ctx_num=ad; ctx_zc=zc;] { build instruction;}


#:^instruction							is ctx_haveext=1 & instruction & as=1 & src_8_4=3 [ctx_haveext=2;] {build instruction;}
:^instruction							is ctx_haveext=1 & instruction & as=1 & src_8_4=3 [ctx_haveext=7;] {build instruction;} #replacment substituting second of haveext=2. NOTE: as=1 precludes first 
:^instruction							is ctx_haveext=1 & instruction & as=1 [ctx_haveext=7;] {build instruction;}
:^instruction							is ctx_haveext=1 & instruction & as=3 & src_8_4=0 [ctx_haveext=7;] {build instruction;}
#:^instruction							is ctx_haveext=1 & instruction [ctx_haveext=2;] {build instruction;}
:^instruction							is ctx_haveext=1 & instruction & as=0 & ad=0 [ctx_haveext=3;] {build instruction;} #replacement substituting first of haveext=2
:^instruction							is ctx_haveext=1 & instruction [ctx_haveext=7;] {build instruction;} #replacement substituting second of haveext=2

:^instruction							is ctx_haveext=1 & instruction & op16_7_9=0x23 & as=0 [ctx_haveext=3;] {build instruction;}
:^instruction							is ctx_haveext=1 & instruction & op16_7_9=0x21 & as=0 [ctx_haveext=3;] {build instruction;}

# removed haveext=2
#:^instruction							is ctx_haveext=2 & instruction & as=0 & ad=0 [ctx_haveext=3;] {build instruction;}
#:^instruction							is ctx_haveext=2 & instruction [ctx_haveext=7;] {build instruction;}



:^instruction							is ctx_haveext=3 & instruction & ctx_num=0 & ctx_ctregdest=0 [ctx_haveext=4;] { CNT = 0;build instruction; }
:"RPT #"^val^" { "^instruction			is ctx_haveext=3 & instruction & ctx_num=0 & ctx_ctregdest [ctx_haveext=4; val = ctx_ctregdest+1;] { CNT = ctx_ctregdest;build instruction;}
:"RPT "^ctx_repreg^" { "^instruction	is ctx_haveext=3 & instruction & ctx_num=1 & ctx_repreg [ctx_haveext=4;] { CNT = zext(ctx_repreg[0,4]); build instruction;}

# 20bit address mode sub tables
Abs20: val						is ctx_ctregdest & imm_0_16 [ val=(ctx_ctregdest << 16) | imm_0_16;] {export *[const]:3 val;}
Abs20s: val						is ctx_ctregdests & imm_0_16 [ val=(ctx_ctregdests << 16) | imm_0_16;] {export *[const]:3 val;}
Abs20add: val					is ctx_ctregdest & imm_0_16 [ val=(ctx_ctregdest << 16) | imm_0_16;] {export *:4 val;}

Imm20Dst: val		is ctx_ctregdest & imm_0_16 [ val=(ctx_ctregdest << 16) | imm_0_16;] {export *[const]:4 val;}
ImmS20Dst: val		is ctx_ctregdests & imm_0_16 [ val=(ctx_ctregdests << 16) | imm_0_16;] {export *[const]:4 val;}
Imm20Src: val		is ctx_regsrc & imm_0_16 [ val=(ctx_regsrc << 16) | imm_0_16;] {export *[const]:4 val;}
ImmS20Src: val		is ctx_regsrcs & imm_0_16 [ val=(ctx_regsrcs << 16) | imm_0_16;] {export *[const]:4 val;}

Label20Src: labelCalc		is ctx_regsrcs & imm_0_16 [ labelCalc = inst_start + 4 + ((ctx_regsrcs << 16) | imm_0_16);] {export *[const]:4 labelCalc;}
Label20Dst: labelCalc		is ctx_ctregdests & imm_0_16 [ labelCalc = inst_start + 4 + ((ctx_ctregdests << 16) | imm_0_16);] {export *[const]:4 labelCalc;}
Label20DstExt: labelCalc	is ctx_ctregdests & imm_0_16 [ labelCalc = inst_start + 6 + ((ctx_ctregdests << 16) | imm_0_16);] {export *[const]:4 labelCalc;}

IMM4: val					is imm_4_4 [val = imm_4_4+1;] {export *[const]:1 val;}
NUM2: val					is rrn [ val = rrn+1;] {export *[const]:1 val;}

XREG_B_AS: DST8_0_4 			 		 is DST8_0_4 & as=0x0 & bow=0x1  { export DST8_0_4;} # Word/Register Direct (Rn):
XREG_B_AS: ImmS20Src^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x1 ; ImmS20Src {tmp:$(REG_SIZE) = reg_Indexed16_0_4 + ImmS20Src; export *:1 tmp;}
XREG_B_AS: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x1  {export *:1 reg_InDirect16_0_4;} # Word/Register Indirect (@Rn):
XREG_B_AS: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x1  {export *:1 reg_InDirect16_0_4;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_B_AS: Label20Src 					 is reg16_0_4=0x0 & as=0x1 & bow=0x1 ; Label20Src {export *:1 Label20Src; } # Symbolic
XREG_B_AS: "#"^ImmS20Dst 		 is reg16_0_4=0x0 & as=0x3 & bow=0x1 ; ImmS20Dst {export *[const]:1 ImmS20Dst; } # Immediate
XREG_B_AS: "&"^Imm20Dst 		 is reg16_0_4=0x2 & as=0x1 & bow=0x1 ; Imm20Dst {export *:1 Imm20Dst; } # Absolute
XREG_B_AS: "#4" 						 is reg16_0_4=0x2 & as=0x2 & bow=0x1  { export 4:1;}		# Constant
XREG_B_AS: "#8" 						 is reg16_0_4=0x2 & as=0x3 & bow=0x1  { export 8:1;}		# Constant
XREG_B_AS: "#0" 						 is reg16_0_4=0x3 & as=0x0 & bow=0x1  { export 0:1;}		# Constant
XREG_B_AS: "#1" 						 is reg16_0_4=0x3 & as=0x1 & bow=0x1  { export 1:1;}		# Constant
XREG_B_AS: "#2" 						 is reg16_0_4=0x3 & as=0x2 & bow=0x1  { export 2:1;}		# Constant
XREG_B_AS: "#-1" 						 is	reg16_0_4=0x3 & as=0x3 & bow=0x1  { export 0xff:1;} 	# Constant	

XRREG_B_AS: DST8_0_4						 is DST8_0_4 & as=0x0 & bow=0x1  { export DST8_0_4;} # Word/Register Direct (Rn):
XRREG_B_AS: "#0"						 is reg16_0_4=0x3 & as=0x0 & bow=0x1  { export 0:1;}		# Constant

XREG_W_AS: DST16_0_4 			 		 is DST16_0_4 & as=0x0 & bow=0x0  {export DST16_0_4;} # Word/Register Direct (Rn):
XREG_W_AS: ImmS20Src^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x0 ; ImmS20Src {tmp:$(REG_SIZE) = reg_Indexed16_0_4 + ImmS20Src & ~1; export *:2 tmp;}
XREG_W_AS: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x0  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:2 tmp;} # Word/Register Indirect (@Rn):
XREG_W_AS: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x0  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:2 tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_W_AS: Label20Src 					 is reg16_0_4=0x0 & as=0x1 & bow=0x0 ; Label20Src {local tmp:$(REG_SIZE) = Label20Src & ~1; export *:2 tmp; } # Symbolic
XREG_W_AS: "#"^ImmS20Dst 		 is reg16_0_4=0x0 & as=0x3 & bow=0x0 ; ImmS20Dst {export *[const]:2 ImmS20Dst; } # Immediate
XREG_W_AS: "&"^Imm20Dst 		 is reg16_0_4=0x2 & as=0x1 & bow=0x0 ; Imm20Dst {export *:2 Imm20Dst; } # Absolute
XREG_W_AS: "#4" 						 is reg16_0_4=0x2 & as=0x2 & bow=0x0  { export 4:2;}		# Constant
XREG_W_AS: "#8" 						 is reg16_0_4=0x2 & as=0x3 & bow=0x0  { export 8:2;}		# Constant
XREG_W_AS: "#0" 						 is reg16_0_4=0x3 & as=0x0 & bow=0x0  { export 0:2;}		# Constant
XREG_W_AS: "#1" 						 is reg16_0_4=0x3 & as=0x1 & bow=0x0  { export 1:2;}		# Constant
XREG_W_AS: "#2" 						 is reg16_0_4=0x3 & as=0x2 & bow=0x0  { export 2:2;}		# Constant
XREG_W_AS: "#-1" 					 	 is	reg16_0_4=0x3 & as=0x3 & bow=0x0  { export 0xffff:2;} 	    # Constant

XRREG_W_AS: DST16_0_4						 is DST16_0_4 & as=0x0 & bow=0x0  {export DST16_0_4;} # Word/Register Direct (Rn):
XRREG_W_AS: "#0"						 is reg16_0_4=0x3 & as=0x0 & bow=0x0  { export 0:2;}		# Constant

XREG_A_AS: DST20_0_4						 is DST20_0_4 & as=0 & bow=0x1 {export DST20_0_4;}
XREG_A_AS: ImmS20Src^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x1 ; ImmS20Src {tmp:$(REG_SIZE) = reg_Indexed16_0_4 + ImmS20Src & ~1; export *:$(REG_SIZE) tmp;}
XREG_A_AS: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x1  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect (@Rn):
XREG_A_AS: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x1  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_A_AS: Label20Src 					 is reg16_0_4=0x0 & as=0x1 & bow=0x1 ; Label20Src  {export *:$(REG_SIZE) Label20Src; } # Symbolic
XREG_A_AS: "#"^ImmS20Dst 						 is reg16_0_4=0x0 & as=0x3 & bow=0x1 ; ImmS20Dst {export *[const]:$(REG_SIZE) ImmS20Dst; } # Immediate
XREG_A_AS: "&"^Imm20Dst 						 is reg16_0_4=0x2 & as=0x1 & bow=0x1 ; Imm20Dst {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:$(REG_SIZE) tmp; } # Absolute
XREG_A_AS: "#4" 						 is reg16_0_4=0x2 & as=0x2 & bow=0x1  { export 4:$(REG_SIZE);}		# Constant
XREG_A_AS: "#8" 						 is reg16_0_4=0x2 & as=0x3 & bow=0x1  { export 8:$(REG_SIZE);}		# Constant
XREG_A_AS: "#0" 						 is reg16_0_4=0x3 & as=0x0 & bow=0x1  { export 0:$(REG_SIZE);}		# Constant
XREG_A_AS: "#1" 						 is reg16_0_4=0x3 & as=0x1 & bow=0x1  { export 1:$(REG_SIZE);}		# Constant
XREG_A_AS: "#2" 						 is reg16_0_4=0x3 & as=0x2 & bow=0x1  { export 2:$(REG_SIZE);}		# Constant
XREG_A_AS: "#-1" 						 is	reg16_0_4=0x3 & as=0x3 & bow=0x1  { export 0xffffffff:$(REG_SIZE);} 	# Constant	

XRREG_A_AS: DST20_0_4						 is DST20_0_4 & as=0 & bow=0x1 {export DST20_0_4;}
XRREG_A_AS: "#0" 						 is reg16_0_4=0x3 & as=0x0 & bow=0x1  { export 0:$(REG_SIZE);}		# Constant

XREG_B_AS_DEST: DST8_0_4 			 	 is DST8_0_4 & as=0x0 & bow=0x1  { export DST8_0_4;} # Word/Register Direct (Rn):
XREG_B_AS_DEST: ImmS20Dst^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x1 ; ImmS20Dst {tmp:$(REG_SIZE) = reg_Indexed16_0_4 + ImmS20Dst; export *:1 tmp;}
XREG_B_AS_DEST: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x1  {export *:1 reg_InDirect16_0_4;} # Word/Register Indirect (@Rn):
XREG_B_AS_DEST: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x1  {export *:1 reg_InDirect16_0_4;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_B_AS_DEST: Label20Dst 					 is reg16_0_4=0x0 & as=0x1 & bow=0x1 ; Label20Dst {export *:1 Label20Dst; } # Symbolic
XREG_B_AS_DEST: "&"^Imm20Dst 	 is reg16_0_4=0x2 & as=0x1 & bow=0x1 ; Imm20Dst {export *:1 Imm20Dst; } # Absolute

XRREG_B_AS_DEST: DST8_0_4					 is DST8_0_4 & as=0x0 & reg_Direct16_0_4 & bow=0x1  { ztmp:1 = DST8_0_4; reg_Direct16_0_4=0; DST8_0_4 = ztmp; export DST8_0_4;} # Word/Register Direct (Rn):

XREG_W_AS_DEST: ImmS20Dst^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x0 & AMASK ; ImmS20Dst {tmp:$(REG_SIZE) = (reg_Indexed16_0_4 + ImmS20Dst) & AMASK; export *:2 tmp;}
XREG_W_AS_DEST: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x0  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:2 tmp;} # Word/Register Indirect (@Rn):
XREG_W_AS_DEST: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x0  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:2 tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_W_AS_DEST: Label20Dst 					 is reg16_0_4=0x0 & as=0x1 & bow=0x0 ; Label20Dst {local tmp:$(REG_SIZE) = Label20Dst & ~1; export *:2 tmp; } # Symbolic
XREG_W_AS_DEST: "&"^Imm20Dst 	 is reg16_0_4=0x2 & as=0x1 & bow=0x0 ; Imm20Dst {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:2 tmp; } # Absolute

XRREG_W_AS_DEST: DST16_0_4					 is DST16_0_4 & as=0x0 & reg_Direct16_0_4 & bow=0x0  {ztmp:2 = DST16_0_4; reg_Direct16_0_4=0; DST16_0_4 = ztmp;export DST16_0_4;} # Word/Register Direct (Rn):

XREG_A_AS_DEST: ImmS20Dst^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x1 ; ImmS20Dst {tmp:$(REG_SIZE) = reg_Indexed16_0_4 + ImmS20Dst & ~1; export *:$(REG_SIZE) tmp;}
XREG_A_AS_DEST: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x1  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect (@Rn):
XREG_A_AS_DEST: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x1  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_A_AS_DEST: Label20Dst 					 is reg16_0_4=0x0 & as=0x1 & bow=0x1 ; Label20Dst {export *:$(REG_SIZE) Label20Dst; } # Symbolic
XREG_A_AS_DEST: "&"^Imm20Dst 					 is reg16_0_4=0x2 & as=0x1 & bow=0x1 ; Imm20Dst {export *:$(REG_SIZE) Imm20Dst; } # Absolute

XRREG_A_AS_DEST: DST20_0_4					 is DST20_0_4 & as=0 & bow=0x1 {export DST20_0_4;}

XREG_A_AS_DEST2: Imm20Dst^"("^reg_Indexed16_0_4^")" is reg_Indexed16_0_4 & as=0x1 & bow=0x0 ; Imm20Dst {tmp:$(REG_SIZE) = reg_Indexed16_0_4 + Imm20Dst & ~1; export *:$(REG_SIZE) tmp;}
XREG_A_AS_DEST2: "@"^reg_InDirect16_0_4 		 is reg_InDirect16_0_4 & as=0x2 & bow=0x0  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect (@Rn):
XREG_A_AS_DEST2: "@"^reg_InDirect16_0_4^"+"	 is reg_InDirect16_0_4 & as=0x3 & bow=0x0  {local tmp:$(REG_SIZE) = reg_InDirect16_0_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XREG_A_AS_DEST2: Label20Dst 					 is reg16_0_4=0x0 & as=0x1 & bow=0x0 ; Label20Dst {export *:$(REG_SIZE) Label20Dst; } # Symbolic
XREG_A_AS_DEST2: "&"^Imm20Dst 					 is reg16_0_4=0x2 & as=0x1 & bow=0x0 ; Imm20Dst {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:$(REG_SIZE) tmp; } # Absolute

XRREG_A_AS_DEST2: DST20_0_4					 is DST20_0_4 & as=0 & bow=0x0 {export DST20_0_4;}

XSRC_B_AS: SRC8_8_4 			 		 is SRC8_8_4 & as=0x0 & bow=0x1 { export SRC8_8_4;} # Word/Register Direct (Rn):
XSRC_B_AS: ImmS20Src^"("^src_Indexed16_8_4^")" is src_Indexed16_8_4 & as=0x1 & bow=0x1 ; ImmS20Src {tmp:$(REG_SIZE) = src_Indexed16_8_4 + ImmS20Src; export *:1 tmp;}
XSRC_B_AS: "@"^src_InDirect16_8_4 	 is src_InDirect16_8_4 & as=0x2 & bow=0x1  {export *:1 src_InDirect16_8_4;} # Word/Register Indirect (@Rn):
XSRC_B_AS: "@"^src_InDirect16_8_4^"+" is src_InDirect16_8_4 & as=0x3 & bow=0x1  {export *:1 src_InDirect16_8_4;} # Word/Register Indirect Autoincrement (@Rn+):	
XSRC_B_AS: Label20Src 				 is src16_8_4=0x0 & as=0x1 & bow=0x1 ; Label20Src {export *:1 Label20Src; } # Symbolic
XSRC_B_AS: "#"^ImmS20Src 	 is src16_8_4=0x0 & as=0x3 & bow=0x1 ; ImmS20Src {export *[const]:1 ImmS20Src;} # Immediate
XSRC_B_AS: "&"^Imm20Src 	 is src16_8_4=0x2 & as=0x1 & bow=0x1 ; Imm20Src {export *:1 Imm20Src; } # Absolute
XSRC_B_AS: "#4" 						 is src16_8_4=0x2 & as=0x2 & bow=0x1  { export 4:1; }		# Constant
XSRC_B_AS: "#8" 						 is src16_8_4=0x2 & as=0x3 & bow=0x1  { export 8:1; }		# Constant
XSRC_B_AS: "#0" 						 is src16_8_4=0x3 & as=0x0 & bow=0x1  { export 0:1; }		# Constant
XSRC_B_AS: "#1" 						 is src16_8_4=0x3 & as=0x1 & bow=0x1  { export 1:1; }		# Constant
XSRC_B_AS: "#2" 						 is src16_8_4=0x3 & as=0x2 & bow=0x1  { export 2:1; }		# Constant
XSRC_B_AS: "#-1" 					 is	src16_8_4=0x3 & as=0x3 & bow=0x1  { export 0xff:1; } 	# Constant

XRSRC_B_AS: SRC8_8_4						 is SRC8_8_4 & as=0x0 & bow=0x1 { export SRC8_8_4;} # Word/Register Direct (Rn):
XRSRC_B_AS: "#0" 						 is src16_8_4=0x3 & as=0x0 & bow=0x1  { export 0:1; }		# Constant

XSRC_W_AS: SRC16_8_4 			 	 is SRC16_8_4 & as=0x0 & bow=0x0 {export SRC16_8_4;} # Word/Register Direct (Rn):
XSRC_W_AS: ImmS20Src^"("^src_Indexed16_8_4^")" is src_Indexed16_8_4 & as=0x1 & bow=0x0 ; ImmS20Src {tmp:$(REG_SIZE) = src_Indexed16_8_4 + ImmS20Src; export *:2 tmp;}
XSRC_W_AS: "@"^src_InDirect16_8_4 	 is src_InDirect16_8_4 & as=0x2 & bow=0x0  {local tmp:$(REG_SIZE) = src_InDirect16_8_4 & ~1; export *:2 tmp;} # Word/Register Indirect (@Rn):
XSRC_W_AS: "@"^src_InDirect16_8_4^"+" is src_InDirect16_8_4 & as=0x3 & bow=0x0  {local tmp:$(REG_SIZE) = src_InDirect16_8_4 & ~1; export *:2 tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XSRC_W_AS: Label20Src 				 is src16_8_4=0x0 & as=0x1 & bow=0x0 ; Label20Src {local tmp:$(REG_SIZE) = Label20Src & ~1; export *:2 tmp; } # Symbolic
XSRC_W_AS: "#"^ImmS20Src 	 is src16_8_4=0x0 & as=0x3 & bow=0x0 ; ImmS20Src {export *[const]:2 ImmS20Src; } # Immediate
XSRC_W_AS: "&"^Imm20Src 	 is src16_8_4=0x2 & as=0x1 & bow=0x0 ; Imm20Src {local tmp:$(REG_SIZE) = Imm20Src & ~1; export *:2 tmp; } # Absolute
XSRC_W_AS: "#4" 					 is src16_8_4=0x2 & as=0x2 & bow=0x0  { export 4:2; }		# Constant
XSRC_W_AS: "#8" 					 is src16_8_4=0x2 & as=0x3 & bow=0x0  { export 8:2; }		# Constant
XSRC_W_AS: "#0" 					 is src16_8_4=0x3 & as=0x0 & bow=0x0  { export 0:2; }		# Constant
XSRC_W_AS: "#1" 					 is src16_8_4=0x3 & as=0x1 & bow=0x0  { export 1:2; }		# Constant
XSRC_W_AS: "#2" 					 is src16_8_4=0x3 & as=0x2 & bow=0x0  { export 2:2; }		# Constant
XSRC_W_AS: "#-1" 					 is	src16_8_4=0x3 & as=0x3 & bow=0x0  { export 0xffff:2; } 	# Constant	

XRSRC_W_AS: SRC16_8_4					 is SRC16_8_4 & as=0x0 & bow=0x0 {export SRC16_8_4;} # Word/Register Direct (Rn):
XRSRC_W_AS: "#0" 					 is src16_8_4=0x3 & as=0x0 & bow=0x0  { export 0:2; }		# Constant

XSRC_A_AS: SRC20_8_4 			 		 is SRC20_8_4 & as=0x0 & bow=0x1 { export SRC20_8_4;} # Word/Register Direct (Rn):
XSRC_A_AS: ImmS20Src^"("^src_Indexed16_8_4^")" is src_Indexed16_8_4 & as=0x1 & bow=0x1 ; ImmS20Src {tmp:$(REG_SIZE) = src_Indexed16_8_4 + ImmS20Src & ~1; export *:$(REG_SIZE) tmp;}
XSRC_A_AS: "@"^src_InDirect16_8_4 	 is src_InDirect16_8_4 & as=0x2 & bow=0x1  {local tmp:$(REG_SIZE) = src_InDirect16_8_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect (@Rn):
XSRC_A_AS: "@"^src_InDirect16_8_4^"+" is src_InDirect16_8_4 & as=0x3 & bow=0x1  {local tmp:$(REG_SIZE) = src_InDirect16_8_4 & ~1; export *:$(REG_SIZE) tmp;} # Word/Register Indirect Autoincrement (@Rn+):
XSRC_A_AS: Label20Src 				 is src16_8_4=0x0 & as=0x1 & bow=0x1 ; Label20Src {export *:$(REG_SIZE) Label20Src; } # Symbolic
XSRC_A_AS: "#"^ImmS20Src 	 				 is src16_8_4=0x0 & as=0x3 & bow=0x1 ; ImmS20Src {export *[const]:$(REG_SIZE) ImmS20Src; } # Immediate
XSRC_A_AS: "&"^Imm20Src 	 				 is src16_8_4=0x2 & as=0x1 & bow=0x1 ; Imm20Src {local tmp:$(REG_SIZE) = Imm20Src & ~1; export *:$(REG_SIZE) tmp; } # Absolute
XSRC_A_AS: "#4" 					 is src16_8_4=0x2 & as=0x2 & bow=0x1  { export 4:$(REG_SIZE); }		# Constant
XSRC_A_AS: "#8" 					 is src16_8_4=0x2 & as=0x3 & bow=0x1  { export 8:$(REG_SIZE); }		# Constant
XSRC_A_AS: "#0" 					 is src16_8_4=0x3 & as=0x0 & bow=0x1  { export 0:$(REG_SIZE); }		# Constant
XSRC_A_AS: "#1" 					 is src16_8_4=0x3 & as=0x1 & bow=0x1  { export 1:$(REG_SIZE); }		# Constant
XSRC_A_AS: "#2" 					 is src16_8_4=0x3 & as=0x2 & bow=0x1  { export 2:$(REG_SIZE); }		# Constant
XSRC_A_AS: "#-1" 					 is	src16_8_4=0x3 & as=0x3 & bow=0x1  { export 0xffffffff:$(REG_SIZE); } 	# Constant	

XRSRC_A_AS: SRC20_8_4 			 		 is SRC20_8_4 & as=0x0 & bow=0x1 { export SRC20_8_4;} # Word/Register Direct (Rn):
XRSRC_A_AS: "#0" 					 is src16_8_4=0x3 & as=0x0 & bow=0x1  { export 0:$(REG_SIZE); }		# Constant

XDEST_B_AD: DST8_0_4 		  		 is DST8_0_4 & ad=0x0 & bow=0x1
     { export DST8_0_4; }        # Word/Register Direct (Rn):
XDEST_B_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x1 ; ImmS20Dst
     { tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst; export *:1 tmp;}
XDEST_B_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x1 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; ImmS20Dst
     { tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst; export *:1 tmp;}
XDEST_B_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x1 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; ImmS20Dst
     { tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst; export *:1 tmp;}
XDEST_B_AD: Label20Dst 				  is dest=0x0 & ad=0x1 & bow=0x1 ; Label20Dst
     { export *:1 Label20Dst; } # Symbolic
XDEST_B_AD: Label20DstExt 				  is dest=0x0 & ad=0x1 & bow=0x1 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; Label20DstExt
     {export *:1 Label20DstExt; } # Symbolic
XDEST_B_AD: Label20DstExt 				  is dest=0x0 & ad=0x1 & bow=0x1 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; Label20DstExt
     {export *:1 Label20DstExt; } # Symbolic
XDEST_B_AD: "&"^Imm20Dst 	  is dest=0x2 & ad=0x1 & bow=0x1 ; Imm20Dst
     {export *:1 Imm20Dst; } # Absolute
XDEST_B_AD: "&"^Imm20Dst   is dest=0x2 & ad=0x1 & bow=0x1 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; Imm20Dst
     {export *:1 Imm20Dst; } # Absolute
XDEST_B_AD: "&"^Imm20Dst   is dest=0x2 & ad=0x1 & bow=0x1 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; Imm20Dst
     {export *:1 Imm20Dst; } # Absolute


XDEST_W_AD: DST16_0_4 		  		 is DST16_0_4 & ad=0x0 & bow=0x0
     {export DST16_0_4;} # Word/Register Direct (Rn):
XDEST_W_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x0 ; ImmS20Dst
     {tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst & ~1; export *:2 tmp;}
XDEST_W_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x0 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; ImmS20Dst
     {tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst & ~1; export *:2 tmp;}
XDEST_W_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x0 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; ImmS20Dst
     {tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst & ~1; export *:2 tmp;}
XDEST_W_AD: Label20Dst 				  is dest=0x0 & ad=0x1 & bow=0x0 ; Label20Dst
     {local tmp:$(REG_SIZE) = Label20Dst & ~1; export *:2 tmp; } # Symbolic
XDEST_W_AD: Label20DstExt 				  is dest=0x0 & ad=0x1 & bow=0x0 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; Label20DstExt
     {local tmp:$(REG_SIZE) = Label20DstExt & ~1; export *:2 tmp; } # Symbolic
XDEST_W_AD: Label20DstExt 				  is dest=0x0 & ad=0x1 & bow=0x0 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; Label20DstExt
     {local tmp:$(REG_SIZE) = Label20DstExt & ~1; export *:2 tmp; } # Symbolic
XDEST_W_AD: "&"^Imm20Dst 	  is dest=0x2 & ad=0x1 & bow=0x0 ; Imm20Dst
     {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:2 tmp; } # Absolute
XDEST_W_AD: "&"^Imm20Dst   is dest=0x2 & ad=0x1 & bow=0x0 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; Imm20Dst
     {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:2 tmp; } # Absolute
XDEST_W_AD: "&"^Imm20Dst   is dest=0x2 & ad=0x1 & bow=0x0 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; Imm20Dst
     {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:2 tmp; } # Absolute

XDEST_A_AD: DST20_0_4 		  		 is DST20_0_4 & ad=0x0 & bow=0x1
     { export DST20_0_4; }        # Word/Register Direct (Rn):
XDEST_A_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x1 ; ImmS20Dst
     {tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst & ~1; export *:$(REG_SIZE) tmp;}
XDEST_A_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x1 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; ImmS20Dst
     {tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst & ~1; export *:$(REG_SIZE) tmp;}
XDEST_A_AD: ImmS20Dst^"("^dest_Indexed16_0_4^")" is dest_Indexed16_0_4 & ad=0x1 & bow=0x1 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; ImmS20Dst
     {tmp:$(REG_SIZE) = dest_Indexed16_0_4 + ImmS20Dst & ~1; export *:$(REG_SIZE) tmp;}
XDEST_A_AD: Label20Dst 				  is dest=0x0 & ad=0x1 & bow=0x1 ; Label20Dst
     {local tmp:$(REG_SIZE) = Label20Dst & ~1; export *:$(REG_SIZE) tmp; } # Symbolic
XDEST_A_AD: Label20DstExt			  is dest=0x0 & ad=0x1 & bow=0x1 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ;Label20DstExt
     {local tmp:$(REG_SIZE) = Label20DstExt & ~1; export *:$(REG_SIZE) tmp; } # Symbolic
XDEST_A_AD: Label20DstExt			  is dest=0x0 & ad=0x1 & bow=0x1 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; Label20DstExt
     {local tmp:$(REG_SIZE) = Label20DstExt & ~1; export *:$(REG_SIZE) tmp; } # Symbolic
XDEST_A_AD: "&"^Imm20Dst 			  is dest=0x2 & ad=0x1 & bow=0x1 ; Imm20Dst
     {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:$(REG_SIZE) tmp; } # Absolute
XDEST_A_AD: "&"^Imm20Dst			  is dest=0x2 & ad=0x1 & bow=0x1 & as=0x1 & ((src16_8_4>=0x0 & src16_8_4<=0x2) | (src16_8_4>=0x4 & src16_8_4<=0xF)) ; indexExtWord16_0_16 ; Imm20Dst
     {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:$(REG_SIZE) tmp; } # Absolute
XDEST_A_AD: "&"^Imm20Dst			  is dest=0x2 & ad=0x1 & bow=0x1 & as=0x3 & src16_8_4=0x0 ; indexExtWord16_0_16 ; Imm20Dst
     {local tmp:$(REG_SIZE) = Imm20Dst & ~1; export *:$(REG_SIZE) tmp; } # Absolute

#Use repeat_carry with a build directive at the beginning of a RPT loop

#use existing value of carry bit
repeat_carry: is ctx_zc = 0 {} 

#in this case the repeated instruction uses 0 as the value of the carry bit
#after repeated instruction executes, value of carry bit is defined by the result of
#last operation, so building this constructor at the beginning of RPT loop can accurately
#model the semantics
repeat_carry: is ctx_zc = 1 {$(CARRY) = 0;} 

macro setaddflags(ans, in1, in2)
{
	local src_neg:1 = in1[19,1] == 1;
	local dst_neg:1 = in2[19,1] == 1;
	local ans_neg:1 = ans[19,1] == 1;

	$(CARRY) = in1[0,20] + in2[0,20] > 0xFFFFF;
	$(OVERFLOW) = (!src_neg && !dst_neg && ans_neg) || (src_neg && dst_neg && !ans_neg);
	$(SIGN) = ans_neg;
	$(ZERO) = (ans[0,20] == 0);
}

macro setsubflags(ans, in1, in2)
{
	tmp1:$(REG_SIZE) = in1 << 12 s>> 12; # Rscr
	tmp2:$(REG_SIZE) = in2 << 12 s>> 12; # Rdst
	tmpans:$(REG_SIZE) = ans << 12 s>> 12;

	$(CARRY) = tmp1 <= tmp2;
	$(OVERFLOW) = ((tmp1 s< 0) && (tmp2 s>= 0) && (tmpans s< 0)) || ((tmp1 s>= 0) && (tmp2 s< 0) && (tmpans s>= 0));
	$(SIGN) = tmpans s< 0;
	$(ZERO) = (ans == 0);
}

#################
#
# Subtables for the pushm/popm variants.
# In memory, the 20 bit regs take up 4 bytes with all the uppers being 0.
# However, to get some of the math to work, the 20bit regs are sign extended when reading from mem.

PUSHAR0:					is ctx_count=0 {}
PUSHAR0:					is ctx_mreg=0x0 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = inst_next;
}

PUSHAR1:					is ctx_count=0 {}
PUSHAR1:					is PUSHAR0 {build PUSHAR0;}
PUSHAR1:					is ctx_mreg=0x1 & PUSHAR0 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	local tmp:4 = SP;
	SP = SP - 4;
	*[RAM]:4 SP = tmp & 0xFFFFE;
	build PUSHAR0;
}

PUSHAR2:					is ctx_count=0 {}
PUSHAR2:					is PUSHAR1 {build PUSHAR1;}
PUSHAR2:					is ctx_mreg=0x2 & PUSHAR1 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = SR & 0xFFFF;
	build PUSHAR1;
}

PUSHAR3:					is ctx_count=0 {}
PUSHAR3:					is PUSHAR2 {build PUSHAR2;}
PUSHAR3:					is ctx_mreg=0x3 & PUSHAR2 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R3 & 0xFFFFF;
	build PUSHAR2;
}

PUSHAR4:					is ctx_count=0 {}
PUSHAR4:					is PUSHAR3 {build PUSHAR3;}
PUSHAR4:					is ctx_mreg=0x4 & PUSHAR3 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R4 & 0xFFFFF;
	build PUSHAR3;
}

PUSHAR5:					is ctx_count=0 {}
PUSHAR5:					is PUSHAR4 {build PUSHAR4;}
PUSHAR5:					is ctx_mreg=0x5 & PUSHAR4 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R5 & 0xFFFFF;
	build PUSHAR4;
}

PUSHAR6:					is ctx_count=0 {}
PUSHAR6:					is PUSHAR5 {build PUSHAR5;}
PUSHAR6:					is ctx_mreg=0x6 & PUSHAR5 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R6 & 0xFFFFF;
	build PUSHAR5;
}

PUSHAR7:					is ctx_count=0 {}
PUSHAR7:					is PUSHAR6 {build PUSHAR6;}
PUSHAR7:					is ctx_mreg=0x7 & PUSHAR6 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R7 & 0xFFFFF;
	build PUSHAR6;
}

PUSHAR8:					is ctx_count=0 {}
PUSHAR8:					is PUSHAR7 {build PUSHAR7;}
PUSHAR8:					is ctx_mreg=0x8 & PUSHAR7 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R8 & 0xFFFFF;
	build PUSHAR7;
}

PUSHAR9:					is ctx_count=0 {}
PUSHAR9:					is PUSHAR8 {build PUSHAR8;}
PUSHAR9:					is ctx_mreg=0x9 & PUSHAR8 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R9 & 0xFFFFF;
	build PUSHAR8;
}

PUSHAR10:					is ctx_count=0 {}
PUSHAR10:					is PUSHAR9 {build PUSHAR9;}
PUSHAR10:					is ctx_mreg=0xA & PUSHAR9 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R10 & 0xFFFFF;
	build PUSHAR9;
}

PUSHAR11:					is ctx_count=0 {}
PUSHAR11:					is PUSHAR10 {build PUSHAR10;}
PUSHAR11:					is ctx_mreg=0xB & PUSHAR10 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R11 & 0xFFFFF;
	build PUSHAR10;
}

PUSHAR12:					is ctx_count=0 {}
PUSHAR12:					is PUSHAR11 {build PUSHAR11;}
PUSHAR12:					is ctx_mreg=0xC & PUSHAR11 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R12 & 0xFFFFF;
	build PUSHAR11;
}

PUSHAR13:					is ctx_count=0 {}
PUSHAR13:					is PUSHAR12 {build PUSHAR12;}
PUSHAR13:					is ctx_mreg=0xD & PUSHAR12 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R13 & 0xFFFFF;
	build PUSHAR12;
}

PUSHAR14:					is ctx_count=0 {}
PUSHAR14:					is PUSHAR13 {build PUSHAR13;}
PUSHAR14:					is ctx_mreg=0xE & PUSHAR13 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R14 & 0xFFFFF;
	build PUSHAR13;
}

PUSHAR15:					is PUSHAR14 {build PUSHAR14;}
PUSHAR15:					is ctx_mreg=0xF & PUSHAR14 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 4;
	*[RAM]:4 SP = R15 & 0xFFFFF;
	build PUSHAR14;
}

PUSHWR0:					is ctx_count=0 {}
PUSHWR0:					is ctx_mreg=0x0 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = inst_next & 0xFFFF;
}

PUSHWR1:					is ctx_count=0 {}
PUSHWR1:					is PUSHWR0 {build PUSHWR0;}
PUSHWR1:					is ctx_mreg=0x1 & PUSHWR0 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	local tmp:2 = SP:2;
	SP = SP - 2;
	*[RAM]:2 SP = tmp;
	build PUSHWR0;
}

PUSHWR2:					is ctx_count=0 {}
PUSHWR2:					is PUSHWR1 {build PUSHWR1;}
PUSHWR2:					is ctx_mreg=0x2 & PUSHWR1 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = SR:2;
	build PUSHWR1;
}

PUSHWR3:					is ctx_count=0 {}
PUSHWR3:					is PUSHWR2 {build PUSHWR2;}
PUSHWR3:					is ctx_mreg=0x3 & PUSHWR2 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R3:2;
	build PUSHWR2;
}

PUSHWR4:					is ctx_count=0 {}
PUSHWR4:					is PUSHWR3 {build PUSHWR3;}
PUSHWR4:					is ctx_mreg=0x4 & PUSHWR3 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R4:2;
	build PUSHWR3;
}

PUSHWR5:					is ctx_count=0 {}
PUSHWR5:					is PUSHWR4 {build PUSHWR4;}
PUSHWR5:					is ctx_mreg=0x5 & PUSHWR4 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R5:2;
	build PUSHWR4;
}

PUSHWR6:					is ctx_count=0 {}
PUSHWR6:					is PUSHWR5 {build PUSHWR5;}
PUSHWR6:					is ctx_mreg=0x6 & PUSHWR5 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R6:2;
	build PUSHWR5;
}

PUSHWR7:					is ctx_count=0 {}
PUSHWR7:					is PUSHWR6 {build PUSHWR6;}
PUSHWR7:					is ctx_mreg=0x7 & PUSHWR6 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R7:2;
	build PUSHWR6;
}

PUSHWR8:					is ctx_count=0 {}
PUSHWR8:					is PUSHWR7 {build PUSHWR7;}
PUSHWR8:					is ctx_mreg=0x8 & PUSHWR7 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R8:2;
	build PUSHWR7;
}

PUSHWR9:					is ctx_count=0 {}
PUSHWR9:					is PUSHWR8 {build PUSHWR8;}
PUSHWR9:					is ctx_mreg=0x9 & PUSHWR8 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R9:2;
	build PUSHWR8;
}

PUSHWR10:					is ctx_count=0 {}
PUSHWR10:					is PUSHWR9 {build PUSHWR9;}
PUSHWR10:					is ctx_mreg=0xA & PUSHWR9 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R10:2;
	build PUSHWR9;
}

PUSHWR11:					is ctx_count=0 {}
PUSHWR11:					is PUSHWR10 {build PUSHWR10;}
PUSHWR11:					is ctx_mreg=0xB & PUSHWR10 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R11:2;
	build PUSHWR10;
}

PUSHWR12:					is ctx_count=0 {}
PUSHWR12:					is PUSHWR11 {build PUSHWR11;}
PUSHWR12:					is ctx_mreg=0xC & PUSHWR11 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R12:2;
	build PUSHWR11;
}

PUSHWR13:					is ctx_count=0 {}
PUSHWR13:					is PUSHWR12 {build PUSHWR12;}
PUSHWR13:					is ctx_mreg=0xD & PUSHWR12 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R13:2;
	build PUSHWR12;
}

PUSHWR14:					is ctx_count=0 {}
PUSHWR14:					is PUSHWR13 {build PUSHWR13;}
PUSHWR14:					is ctx_mreg=0xE & PUSHWR13 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R14:2;
	build PUSHWR13;
}

PUSHWR15:					is PUSHWR14 {build PUSHWR14;}
PUSHWR15:					is ctx_mreg=0xF & PUSHWR14 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg-1;] {
	SP = SP - 2;
	*[RAM]:2 SP = R15:2;
	build PUSHWR14;
}

POPAR15:					is ctx_count=0 {}
POPAR15:					is ctx_mreg=0xF {
	R15 = *[RAM]:4 SP;
	R15 = sext(R15[0,20]);
	SP = SP + 4;	
}

POPAR14:					is ctx_count=0 {}
POPAR14:					is  POPAR15 {build POPAR15;}
POPAR14:					is ctx_mreg=0xE & POPAR15 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {	
	R14 = *[RAM]:4 SP;
	R14 = sext(R14[0,20]);
	SP = SP + 4;
	build POPAR15;
}

POPAR13:					is ctx_count=0 {}
POPAR13:					is  POPAR14 {build POPAR14;}
POPAR13:					is ctx_mreg=0xD & POPAR14 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R13 = *[RAM]:4 SP;
	R13 = sext(R13[0,20]);
	SP = SP + 4;
	build POPAR14;
}

POPAR12:					is ctx_count=0 {}
POPAR12:					is  POPAR13 {build POPAR13;}
POPAR12:					is ctx_mreg=0xC & POPAR13 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R12 = *[RAM]:4 SP;
	R12 = sext(R12[0,20]);
	SP = SP + 4;
	build POPAR13;
}

POPAR11:					is ctx_count=0 {}
POPAR11:					is  POPAR12 {build POPAR12;}
POPAR11:					is ctx_mreg=0xB & POPAR12 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R11 = *[RAM]:4 SP;
	R11 = sext(R11[0,20]);
	SP = SP + 4;
	build POPAR12;
}

POPAR10:					is ctx_count=0 {}
POPAR10:					is  POPAR11 {build POPAR11;}
POPAR10:					is ctx_mreg=0xA & POPAR11 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R10 = *[RAM]:4 SP;
	R10 = sext(R10[0,20]);
	SP = SP + 4;
	build POPAR11;
}

POPAR9:						is ctx_count=0 {}
POPAR9:						is  POPAR10 {build POPAR10;}
POPAR9:						is ctx_mreg=0x9 & POPAR10 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R9 = *[RAM]:4 SP;
	R9 = sext(R9[0,20]);
	SP = SP + 4;
	build POPAR10;
}

POPAR8:						is ctx_count=0 {}
POPAR8:						is  POPAR9 {build POPAR9;}
POPAR8:						is ctx_mreg=0x8 & POPAR9 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R8 = *[RAM]:4 SP;
	R8 = sext(R8[0,20]);
	SP = SP + 4;
	build POPAR9;
}

POPAR7:						is ctx_count=0 {}
POPAR7:						is  POPAR8 {build POPAR8;}
POPAR7:						is ctx_mreg=0x7 & POPAR8 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R7 = *[RAM]:4 SP;
	R7 = sext(R7[0,20]);
	SP = SP + 4;
	build POPAR8;
}

POPAR6:						is ctx_count=0 {}
POPAR6:						is  POPAR7 {build POPAR7;}
POPAR6:						is ctx_mreg=0x6 & POPAR7 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R6 = *[RAM]:4 SP;
	R6 = sext(R6[0,20]);
	SP = SP + 4;
	build POPAR7;
}

POPAR5:						is ctx_count=0 {}
POPAR5:						is  POPAR6 {build POPAR6;}
POPAR5:						is ctx_mreg=0x5 & POPAR6 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R5 = *[RAM]:4 SP;
	R5 = sext(R5[0,20]);
	SP = SP + 4;
	build POPAR6;
}

POPAR4:						is ctx_count=0 {}
POPAR4:						is  POPAR5 {build POPAR5;}
POPAR4:						is ctx_mreg=0x4 & POPAR5 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R4 = *[RAM]:4 SP;
	R4 = sext(R4[0,20]);
	SP = SP + 4;
	build POPAR5;
}

POPAR3:						is ctx_count=0 {}
POPAR3:						is  POPAR4 {build POPAR4;}
POPAR3:						is ctx_mreg=0x3 & POPAR4 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	SP = SP + 4;
	build POPAR4;
}

POPAR2:						is ctx_count=0 {}
POPAR2:						is  POPAR3 {build POPAR3;}
POPAR2:						is ctx_mreg=0x2 & POPAR3 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	SR = *[RAM]:4 SP;
	SP = SP + 4;
	build POPAR3;
}

POPAR1:						is ctx_count=0 {}
POPAR1:						is  POPAR2 {build POPAR2;}
POPAR1:						is ctx_mreg=0x1 & POPAR2 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	SP = SP + 4;
	build POPAR2;
}

POPAR0:						is  POPAR1 {build POPAR1;}
POPAR0:						is ctx_mreg=0x0 & POPAR1 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	PC = *[RAM]:4 SP;
	PC = PC & 0xffffe;
	SP = SP + 4;
	build POPAR1;
	goto [PC];
}

POPWR15:					is ctx_count=0 {}
POPWR15:					is ctx_mreg=0xF {
	R15 = zext(*[RAM]:2 SP);
	SP = SP + 2;	
}

POPWR14:					is ctx_count=0 {}
POPWR14:					is  POPWR15 {build POPWR15;}
POPWR14:					is ctx_mreg=0xE & POPWR15 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {	
	R14 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR15;
}

POPWR13:					is ctx_count=0 {}
POPWR13:					is  POPWR14 {build POPWR14;}
POPWR13:					is ctx_mreg=0xD & POPWR14 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R13 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR14;
}

POPWR12:					is ctx_count=0 {}
POPWR12:					is  POPWR13 {build POPWR13;}
POPWR12:					is ctx_mreg=0xC & POPWR13 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R12 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR13;
}

POPWR11:					is ctx_count=0 {}
POPWR11:					is  POPWR12 {build POPWR12;}
POPWR11:					is ctx_mreg=0xB & POPWR12 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R11 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR12;
}

POPWR10:					is ctx_count=0 {}
POPWR10:					is  POPWR11 {build POPWR11;}
POPWR10:					is ctx_mreg=0xA & POPWR11 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R10 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR11;
}

POPWR9:						is ctx_count=0 {}
POPWR9:						is  POPWR10 {build POPWR10;}
POPWR9:						is ctx_mreg=0x9 & POPWR10 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R9 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR10;
}

POPWR8:						is ctx_count=0 {}
POPWR8:						is  POPWR9 {build POPWR9;}
POPWR8:						is ctx_mreg=0x8 & POPWR9 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R8 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR9;
}

POPWR7:						is ctx_count=0 {}
POPWR7:						is  POPWR8 {build POPWR8;}
POPWR7:						is ctx_mreg=0x7 & POPWR8 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R7 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR8;
}

POPWR6:						is ctx_count=0 {}
POPWR6:						is  POPWR7 {build POPWR7;}
POPWR6:						is ctx_mreg=0x6 & POPWR7 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R6 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR7;
}

POPWR5:						is ctx_count=0 {}
POPWR5:						is  POPWR6 {build POPWR6;}
POPWR5:						is ctx_mreg=0x5 & POPWR6 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R5 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR6;
}

POPWR4:						is ctx_count=0 {}
POPWR4:						is  POPWR5 {build POPWR5;}
POPWR4:						is ctx_mreg=0x4 & POPWR5 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	R4 = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR5;
}

POPWR3:						is ctx_count=0 {}
POPWR3:						is  POPWR4 {build POPWR4;}
POPWR3:						is ctx_mreg=0x3 & POPWR4 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	SP = SP + 2;
	build POPWR4;
}

POPWR2:						is ctx_count=0 {}
POPWR2:						is  POPWR3 {build POPWR3;}
POPWR2:						is ctx_mreg=0x2 & POPWR3 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	SR = zext(*[RAM]:2 SP);
	SP = SP + 2;
	build POPWR3;
}

POPWR1:						is ctx_count=0 {}
POPWR1:						is  POPWR2 {build POPWR2;}
POPWR1:						is ctx_mreg=0x1 & POPWR2 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	SP = SP + 2;
	build POPWR2;
}

POPWR0:						is  POPWR1 {build POPWR1;}
POPWR0:						is ctx_mreg=0x0 & POPWR1 [ctx_count=ctx_count-1; ctx_mreg=ctx_mreg+1;] {
	PC = zext(*[RAM]:2 SP) & ~1;
	SP = SP + 2;
	build POPWR1;
	goto [PC];
}

macro adda(dst, src) {
	tmps:$(REG_SIZE) = src;
	tmpd:$(REG_SIZE) = dst;
	tmp:$(REG_SIZE) = src + dst;
	dst = tmp & 0xfffff;
	
	setaddflags(dst,tmps,tmpd);
}

:ADDA SRC20_8_4, DST20_0_4			is ctx_haveext=0 & op16_12_4=0 & insid=0xE & SRC20_8_4 & DST20_0_4 & postStorePC {
	adda(DST20_0_4,SRC20_8_4);
	build postStorePC;
}

# `ADDA SR, <dst>`, verified with hardware but not in spec.
:ADDA "#"^4, DST20_0_4			is ctx_haveext=0 & op16_12_4=0 & insid=0xE & src_8_4=0x2 & DST20_0_4 {
	adda(DST20_0_4, 4:$(REG_SIZE));
}

:INCDA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0xE & src_8_4=0x3 & DST20_0_4 & postStorePC {
	adda(DST20_0_4, 2:$(REG_SIZE));
	build postStorePC;
}

:ADDA "#"^Abs20s, DST20_0_4			is ctx_haveext=0 & op16_12_4=0 & insid=0xA & imm_8_4 & DST20_0_4 & postStorePC ; Abs20s [ctx_ctregdest=imm_8_4;] {
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmps:$(REG_SIZE) = sext(Abs20s);
	tmp:$(REG_SIZE) = tmpd + tmps;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,tmps,tmpd);
	build postStorePC;
}

:CMPA SRC20_8_4, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insid=0xD & SRC20_8_4 & DST20_0_4 {
	tmp:$(REG_SIZE) = DST20_0_4 - SRC20_8_4;
	tmpd:$(REG_SIZE) = sext(tmp[0,20]);
	setsubflags(tmpd,SRC20_8_4,DST20_0_4);
}

:CMPA "#"^Abs20s, DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0x9 & imm_8_4 & DST20_0_4 ; Abs20s [ctx_ctregdest=imm_8_4;] {
	tmps:$(REG_SIZE) = sext(Abs20s);
	tmp:$(REG_SIZE) = DST20_0_4 - tmps;
	tmpd:$(REG_SIZE) = sext(tmp[0,20]);
	setsubflags(tmpd,tmps,DST20_0_4);
}

:MOVA "@"^SRC20_8_4, DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0x0 & SRC20_8_4 & DST20_0_4 {
	DST20_0_4 = *[RAM]:$(REG_SIZE) SRC20_8_4 & ~1;
	DST20_0_4 = sext(DST20_0_4[0,20]);
}

:MOVA "@"^SRC20_8_4^"+", DST20_0_4			is ctx_haveext=0 & op16_12_4=0 & insid=0x1 & SRC20_8_4 & DST20_0_4 {
	local tmp = *[RAM]:$(REG_SIZE) SRC20_8_4 & ~1;
	SRC20_8_4 = SRC20_8_4 + 4;
	DST20_0_4 = zext(tmp[0,20]);
}

:MOVA "&"^Abs20, DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0x2 & imm_8_4 & DST20_0_4 ; Abs20 [ctx_ctregdest=imm_8_4;] {
	tmp:$(REG_SIZE) = zext(Abs20) & ~1;
	DST20_0_4 = *[RAM]:$(REG_SIZE) tmp;
	DST20_0_4 = sext(DST20_0_4[0,20]);
}

:MOVA imms_0_16^"("^SRC20_8_4^")", DST20_0_4		is ctx_haveext=0 & op16_12_4=0 & insid=0x3 & SRC20_8_4 & DST20_0_4 ; imms_0_16 {
	tmp:$(REG_SIZE) = SRC20_8_4 + sext(imms_0_16:2) & ~1;
	DST20_0_4 = *[RAM]:$(REG_SIZE) tmp;
	DST20_0_4 = sext(DST20_0_4[0,20]);
}

:MOVA imms_0_16^"(PC)", DST20_0_4		is ctx_haveext=0 & op16_12_4=0 & src_8_4=0 & insid=0x3 & SRC20_8_4 & DST20_0_4 ; imms_0_16 {
	tmp:$(REG_SIZE) = inst_start + 2 + sext(imms_0_16:2);
	DST20_0_4 = *[RAM]:$(REG_SIZE) tmp;
	DST20_0_4 = sext(DST20_0_4[0,20]);
}

:MOVA SRC20_8_4, "&"^Abs20				is ctx_haveext=0 & op16_12_4=0 & insid=0x6 & imm_0_4 & SRC20_8_4 ; Abs20 [ctx_ctregdest=imm_0_4;] {
	tmp:$(REG_SIZE) = zext(Abs20) & ~1;
	*[RAM]:$(REG_SIZE) tmp = SRC20_8_4 & 0xFFFFF;
}

:MOVA SRC20_8_4, imms_0_16^"("^DST20_0_4^")"		is ctx_haveext=0 & op16_12_4=0 & insid=0x7 & SRC20_8_4 & DST20_0_4 ; imms_0_16 {
	tmp:$(REG_SIZE) = DST20_0_4 + sext(imms_0_16:2) & ~1;
	*[RAM]:$(REG_SIZE) tmp = SRC20_8_4 & 0xFFFFF;
}

:MOVA "#"^Abs20s, DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0x8 & imm_8_4 & DST20_0_4 ; Abs20s [ctx_ctregdest=imm_8_4;] {
	DST20_0_4 = sext(Abs20s) & 0xfffff;
}

:MOVA SRC20_8_4, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insid=0xC & SRC20_8_4 & DST20_0_4 {
	DST20_0_4 = SRC20_8_4;
}

:CLRA DST20_0_4						is ctx_haveext=0 & op16_12_4=0 & insid=0xC & src_8_4=0x3 & DST20_0_4 & postStorePC {
	DST20_0_4 = 0:$(REG_SIZE);
	build postStorePC;
}

macro suba(dst, src) {
	tmps:$(REG_SIZE) = src;
	tmpd:$(REG_SIZE) = dst;
	tmp:$(REG_SIZE) = dst - src;
	dst = sext(tmp[0,20]);
	
	setsubflags(dst,tmps,tmpd);
}

:SUBA SRC20_8_4, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insid=0xF & SRC20_8_4 & DST20_0_4 & postStorePC {
	suba(DST20_0_4, SRC20_8_4);
	build postStorePC;
}

:SUBA "#"^Abs20s, DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0xB & imm_8_4 & DST20_0_4 & postStorePC ; Abs20s [ctx_ctregdest=imm_8_4;] {
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmps:$(REG_SIZE) = sext(Abs20s);
	tmp:$(REG_SIZE) = DST20_0_4 - tmps;
	DST20_0_4 = sext(tmp[0,20]);
	
	setsubflags(DST20_0_4,tmps,tmpd);
	build postStorePC;
}

##################
#
# Special cases of renamed MOVA where PC is involved

# This first case doesn't make any sense, but I saw it in the cunits.  The instruction word is all 0.
# The toolchain comes back with a 'beq', but that doesn't make sense either as there is no beq instruction
# anywhere in the manual. One toolchain allows BRA @PC, another one doesn't. I did find reference to gvv
# assembler extension regarding @rN being treated as 0(rN) and vice versa. That would effectively turn
# this into a branch to following instruction. What I think may be happening is a compiler bug where in
# some cases an immediate gets output even though the constant generator is used.
:BRA "@"^SRC20_8_4 					is ctx_haveext=0 & op16_12_4=0 & insid=0x0 & SRC20_8_4 & src_8_4=0 & dest_0_4=0x0 {
}

:BRA "@"^SRC20_8_4 					is ctx_haveext=0 & op16_12_4=0 & insid=0x0 & SRC20_8_4 & dest_0_4=0x0 {
	PC = *[RAM]:$(REG_SIZE) SRC20_8_4 & 0xffffe;
	goto [PC];
}

:BRA "@"^SRC20_8_4^"+" 				is ctx_haveext=0 & op16_12_4=0 & insid=0x1 & SRC20_8_4 & dest_0_4=0x0 {
	local tmp = *[RAM]:$(REG_SIZE) SRC20_8_4 & 0xffffe;
	SRC20_8_4 = SRC20_8_4 + 4;
	goto [tmp];
}

:BRA "&"^Abs20						is ctx_haveext=0 & op16_12_4=0 & insid=0x2 & imm_8_4 & dest_0_4=0x0; Abs20 [ctx_ctregdest=imm_8_4;] {
	tmp:$(REG_SIZE) = zext(Abs20);
	PC = *[RAM]:$(REG_SIZE) tmp & 0xffffe;
	goto [PC];
}

:BRA imms_0_16^"("^SRC20_8_4^")"		is ctx_haveext=0 & op16_12_4=0 & insid=0x3 & SRC20_8_4 & dest_0_4=0x0; imms_0_16 {
	tmp:$(REG_SIZE) = SRC20_8_4 + sext(imms_0_16:2);
	PC = *[RAM]:$(REG_SIZE) tmp & 0xffffe;
	goto [PC];
}

:BRA imms_0_16^"(PC)"		is ctx_haveext=0 & op16_12_4=0 & src_8_4=0 & insid=0x3 & SRC20_8_4 & dest_0_4=0x0; imms_0_16 {
	tmp:$(REG_SIZE) = inst_start + 2 + sext(imms_0_16:2);
	PC = *[RAM]:$(REG_SIZE) tmp & 0xffffe;
	goto [PC];
}

:BRA "#"^Abs20add					is ctx_haveext=0 & op16_12_4=0 & insid=0x8 & imm_8_4 & dest_0_4=0x0; Abs20add [ctx_ctregdest=imm_8_4;] {
#	PC = Abs20add & 0xffffe;
	goto Abs20add;
}

:BRA SRC20_8_4					is ctx_haveext=0 & op16_12_4=0 & insid=0xC & SRC20_8_4 & dest_0_4=0x0 {
	PC = SRC20_8_4 & 0xffffe;
	goto [PC];
}

:RETA "@"^SRC20_8_4^"+"			is ctx_haveext=0 & op16_12_4=0 & insid=0x1 & SRC20_8_4 & src_8_4=0x1 & dest_0_4=0x0 {
	PC = *[RAM]:$(REG_SIZE) SRC20_8_4 & 0xffffe;
	SP = SP + 4;
	return [PC];
}
#
################
#
# Special cases of SUBA/ADDA/CMPA/MOVA

# `SUBA SR, <dst>`, verified with hardware but not in spec.
:SUBA "#"^4, DST20_0_4			is ctx_haveext=0 & op16_12_4=0 & insid=0xF & src_8_4=0x2 & DST20_0_4 {
	suba(DST20_0_4, 4:$(REG_SIZE));
}

:DECDA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0xF & src_8_4=0x3 & DST20_0_4 {
	suba(DST20_0_4, 2:$(REG_SIZE));
}

:DECDA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0xB & imm_8_4=0x0 & DST20_0_4 ; imm_0_16=0x0002  {
	suba(DST20_0_4, 2:$(REG_SIZE));
}

:INCDA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0xA & imm_8_4=0x0 & DST20_0_4 ; imm_0_16=0x0002  {
	adda(DST20_0_4, 2:$(REG_SIZE));
}

:TSTA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0xD & src_8_4=0x3 & DST20_0_4 {
	$(CARRY) = 1;
	$(OVERFLOW) = 0;
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0);
}

:TSTA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0x9 & imm_8_4=0x0 & DST20_0_4 ; imm_0_16=0x0000 {
	$(CARRY) = 1;
	$(OVERFLOW) = 0;
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0);
}

:CLRA DST20_0_4				is ctx_haveext=0 & op16_12_4=0 & insid=0x8 & imm_8_4=0 & DST20_0_4 ; imm_0_16=0  {
	DST20_0_4 = 0;
}

#
################
#
# Other 20 bit address instructions
:CALLA DST20_0_4							is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0x4 & DST20_0_4 {
	PC = DST20_0_4 & ~1;
	SP = SP - 0x4;
	*:4 SP = inst_next;
	call [PC];
}

:CALLA imms_0_16^"("^DST20_0_4^")"		is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0x5 & DST20_0_4 ; imms_0_16 {
	tmp:$(REG_SIZE) = DST20_0_4 + sext(imms_0_16:2);
	PC = *[RAM]:$(REG_SIZE) tmp;
	PC = PC & 0xffffe;
	SP = SP - 0x4;
	*:4 SP = inst_next;
	call [PC];
}

:CALLA imms_0_16^"(PC)"		is ctx_haveext=0 & op16_8_8=0x13 & dest_0_4=0 & op16_4_4=0x5 & DST20_0_4 ; imms_0_16 {
	tmp:$(REG_SIZE) = inst_start + 2 + sext(imms_0_16:2);
	PC = *[RAM]:$(REG_SIZE) tmp;
	PC = PC & 0xffffe;
	SP = SP - 0x4;
	*:4 SP = inst_next;
	call [PC];
}

:CALLA "@"^DST20_0_4						is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0x6 & DST20_0_4 {
	PC = *[RAM]:$(REG_SIZE) DST20_0_4;
	PC = PC & 0xffffe;
	SP = SP - 0x4;
	*:4 SP = inst_next;
	call [PC];
}

:CALLA "@"^DST20_0_4^"+"					is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0x7 & DST20_0_4 {
	PC = *[RAM]:$(REG_SIZE) DST20_0_4;
	PC = PC & 0xffffe;
	SP = SP - 0x4;
	*:4 SP = inst_next;
	DST20_0_4 = DST20_0_4 + 4;
	call [PC];
}

:CALLA "&"^Abs20						is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0x8 & imm_0_4; Abs20 [ctx_ctregdest=imm_0_4;] {
	SP = SP - 0x4;
	*:4 SP = inst_next;
	tmp:$(REG_SIZE) = zext(Abs20);
	PC = *[RAM]:$(REG_SIZE) tmp;
	PC = PC & 0xffffe;
	call [PC];
}

:CALLA imms_0_16^"(PC)"					is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0x9 ; imms_0_16 {
	tmp:$(REG_SIZE) = inst_start + sext(imms_0_16:2);
	PC = *[RAM]:$(REG_SIZE) tmp;
	PC = PC & 0xffffe;
	SP = SP - 0x4;
	*:4 SP = inst_next;
	call [PC];
}

:CALLA "#"^Abs20add						is ctx_haveext=0 & op16_8_8=0x13 & op16_4_4=0xB & imm_0_4; Abs20add [ctx_ctregdest = imm_0_4;] {
	SP = SP - 0x4;
	*:4 SP = inst_next;
	PC = &Abs20add;
	call Abs20add;
}


:PUSHM.A IMM4,dest_0_4					is ctx_haveext=0 & op16_8_8=0x14 & IMM4 & dest_0_4 & imm_4_4 & PUSHAR15 [ctx_count=imm_4_4+1; ctx_mreg=dest_0_4;] {
	build IMM4;
	build PUSHAR15;
}

:PUSHM.W IMM4,dest_0_4					is ctx_haveext=0 & op16_8_8=0x15 & IMM4 & dest_0_4 & imm_4_4 & PUSHWR15 [ctx_count=imm_4_4+1; ctx_mreg=dest_0_4;] {
	build IMM4;
	build PUSHWR15;
}

:POPM.A IMM4,ctx_popreg					is ctx_haveext=0 & op16_8_8=0x16 & IMM4 & ctx_popreg & imm_0_4 & imm_4_4 & POPAR0 [ctx_popreg_set=imm_0_4+imm_4_4; ctx_count=imm_4_4+1; ctx_mreg=imm_0_4;] {
	build IMM4;
	build POPAR0;
}

:POPM.W IMM4,ctx_popreg					is ctx_haveext=0 & op16_8_8=0x17 & IMM4 & ctx_popreg & imm_0_4 & imm_4_4 & POPWR0 [ctx_popreg_set=imm_0_4+imm_4_4; ctx_count=imm_4_4+1; ctx_mreg=imm_0_4;] {
	build IMM4;
	build POPWR0;
}

:RRCM.A	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x04 & NUM2 & DST20_0_4 & rrn {
	tmph:$(REG_SIZE) = (DST20_0_4 >> rrn) & 0x1;
	tmpc:$(REG_SIZE) = zext($(CARRY));
	tmpc = tmpc << (20-NUM2);
	DST20_0_4 = (DST20_0_4 >> NUM2) | (DST20_0_4 << (20-rrn));
	DST20_0_4 = ((DST20_0_4 & (~tmpc)) | tmpc) & 0xFFFFF;
	$(CARRY) = (tmph != 0);
	$(OVERFLOW) = 0;
	$(SIGN) = (DST20_0_4[19,1] != 0);
	$(ZERO) = (DST20_0_4 == 0);
}

:RRAM.A	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x14 & NUM2 & DST20_0_4 & rrn {
	local tmp:$(REG_SIZE) = DST20_0_4 << 12 s>> 12; # Rscr
	tmph:$(REG_SIZE) = (tmp >> rrn) & 0x1;
	DST20_0_4 = (tmp s>> NUM2) & 0xfffff;
	$(CARRY) = (tmph != 0);
	$(OVERFLOW) = 0;
	$(SIGN) = (DST20_0_4[19,1] != 0);
	$(ZERO) = (DST20_0_4 == 0);
}

:RLAM.A	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x24 & NUM2 & DST20_0_4 {
	tmph:$(REG_SIZE) = (DST20_0_4 >> (20 - NUM2)) & 0x1;
	DST20_0_4 = (DST20_0_4 << NUM2);
	DST20_0_4 = sext(DST20_0_4[0,20]);
	$(CARRY) = (tmph != 0);
	$(SIGN) = (DST20_0_4[19,1] != 0);
	$(ZERO) = (DST20_0_4 == 0);
}

:RRUM.A	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x34 & NUM2 & DST20_0_4 & rrn {
	tmph:$(REG_SIZE) = (DST20_0_4 >> rrn) & 0x1;
	DST20_0_4 = (DST20_0_4 >> NUM2) & 0xFFFFF;
	$(CARRY) = (tmph != 0);
	$(OVERFLOW) = 0;
	$(SIGN) = 0;
	$(ZERO) = (DST20_0_4 == 0);
}

:RRCM.W	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x05 & NUM2 & DST20_0_4 & rrn {
	tmpr:2 = DST20_0_4:2;
	tmph:2 = (tmpr >> rrn) & 0x1;
	tmpc:2 = zext($(CARRY));
	tmpc = tmpc << (16-NUM2);
	tmpr = (tmpr >> NUM2) | (tmpr << (16-rrn));
	DST20_0_4 = zext((tmpr & (~tmpc)) | tmpc);
	$(CARRY) = (tmph != 0);
	$(OVERFLOW) = 0;
	$(SIGN) = (DST20_0_4[15,1] != 0);
	$(ZERO) = (DST20_0_4 == 0);
}

:RRAM.W	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x15 & NUM2 & DST20_0_4 & rrn {
	tmpr:2 = DST20_0_4:2;
	tmph:$(REG_SIZE) = (DST20_0_4 >> rrn) & 0x1;
	DST20_0_4 = zext(tmpr s>> NUM2);
	$(CARRY) = (tmph != 0);
	$(OVERFLOW) = 0;
	$(SIGN) = (DST20_0_4[15,1] != 0);
	$(ZERO) = (DST20_0_4 == 0);
}

:RLAM.W	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x25 & NUM2 & DST20_0_4 {
	tmph:$(REG_SIZE) = (DST20_0_4 >> (16 - NUM2)) & 0x1;
	DST20_0_4 = (DST20_0_4 << NUM2);
	DST20_0_4 = zext(DST20_0_4:2);
	$(CARRY) = (tmph != 0);
	$(SIGN) = (DST20_0_4[15,1] != 0);
	$(ZERO) = (DST20_0_4 == 0);
}

:RRUM.W	NUM2, DST20_0_4					is ctx_haveext=0 & op16_12_4=0 & insidbig=0x35 & NUM2 & DST20_0_4 & rrn {
	tmpr:2 = DST20_0_4:2;
	tmph:2 = (tmpr >> rrn) & 0x1;
	DST20_0_4 = zext(tmpr >> NUM2);
	$(CARRY) = (tmph != 0);
	$(OVERFLOW) = 0;
	$(SIGN) = 0;
	$(ZERO) = (DST20_0_4 == 0);
}

macro bzero(full, byte)
{
	ztmp:1 = byte;
	full = 0;
	byte = ztmp;
}

macro wzero(full, word)
{
	ztmp:2 = word;
	full = 0;
	word = ztmp;
}

##############################
#
# Extention word instructions
#
# The base msp430 handles all the addressing modes in subtables.
# The reg/reg mode for the 'X' instruction has repetition so we
# break that mode out separately. Because of that, we need to use
# separate subtables for the address modes since the base ones
# will hit on the reg/reg mode.
#
# There are also two groups for the extended instructions:
# double and single operand. The double operand ones come
# first. A lot of the singles are covered under the address
# extensions as they don't have the extension word.
#############################
#
# Double Operand
#
#############################
# Repeat enabled
:ADCX.B DST8_0_4							is ctx_haveext=4 & op16_12_4=0x6 & src16_8_4=0x3 & as=0x0 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	tmp_carry:1 = carry(DST8_0_4,$(CARRY));		 #C Flag
 	$(OVERFLOW) = scarry(DST8_0_4,$(CARRY)); #V Flag
 	# Operation...
	DST8_0_4 = DST8_0_4 + $(CARRY);
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADCX.W DST16_0_4							is ctx_haveext=4 & op16_12_4=0x6 & src16_8_4=0x3 & as=0x0 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	tmp_carry:1 = carry(DST16_0_4,zext($(CARRY)));		 #C Flag
 	$(OVERFLOW) = scarry(DST16_0_4,zext($(CARRY))); #V Flag
 	# Operation...
	DST16_0_4 = DST16_0_4 + zext($(CARRY));
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADCX.A DST20_0_4							is ctx_haveext=4 & op16_12_4=0x6 & src16_8_4=0x3 & as=0x0 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmpc:$(REG_SIZE) = zext($(CARRY));
	tmp:$(REG_SIZE) = tmpc + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,tmpc,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADDX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0x5 & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = carry(XRSRC_B_AS, DST8_0_4); 	 	# C Flag
	$(OVERFLOW) = scarry(XRSRC_B_AS, DST8_0_4); 	# V Flag
	# Operation...
	DST8_0_4 = XRSRC_B_AS + DST8_0_4;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADDX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0x5 & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = carry(XRSRC_W_AS, DST16_0_4); 	 	# C Flag
	$(OVERFLOW) = scarry(XRSRC_W_AS, DST16_0_4); 	# V Flag
	# Operation...
	DST16_0_4 = XRSRC_W_AS + DST16_0_4;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADDX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0x5 & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = XRSRC_A_AS + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,XRSRC_A_AS,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADDCX.B XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0x6 & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	tmp_carry:1 = (carry(XRSRC_B_AS, $(CARRY)) || carry(DST8_0_4,XRSRC_B_AS + $(CARRY)));		 #C Flag
 	$(OVERFLOW) = (scarry(XRSRC_B_AS, $(CARRY)) || scarry(DST8_0_4,XRSRC_B_AS + $(CARRY))); #V Flag
 	# Operation...
	DST8_0_4 = XRSRC_B_AS + DST8_0_4 + $(CARRY);
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADDCX.W XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0x6 & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	tmp_carry:1 = (carry(XRSRC_W_AS,zext($(CARRY))) || carry(DST16_0_4,XRSRC_W_AS + zext($(CARRY))));		 #C Flag
 	$(OVERFLOW) = (scarry(XRSRC_W_AS,zext($(CARRY))) || scarry(DST16_0_4,XRSRC_W_AS + zext($(CARRY)))); #V Flag
 	# Operation...
	DST16_0_4 = XRSRC_W_AS + DST16_0_4 + zext($(CARRY));
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ADDCX.A XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0x6 & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmps:$(REG_SIZE) = XRSRC_A_AS + zext($(CARRY));
	tmp:$(REG_SIZE) = tmps + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,tmps,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ANDX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0xF & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 & XRSRC_B_AS;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST8_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ANDX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0xF & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 & XRSRC_W_AS;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST16_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:ANDX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0xF & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	DST20_0_4 = DST20_0_4 & XRSRC_A_AS;
	DST20_0_4 = sext(DST20_0_4[0,20]);
	# Result Flags...
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST20_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BICX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0xC & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	DST8_0_4 = (~XRSRC_B_AS) & DST8_0_4;
	bzero(reg_Direct16_0_4,DST8_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BICX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0xC & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	DST16_0_4 = (~XRSRC_W_AS) & DST16_0_4;
	wzero(reg_Direct16_0_4,DST16_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BICX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0xC & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	DST20_0_4 = (~XRSRC_A_AS) & DST20_0_4;
	DST20_0_4 = zext(DST20_0_4[0,20]);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BISX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0xD & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	DST8_0_4 = XRSRC_B_AS | DST8_0_4;
	bzero(reg_Direct16_0_4,DST8_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BISX.W	XRSRC_W_AS, DST16_0_4				is ctx_haveext=4 & op16_12_4=0xD & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	DST16_0_4 = XRSRC_W_AS | DST16_0_4;
	wzero(reg_Direct16_0_4,DST16_0_4);
	#Status bits are not affected
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BISX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0xD & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	DST20_0_4 = XRSRC_A_AS | DST20_0_4;
	#Status bits are not affected
	DST20_0_4 = sext(DST20_0_4[0,20]);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BITX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0xB & bow=1 & ctx_al=1 & postIncrement & XRSRC_B_AS & DST8_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	result:1 = DST8_0_4 & XRSRC_B_AS;
	# Result Flags...
	$(CARRY) = (result != 0x0);			# C Flag
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BITX.W	XRSRC_W_AS, DST16_0_4				is ctx_haveext=4 & op16_12_4=0xB & bow=0 & ctx_al=1 & postIncrement & XRSRC_W_AS & DST16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	result:2 = DST16_0_4 & XRSRC_W_AS;
	# Result Flags...
	$(CARRY) = (result != 0x0);			# C Flag
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:BITX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0xB & bow=1 & ctx_al=0 & postIncrement & XRSRC_A_AS & DST20_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	result:$(REG_SIZE) = DST20_0_4 & XRSRC_A_AS;
	# Result Flags...
	result = sext(result[0,20]);
	$(CARRY) = (result != 0x0);			# C Flag
	$(SIGN) = result[19, 1] == 1;
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:CLRX.B	DST8_0_4						is ctx_haveext=4 & op16_12_4=0x4 & src16_8_4=0x3 & as=0x0 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	DST8_0_4 = 0;
	bzero(reg_Direct16_0_4,DST8_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:CLRX.W	DST16_0_4						is ctx_haveext=4 & op16_12_4=0x4 & src16_8_4=0x3 & as=0x0 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	DST16_0_4 = 0;
	wzero(reg_Direct16_0_4,DST16_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:CLRX.A	DST20_0_4						is ctx_haveext=4 & op16_12_4=0x4 & src16_8_4=0x3 & as=0x0 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 {
	<top>
	DST20_0_4 = 0;
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:CMPX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0x9 & bow=1 & ctx_al=1 & postIncrement & XRSRC_B_AS & DST8_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (XRSRC_B_AS <= DST8_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST8_0_4, XRSRC_B_AS);	# V Flag
	# Operation...
	result:1 = (DST8_0_4 - XRSRC_B_AS);
	# Result Flags...
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:CMPX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0x9 & bow=0 & ctx_al=1 & postIncrement & XRSRC_W_AS & DST16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (XRSRC_W_AS <= DST16_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST16_0_4, XRSRC_W_AS);	# V Flag
	# Operation...
	result:2 = (DST16_0_4 - XRSRC_W_AS);
	# Result Flags...
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:CMPX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0x9 & bow=1 & ctx_al=0 & postIncrement & XRSRC_A_AS & DST20_0_4 {
	<top>
	tmp:$(REG_SIZE) = DST20_0_4 - XRSRC_A_AS;
	tmpd:$(REG_SIZE) = sext(tmp[0,20]);
	setsubflags(tmpd,XRSRC_A_AS,DST20_0_4);
	build postIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

define pcodeop bcd_add;

:DADCX.B DST8_0_4						is ctx_haveext=4 & op16_12_4=0xA & src16_8_4=0x3 & as=0x0 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	local temp:4 = zext(DST8_0_4);
	DST8_0_4 = bcd_add(temp, $(CARRY));
	$(CARRY) = temp >= 0x99;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);		# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);		# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DADCX.W DST16_0_4						is ctx_haveext=4 & op16_12_4=0xA & src16_8_4=0x3 & as=0x0 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	local temp:4 = zext(DST16_0_4);
	DST16_0_4 = bcd_add(temp, $(CARRY));
	$(CARRY) = temp >= 0x9999;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DADCX.A DST20_0_4						is ctx_haveext=4 & op16_12_4=0xA & src16_8_4=0x3 & as=0x0 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	local temp:4 = zext(DST20_0_4);
	DST20_0_4 = bcd_add(temp, $(CARRY));
	$(CARRY) = temp >= 0x99999;
	DST20_0_4 = sext(DST20_0_4[0,20]);
	# Result Flags...
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DADDX.B XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0xA & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	local temp_src:4 = zext(XRSRC_B_AS);
	local temp_dest:4 = zext(DST8_0_4);
	local temp_carry:4 = zext($(CARRY));
	DST8_0_4 = bcd_add(temp_src,temp_dest, temp_carry);
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);		# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);		# Z Flag
	$(CARRY) = (temp_src + temp_dest + temp_carry) > 0x99;
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DADDX.W XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0xA & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	local temp_src:4 = zext(XRSRC_W_AS);
	local temp_dest:4 = zext(DST16_0_4);
	local temp_carry:4 = zext($(CARRY));
	DST16_0_4 = bcd_add(temp_src, temp_dest, temp_carry);
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	$(CARRY) = (temp_src + temp_dest + temp_carry) > 0x9999;
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DADDX.A XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0xA & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	local temp_src:4 = zext(XRSRC_A_AS);
	local temp_dest:4 = zext(DST20_0_4);
	local temp_carry:4 = zext($(CARRY));
	DST20_0_4 = bcd_add(temp_src, temp_dest, temp_carry);
	DST20_0_4 = sext(DST20_0_4[0,20]);
	# Result Flags...
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0x0);			# Z Flag
	$(CARRY) = (temp_src + temp_dest + temp_carry) > 0x99999;
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DECX.B	DST8_0_4				is ctx_haveext=4 & op16_12_4=0x8 & src16_8_4=0x3 & as=0x1 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (1 <= DST8_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST8_0_4, 1:1);									# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 - 1;		
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DECX.W	DST16_0_4				is ctx_haveext=4 & op16_12_4=0x8 & src16_8_4=0x3 & as=0x1 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (1 <= DST16_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST16_0_4, 1:2);								# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 - 1;		
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DECX.A	DST20_0_4				is ctx_haveext=4 & op16_12_4=0x8 & src16_8_4=0x3 & as=0x1 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = DST20_0_4 - 1;
	DST20_0_4 = sext(tmp[0,20]);
	
	setsubflags(DST20_0_4,1:$(REG_SIZE),tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DECDX.B DST8_0_4				is ctx_haveext=4 & op16_12_4=0x8 & src16_8_4=0x3 & as=0x2 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (2 <= DST8_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST8_0_4, 2:1);									# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 - 2;		
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DECDX.W DST16_0_4				is ctx_haveext=4 & op16_12_4=0x8 & src16_8_4=0x3 & as=0x2 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (2 <= DST16_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST16_0_4, 2:2);								# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 - 2;		
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:DECDX.A DST20_0_4				is ctx_haveext=4 & op16_12_4=0x8 & src16_8_4=0x3 & as=0x2 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = DST20_0_4 - 2;
	DST20_0_4 = sext(tmp[0,20]);
	
	setsubflags(DST20_0_4,2:$(REG_SIZE),tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INCX.B	DST8_0_4						is ctx_haveext=4 & op16_12_4=0x5 & src16_8_4=0x3 & as=0x1 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = carry(DST8_0_4,1); 	 	# C Flag
	$(OVERFLOW) = scarry(DST8_0_4,1); 	# V Flag
	# Operation...
	DST8_0_4 = 1 + DST8_0_4;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INCX.W	DST16_0_4						is ctx_haveext=4 & op16_12_4=0x5 & src16_8_4=0x3 & as=0x1 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = carry(DST16_0_4,1); 	 	# C Flag
	$(OVERFLOW) = scarry(DST16_0_4,1); 	# V Flag
	# Operation...
	DST16_0_4 = 1:2 + DST16_0_4;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INCX.A	DST20_0_4						is ctx_haveext=4 & op16_12_4=0x5 & src16_8_4=0x3 & as=0x1 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = 1 + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,1:$(REG_SIZE),tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INCDX.B DST8_0_4						is ctx_haveext=4 & op16_12_4=0x5 & src16_8_4=0x3 & as=0x2 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = carry(DST8_0_4,2); 	 	# C Flag
	$(OVERFLOW) = scarry(DST8_0_4,2); 	# V Flag
	# Operation...
	DST8_0_4 = 2 + DST8_0_4;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INCDX.W DST16_0_4						is ctx_haveext=4 & op16_12_4=0x5 & src16_8_4=0x3 & as=0x2 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = carry(DST16_0_4,2); 	 	# C Flag
	$(OVERFLOW) = scarry(DST16_0_4,2); 	# V Flag
	# Operation...
	DST16_0_4 = 2:2 + DST16_0_4;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INCDX.A DST20_0_4						is ctx_haveext=4 & op16_12_4=0x5 & src16_8_4=0x3 & as=0x2 & bow=1 & ctx_al=0 & postIncrementStore & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = 2 + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,2:$(REG_SIZE),tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INVX.B	DST8_0_4				is ctx_haveext=4 & op16_12_4=0xE & src16_8_4=0x3 & as=0x3 & bow=1 & ctx_al=1 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = DST8_0_4 s< 0x0;	# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 ^ -1;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST8_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INVX.W	DST16_0_4			is ctx_haveext=4 & op16_12_4=0xE & src16_8_4=0x3 & as=0x3 & bow=0 & ctx_al=1 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = DST16_0_4 s< 0x0 ;	# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 ^ -1;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST16_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:INVX.A	DST20_0_4				is ctx_haveext=4 & op16_12_4=0xE & src16_8_4=0x3 & as=0x3 & bow=1 & ctx_al=0 & postIncrementStore &  DST20_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = DST20_0_4 s< 0x0;	# V Flag
	# Operation...
	DST20_0_4 = DST20_0_4 ^ -1;
	DST20_0_4 = sext(DST20_0_4[0,20]);
	# Result Flags...
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST20_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:MOVX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0x4 & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	DST8_0_4 = XRSRC_B_AS;
	bzero(reg_Direct16_0_4,DST8_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:MOVX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0x4 & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	DST16_0_4 = XRSRC_W_AS;
	wzero(reg_Direct16_0_4,DST16_0_4);
	#Status bits are not affected
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:MOVX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0x4 & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	DST20_0_4 = XRSRC_A_AS & 0xfffff;
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:POPX.B	DST8_0_4							is ctx_haveext=4 & op16_12_4=0x4 & src16_8_4=0x1 & as=0x3 & bow=1 & ctx_al=1 & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	DST8_0_4 = *:1 SP;
	bzero(reg_Direct16_0_4,DST8_0_4);
	SP = SP + 0x2;
	#Status bits are not affected
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:POPX.W	DST16_0_4							is ctx_haveext=4 & op16_12_4=0x4 & src16_8_4=0x1 & as=0x3 & bow=0 & ctx_al=1 & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	DST16_0_4 = *:2 SP;
	wzero(reg_Direct16_0_4,DST16_0_4);
	SP = SP + 0x2;
	#Status bits are not affected
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:POPX.A	DST20_0_4							is ctx_haveext=4 & op16_12_4=0x4 & src16_8_4=0x1 & as=0x3 & bow=1 & ctx_al=0 & DST20_0_4 {
	<top>
	DST20_0_4 = *:4 SP;
	SP = SP + 0x4;
	DST20_0_4 = sext(DST20_0_4[0,20]);
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RLAX.B	DST8_0_4						is ctx_haveext=4 & op16_12_4=0x5 & bow=1 & ctx_al=1 & src_Direct16_8_4=dest_Direct16_0_4 & DST8_0_4 & reg_Direct16_0_4 & postStorePC {
	<top>
	# Operation Flags...
	$(CARRY) = carry(DST8_0_4, DST8_0_4); 	 	# C Flag
	$(OVERFLOW) = scarry(DST8_0_4, DST8_0_4); 	# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 + DST8_0_4;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postStorePC;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RLAX.W	DST16_0_4						is ctx_haveext=4 & op16_12_4=0x5 & bow=0 & ctx_al=1 & src_Direct16_8_4=dest_Direct16_0_4 & DST16_0_4 & reg_Direct16_0_4 & postStorePC {
	<top>
	# Operation Flags...
	$(CARRY) = carry(DST16_0_4, DST16_0_4); 	 	# C Flag
	$(OVERFLOW) = scarry(DST16_0_4, DST16_0_4); 	# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 + DST16_0_4;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postStorePC;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RLAX.A	DST20_0_4						is ctx_haveext=4 & op16_12_4=0x5 & bow=1 & src_Direct16_8_4=dest_Direct16_0_4 & ctx_al=0 & postStorePC & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = DST20_0_4 + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,tmpd,tmpd);
	build postStorePC;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RLCX.B DST8_0_4						is ctx_haveext=4 & op16_12_4=0x6 & bow=1 & ctx_al=1 & src_Direct16_8_4=dest_Direct16_0_4 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	tmp_carry:1 = (carry(DST8_0_4, $(CARRY)) || carry(DST8_0_4,DST8_0_4 + $(CARRY)));		 #C Flag
 	$(OVERFLOW) = (scarry(DST8_0_4, $(CARRY)) || scarry(DST8_0_4,DST8_0_4 + $(CARRY))); #V Flag
 	# Operation...
	DST8_0_4 = DST8_0_4 + DST8_0_4 + $(CARRY);
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RLCX.W DST16_0_4						is ctx_haveext=4 & op16_12_4=0x6 & bow=0 & ctx_al=1 & src_Direct16_8_4=dest_Direct16_0_4 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	tmp_carry:1 = (carry(DST16_0_4,zext($(CARRY))) || carry(DST16_0_4,DST16_0_4 + zext($(CARRY))));		 #C Flag
 	$(OVERFLOW) = (scarry(DST16_0_4,zext($(CARRY))) || scarry(DST16_0_4,DST16_0_4 + zext($(CARRY)))); #V Flag
 	# Operation...
	DST16_0_4 = DST16_0_4 + DST16_0_4 + zext($(CARRY));
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RLCX.A DST20_0_4						is ctx_haveext=4 & op16_12_4=0x6 & bow=1 & ctx_al=0 & src_Direct16_8_4=dest_Direct16_0_4 & postIncrementStore & XRSRC_A_AS & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmps:$(REG_SIZE) = DST20_0_4 + zext($(CARRY));
	tmp:$(REG_SIZE) = tmps + DST20_0_4;
	DST20_0_4 = sext(tmp[0,20]);
	
	setaddflags(DST20_0_4,tmps,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SBCX.B DST8_0_4				is ctx_haveext=4 & op16_12_4=0x7 & bow=1 & ctx_al=1 & src16_8_4=0x3 & as=0x0 & postIncrementStore & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	brw:1 = 1 - $(CARRY);
	$(CARRY) = (brw <= DST8_0_4);             # Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST8_0_4, brw);	
	# Operation...
	DST8_0_4 = DST8_0_4 - brw;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SBCX.W DST16_0_4				is ctx_haveext=4 & op16_12_4=0x7 & bow=0 & ctx_al=1 & src16_8_4=0x3 & as=0x0 & postIncrementStore & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	brw:2 = 1 - zext( $(CARRY) );
	$(CARRY) = (brw  <= DST16_0_4);		# Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST16_0_4, brw);	
	# Operation...
	DST16_0_4 = DST16_0_4 - brw;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SBCX.A DST20_0_4				is ctx_haveext=4 & op16_12_4=0x7 & bow=1 & ctx_al=0 & src16_8_4=0x3 & as=0x0 & postIncrementStore & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	brw:$(REG_SIZE) = 1 - zext( $(CARRY) );
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = DST20_0_4 - brw;
	DST20_0_4 = sext(tmp[0,20]);
	
	setsubflags(DST20_0_4,brw,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SUBCX.B XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0x7 & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	brw:1 = 1 - $(CARRY);
	$(CARRY) = ((brw + XRSRC_B_AS) <= DST8_0_4);             # Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST8_0_4, XRSRC_B_AS + brw);	
	# Operation...
	DST8_0_4 = DST8_0_4 - XRSRC_B_AS - brw;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SUBCX.W XRSRC_W_AS, DST16_0_4				is ctx_haveext=4 & op16_12_4=0x7 & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	brw:2 = 1 - zext( $(CARRY) );
	$(CARRY) = ((brw + XRSRC_W_AS) <= DST16_0_4);		# Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST16_0_4, XRSRC_W_AS + brw);	
	# Operation...
	DST16_0_4 = DST16_0_4 - XRSRC_W_AS - brw;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SUBCX.A XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0x7 & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 & repeat_carry {
	<top>
	build repeat_carry;
	brw:$(REG_SIZE) = 1 - zext( $(CARRY) );
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmps:$(REG_SIZE) = XRSRC_A_AS + brw;
	tmp:$(REG_SIZE) = DST20_0_4 - tmps;
	DST20_0_4 = sext(tmp[0,20]);
	
	setsubflags(DST20_0_4,tmps,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SUBX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0x8 & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (XRSRC_B_AS <= DST8_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST8_0_4, XRSRC_B_AS);									# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 - XRSRC_B_AS;		
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SUBX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0x8 & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = (XRSRC_W_AS <= DST16_0_4);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(DST16_0_4, XRSRC_W_AS);								# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 - XRSRC_W_AS;		
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SUBX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0x8 & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	tmpd:$(REG_SIZE) = DST20_0_4;
	tmp:$(REG_SIZE) = DST20_0_4 - XRSRC_A_AS;
	DST20_0_4 = sext(tmp[0,20]);
	
	setsubflags(DST20_0_4,XRSRC_A_AS,tmpd);
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:TSTX.B	DST8_0_4						is ctx_haveext=4 & op16_12_4=0x9 & bow=1 & ctx_al=1 & src16_8_4=0x3 & as=0x0 & DST8_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = 1;		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = 0;	# V Flag
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:TSTX.W	DST16_0_4						is ctx_haveext=4 & op16_12_4=0x9 & bow=0 & ctx_al=1 & src16_8_4=0x3 & as=0x0 & DST16_0_4 {
	<top>
	# Operation Flags...
	$(CARRY) = 1;		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = 0;	# V Flag
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:TSTX.A	DST20_0_4						is ctx_haveext=4 & op16_12_4=0x9 & bow=1 & ctx_al=0 & src16_8_4=0x3 & as=0x0 & DST20_0_4 {
	<top>
	setsubflags(DST20_0_4,0:$(REG_SIZE),DST20_0_4);
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:XORX.B	XRSRC_B_AS, DST8_0_4				is ctx_haveext=4 & op16_12_4=0xE & bow=1 & ctx_al=1 & postIncrementStore & XRSRC_B_AS & DST8_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = ((DST8_0_4 s< 0x0) && (XRSRC_B_AS s< 0x0)) ;	# V Flag
	# Operation...
	DST8_0_4 = DST8_0_4 ^ XRSRC_B_AS;
	bzero(reg_Direct16_0_4,DST8_0_4);
	# Result Flags...
	$(SIGN) = (DST8_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST8_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST8_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:XORX.W	XRSRC_W_AS, DST16_0_4			is ctx_haveext=4 & op16_12_4=0xE & bow=0 & ctx_al=1 & postIncrementStore & XRSRC_W_AS & DST16_0_4 & reg_Direct16_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = ((DST16_0_4 s< 0x0) && (XRSRC_W_AS s< 0x0)) ;	# V Flag
	# Operation...
	DST16_0_4 = DST16_0_4 ^ XRSRC_W_AS;
	wzero(reg_Direct16_0_4,DST16_0_4);
	# Result Flags...
	$(SIGN) = (DST16_0_4 s< 0x0);			# S Flag
	$(ZERO) = (DST16_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST16_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:XORX.A	XRSRC_A_AS, DST20_0_4				is ctx_haveext=4 & op16_12_4=0xE & bow=1 & ctx_al=0 & postIncrementStore & XRSRC_A_AS & DST20_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = ((DST20_0_4 s< 0x0) && (XRSRC_A_AS s< 0x0)) ;	# V Flag
	# Operation...
	DST20_0_4 = DST20_0_4 ^ XRSRC_A_AS;
	DST20_0_4 = sext(DST20_0_4[0,20]);
	# Result Flags...
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0x0);			# Z Flag
	$(CARRY) = (DST20_0_4 != 0x0);			# C Flag
	build postIncrementStore;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

#############################
# No Repeat
:ADCX.B XDEST_B_AD				is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x6 & src16_8_4=0x3 & as=0x0 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	tmp_carry:1 = carry(XDEST_B_AD,$(CARRY));		 #C Flag
 	$(OVERFLOW) = scarry(XDEST_B_AD,$(CARRY)); #V Flag
 	# Operation...
	XDEST_B_AD = XDEST_B_AD + $(CARRY);
	build tbl_bzero;
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:ADCX.W XDEST_W_AD				is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x6 & src16_8_4=0x3 & as=0x0 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	tmp_carry:1 = carry(XDEST_W_AD,zext($(CARRY)));		 #C Flag
 	$(OVERFLOW) = scarry(XDEST_W_AD,zext($(CARRY))); #V Flag
 	# Operation...
	XDEST_W_AD = XDEST_W_AD + zext($(CARRY));
	build tbl_wzero;
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:ADCX.A XDEST_A_AD				is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x6 & src16_8_4=0x3 & as=0x0 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmpc:$(REG_SIZE) = zext($(CARRY));
	tmp:$(REG_SIZE) = tmpc + XDEST_A_AD;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setaddflags(XDEST_A_AD,tmpc,tmpd);
	build postIncrementStore;
}

:ADDX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x5 & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = carry(XSRC_B_AS, XDEST_B_AD); 	 	# C Flag
	$(OVERFLOW) = scarry(XSRC_B_AS, XDEST_B_AD); 	# V Flag
	# Operation...
	XDEST_B_AD = XSRC_B_AS + XDEST_B_AD;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:ADDX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x5 & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = carry(XSRC_W_AS, XDEST_W_AD); 	 	# C Flag
	$(OVERFLOW) = scarry(XSRC_W_AS, XDEST_W_AD); 	# V Flag
	# Operation...
	XDEST_W_AD = XSRC_W_AS + XDEST_W_AD;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:ADDX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x5 & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmp:$(REG_SIZE) = XSRC_A_AS + XDEST_A_AD;
	
	XDEST_A_AD = sext(tmp[0,20]);
	setaddflags(XDEST_A_AD,XSRC_A_AS,tmpd);
	build postIncrementStore;
}

:ADDCX.B XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x6 & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	tmp_carry:1 = (carry(XSRC_B_AS, $(CARRY)) || carry(XDEST_B_AD,XSRC_B_AS + $(CARRY)));		 #C Flag
 	$(OVERFLOW) = (scarry(XSRC_B_AS, $(CARRY)) || scarry(XDEST_B_AD,XSRC_B_AS + $(CARRY))); #V Flag
 	# Operation...
	XDEST_B_AD = XSRC_B_AS + XDEST_B_AD + $(CARRY);
	build tbl_bzero;
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:ADDCX.W XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x6 & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	tmp_carry:1 = (carry(XSRC_W_AS,zext($(CARRY))) || carry(XDEST_W_AD,XSRC_W_AS + zext($(CARRY))));		 #C Flag
 	$(OVERFLOW) = (scarry(XSRC_W_AS,zext($(CARRY))) || scarry(XDEST_W_AD,XSRC_W_AS + zext($(CARRY)))); #V Flag
 	# Operation...
	XDEST_W_AD = XSRC_W_AS + XDEST_W_AD + zext($(CARRY));
	build tbl_wzero;
	# Result Flags...
	$(CARRY) = tmp_carry;
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:ADDCX.A XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x6 & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmps:$(REG_SIZE) = XSRC_A_AS + zext($(CARRY));
	tmp:$(REG_SIZE) = tmps + XDEST_A_AD;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setaddflags(XDEST_A_AD,tmps,tmpd);
	build postIncrementStore;
}

:ANDX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xF & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	result:1 = XDEST_B_AD & XSRC_B_AS;
	XDEST_B_AD = result;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	$(CARRY) = (result != 0x0);			# C Flag
	build postIncrementStore;
}

:ANDX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xF & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	result:2 = XDEST_W_AD & XSRC_W_AS;
	XDEST_W_AD = result;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	$(CARRY) = (result != 0x0);			# C Flag
	build postIncrementStore;
}

:ANDX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xF & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	XDEST_A_AD = XDEST_A_AD & XSRC_A_AS;
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	# Result Flags...
	$(SIGN) = XDEST_A_AD[19, 1] == 1;
	$(ZERO) = (XDEST_A_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_A_AD != 0x0);			# C Flag
	build postIncrementStore;
}

:BICX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xC & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	XDEST_B_AD = (~XSRC_B_AS) & XDEST_B_AD;
	build tbl_bzero;
	#Status bits are not affected
	build postIncrementStore;
}

:BICX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xC & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	XDEST_W_AD = (~XSRC_W_AS) & XDEST_W_AD;
	build tbl_wzero;
	#Status bits are not affected
	build postIncrementStore;
}

:BICX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xC & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	XDEST_A_AD = (~XSRC_A_AS) & XDEST_A_AD;
	#Status bits are not affected
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	build postIncrementStore;
}

:BISX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xD & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	XDEST_B_AD = XSRC_B_AS | XDEST_B_AD;
	build tbl_bzero;
	#Status bits are not affected
	build postIncrementStore;
}

:BISX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xD & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	XDEST_W_AD = XSRC_W_AS | XDEST_W_AD;
	build tbl_wzero;
	#Status bits are not affected
	build postIncrementStore;
}

:BISX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xD & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	XDEST_A_AD = XSRC_A_AS | XDEST_A_AD;
	#Status bits are not affected
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	build postIncrementStore;
}

:BITX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xB & bow=1 & postIncrement) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	result:1 = XDEST_B_AD & XSRC_B_AS;
	# Result Flags...
	$(CARRY) = (result != 0x0);			# C Flag
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
}

:BITX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xB & bow=0 & postIncrement) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	result:2 = XDEST_W_AD & XSRC_W_AS;
	# Result Flags...
	$(CARRY) = (result != 0x0);			# C Flag
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
}

:BITX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xB & bow=1 & postIncrement) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	result:$(REG_SIZE) = XDEST_A_AD & XSRC_A_AS;
	# Result Flags...
	result = sext(result[0,20]);
	$(CARRY) = (result != 0x0);			# C Flag
	$(SIGN) = result[19, 1] == 1;
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
}

:CLRX.B	XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x4 & src16_8_4=0x3 & as=0x0 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	XDEST_B_AD = 0;
	build tbl_bzero;
	#Status bits are not affected
	build postIncrementStore;
}

:CLRX.W	XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x4 & src16_8_4=0x3 & as=0x0 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	XDEST_W_AD = 0;
	build tbl_wzero;
	#Status bits are not affected
	build postIncrementStore;
}

:CLRX.A	XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x4 & src16_8_4=0x3 & as=0x0 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	XDEST_A_AD = 0;
	build postIncrementStore;
}

:CMPX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x9 & bow=1 & postIncrement) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = (XSRC_B_AS <= XDEST_B_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_B_AD, XSRC_B_AS);	# V Flag
	# Operation...
	result:1 = (XDEST_B_AD - XSRC_B_AS);
	# Result Flags...
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
}

:CMPX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x9 & bow=0 & postIncrement) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = (XSRC_W_AS <= XDEST_W_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_W_AD, XSRC_W_AS);	# V Flag
	# Operation...
	result:2 = (XDEST_W_AD - XSRC_W_AS);
	# Result Flags...
	$(SIGN) = (result s< 0x0);			# S Flag
	$(ZERO) = (result == 0x0);			# Z Flag
	build postIncrement;
}

:CMPX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x9 & bow=1 & postIncrement) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	tmp:$(REG_SIZE) = XDEST_A_AD - XSRC_A_AS;
	tmpd:$(REG_SIZE) = sext(tmp[0,20]);
	setsubflags(tmpd,XSRC_A_AS,XDEST_A_AD);
	build postIncrement;
}

:DADCX.B XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xA & src16_8_4=0x3 & as=0x0 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = 0;				# This should be overflow
	# Operation...
	XDEST_B_AD = bcd_add(XDEST_B_AD);
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);		# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);		# Z Flag
	build postIncrementStore;
}

:DADCX.W XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xA & src16_8_4=0x3 & as=0x0 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = 0;					# Don't currently have BCD overflow op
	# Operation...
	XDEST_W_AD = bcd_add(XDEST_W_AD);
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DADCX.A XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xA & src16_8_4=0x3 & as=0x0 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	# Operation Flags...
	$(CARRY) = 0;					# Don't currently have BCD overflow op
	# Operation...
	XDEST_A_AD = bcd_add(XDEST_A_AD);
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	# Result Flags...
	$(SIGN) = XDEST_A_AD[19, 1] == 1;
	$(ZERO) = (XDEST_A_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DADDX.B XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xA & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = 0;				# This should be overflow
	# Operation...
	XDEST_B_AD = bcd_add(XSRC_B_AS,XDEST_B_AD);
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);		# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);		# Z Flag
	build postIncrementStore;
}

:DADDX.W XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xA & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = 0;					# Don't currently have BCD overflow op
	# Operation...
	XDEST_W_AD = bcd_add(XSRC_W_AS ,XDEST_W_AD);
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DADDX.A XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xA & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	# Operation Flags...
	$(CARRY) = 0;					# Don't currently have BCD overflow op
	# Operation...
	XDEST_A_AD = bcd_add(XSRC_A_AS ,XDEST_A_AD);
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	# Result Flags...
	$(SIGN) = XDEST_A_AD[19, 1] == 1;
	$(ZERO) = (XDEST_A_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DECX.B	XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x8 & src16_8_4=0x3 & as=0x1 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = (1 <= XDEST_B_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_B_AD, 1:1);									# V Flag
	# Operation...
	XDEST_B_AD = XDEST_B_AD - 1;		
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DECX.W	XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x8 & src16_8_4=0x3 & as=0x1 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = (1 <= XDEST_W_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_W_AD, 1:2);								# V Flag
	# Operation...
	XDEST_W_AD = XDEST_W_AD - 1:2;		
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DECX.A	XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x8 & src16_8_4=0x3 & as=0x1 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmp:$(REG_SIZE) = XDEST_A_AD - 1:$(REG_SIZE);
	XDEST_A_AD = sext(tmp[0,20]);
	
	setsubflags(XDEST_A_AD,1:$(REG_SIZE),tmpd);
	build postIncrementStore;
}

:DECDX.B XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x8 & src16_8_4=0x3 & as=0x2 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = (1 <= XDEST_B_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_B_AD, 2:1);									# V Flag
	# Operation...
	XDEST_B_AD = XDEST_B_AD - 2;		
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DECDX.W XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x8 & src16_8_4=0x3 & as=0x2 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = (1 <= XDEST_W_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_W_AD, 2:2);								# V Flag
	# Operation...
	XDEST_W_AD = XDEST_W_AD - 2:2;		
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:DECDX.A XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x8 & src16_8_4=0x3 & as=0x2 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmp:$(REG_SIZE) = XDEST_A_AD - 2:$(REG_SIZE);
	XDEST_A_AD = sext(tmp[0,20]);
	
	setsubflags(XDEST_A_AD,2:$(REG_SIZE),tmpd);
	build postIncrementStore;
}

:INCX.B	XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x5 & src16_8_4=0x3 & as=0x1 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = carry(XDEST_B_AD,1); 	 	# C Flag
	$(OVERFLOW) = scarry(XDEST_B_AD,1); 	# V Flag
	# Operation...
	XDEST_B_AD = 1 + XDEST_B_AD;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:INCX.W	XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x5 & src16_8_4=0x3 & as=0x1 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = carry(XDEST_W_AD,1); 	 	# C Flag
	$(OVERFLOW) = scarry(XDEST_W_AD,1); 	# V Flag
	# Operation...
	XDEST_W_AD = 1 + XDEST_W_AD;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:INCX.A	XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x5 & src16_8_4=0x3 & as=0x1 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmp:$(REG_SIZE) = 1 + XDEST_A_AD;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setaddflags(XDEST_A_AD,1:$(REG_SIZE),tmpd);
	build postIncrementStore;
}

:INCDX.B XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x5 & src16_8_4=0x3 & as=0x2 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = carry(XDEST_B_AD,2); 	 	# C Flag
	$(OVERFLOW) = scarry(XDEST_B_AD,2); 	# V Flag
	# Operation...
	XDEST_B_AD = 2 + XDEST_B_AD;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:INCDX.W XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x5 & src16_8_4=0x3 & as=0x2 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = carry(XDEST_W_AD,2); 	 	# C Flag
	$(OVERFLOW) = scarry(XDEST_W_AD,2); 	# V Flag
	# Operation...
	XDEST_W_AD = 2 + XDEST_W_AD;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:INCDX.A XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x5 & src16_8_4=0x3 & as=0x2 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmp:$(REG_SIZE) = 2 + XDEST_A_AD;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setaddflags(XDEST_A_AD,1:$(REG_SIZE),tmpd);
	build postIncrementStore;
}

:INVX.B	XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xE & src16_8_4=0x3 & as=0x3 & bow=1 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(OVERFLOW) = XDEST_B_AD s< 0x0;	# V Flag
	# Operation...
	XDEST_B_AD = XDEST_B_AD ^ -1;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_B_AD != 0x0);			# C Flag
	build postIncrementStore;
}

:INVX.W	XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xE & src16_8_4=0x3 & as=0x3 & bow=0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(OVERFLOW) = XDEST_W_AD s< 0x0;	# V Flag
	# Operation...
	XDEST_W_AD = XDEST_W_AD ^ -1;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_W_AD != 0x0);			# C Flag
	build postIncrementStore;
}

:INVX.A	XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xE & src16_8_4=0x3 & as=0x3 & bow=1 & postIncrementStore) ... & XDEST_A_AD ... {
	# Operation Flags...
	$(OVERFLOW) = XDEST_A_AD s< 0x0;	# V Flag
	# Operation...
	XDEST_A_AD = XDEST_A_AD ^ -1;
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	# Result Flags...
	$(SIGN) = XDEST_A_AD[19, 1] == 1;
	$(ZERO) = (XDEST_A_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_A_AD != 0x0);			# C Flag
	build postIncrementStore;
}

:MOVX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x4 & bow=1 & tbl_bzero & postIncrement & postStorePC) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	local tmp:1 = XSRC_B_AS;
	build postIncrement;
	XDEST_B_AD = tmp;
	build tbl_bzero;
	#Status bits are not affected
	build postStorePC;
}

:MOVX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x4 & bow=0 & tbl_wzero & postIncrement & postStorePC) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	local tmp:2 = XSRC_W_AS;
	build postIncrement;
	XDEST_W_AD = tmp;
	build tbl_wzero;
	#Status bits are not affected
	build postStorePC;
}

:MOVX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x4 & bow=1 & postIncrement & postStorePC) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	local tmp:$(REG_SIZE) = XSRC_A_AS & 0xfffff;
	build postIncrement;
	XDEST_A_AD = tmp;
	build postStorePC;
}

:POPX.B	XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x4 & src16_8_4=0x1 & as=0x3 & bow=1 & tbl_bzero & postStorePC) ... & XDEST_B_AD ...  {
	local tmp:1 = *:1 SP;
	SP = SP + 0x2;
	XDEST_B_AD = tmp;
	build tbl_bzero;
	#Status bits are not affected
	build postStorePC;
}

:POPX.W	XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x4 & src16_8_4=0x1 & as=0x3 & bow=0 & tbl_wzero & postStorePC) ... & XDEST_W_AD ... {
	local tmp:2 = *:2 SP;
	SP = SP + 0x2;
	XDEST_W_AD = tmp;
	build tbl_wzero;
	#Status bits are not affected
	build postStorePC;
}

:POPX.A	XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x4 & src16_8_4=0x1 & as=0x3 & bow=1 & postStorePC) ... & XDEST_A_AD ... {
	local tmp:4 = *:4 SP;
	SP = SP + 0x4;
	tmp = zext(tmp[0,20]);
	XDEST_A_AD = tmp;
	build postStorePC;
}

:SBCX.B XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x7 & bow=1 & src16_8_4=0x3 & as=0x0 & tbl_bzero & postIncrementStore) ... & XDEST_B_AD ...  {
	# Operation Flags...
	brw:1 = 1 - $(CARRY);
    $(CARRY) = (brw <= XDEST_B_AD);             # Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_B_AD, brw);	
	# Operation...
	XDEST_B_AD = XDEST_B_AD - brw;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:SBCX.W XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x7 & bow=0 & src16_8_4=0x3 & as=0x0 & tbl_wzero & postIncrementStore) ... & XDEST_W_AD ... {
	# Operation Flags...
	brw:2 = 1 - zext( $(CARRY) );
	$(CARRY) = (brw <= XDEST_W_AD);		# Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_W_AD, brw);	
	# Operation...
	XDEST_W_AD = XDEST_W_AD - brw;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:SBCX.A XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x7 & bow=1 & src16_8_4=0x3 & as=0x0 & postIncrementStore) ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	brw:$(REG_SIZE) = 1 - zext( $(CARRY) ); 
	tmp:$(REG_SIZE) = XDEST_A_AD - brw;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setsubflags(XDEST_A_AD,brw,tmpd);
	build postIncrementStore;
}

:SUBCX.B XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x7 & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	brw:1 = 1 - $(CARRY);
    $(CARRY) = ((brw + XSRC_B_AS) <= XDEST_B_AD);             # Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_B_AD, XSRC_B_AS + brw);	
	# Operation...
	XDEST_B_AD = XDEST_B_AD - XSRC_B_AS - brw;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:SUBCX.W XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x7 & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	brw:2 = 1 - zext( $(CARRY) );
	$(CARRY) = ((brw + XSRC_W_AS) <= XDEST_W_AD);		# Carry flag is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_W_AD, XSRC_W_AS + brw);	
	# Operation...
	XDEST_W_AD = XDEST_W_AD - XSRC_W_AS - brw;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:SUBCX.A XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x7 & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	brw:$(REG_SIZE) = 1 - zext( $(CARRY) ); 
	tmps:$(REG_SIZE) = XSRC_A_AS + brw;
	tmp:$(REG_SIZE) = XDEST_A_AD - tmps;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setsubflags(XDEST_A_AD,tmps,tmpd);
	build postIncrementStore;
}

:SUBX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x8 & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = (XSRC_B_AS <= XDEST_B_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_B_AD, XSRC_B_AS);									# V Flag
	# Operation...
	XDEST_B_AD = XDEST_B_AD - XSRC_B_AS;		
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:SUBX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x8 & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = (XSRC_W_AS <= XDEST_W_AD);		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = sborrow(XDEST_W_AD, XSRC_W_AS);								# V Flag
	# Operation...
	XDEST_W_AD = XDEST_W_AD - XSRC_W_AS;		
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrementStore;
}

:SUBX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x8 & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	tmpd:$(REG_SIZE) = XDEST_A_AD;
	tmp:$(REG_SIZE) = XDEST_A_AD - XSRC_A_AS;
	XDEST_A_AD = sext(tmp[0,20]);
	
	setsubflags(XDEST_A_AD,XSRC_A_AS,tmpd);
	build postIncrementStore;
}

:TSTX.B	XDEST_B_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x9 & bow=1 & src16_8_4=0x3 & as=0x0 & postIncrement) ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(CARRY) = 1;		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = 0;	# V Flag
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	build postIncrement;
}

:TSTX.W	XDEST_W_AD						is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x9 & bow=0 & src16_8_4=0x3 & as=0x0 & postIncrement) ... & XDEST_W_AD ... {
	# Operation Flags...
	$(CARRY) = 1;		# Carry is NOT set if there is a borrow
	$(OVERFLOW) = 0;	# V Flag
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	build postIncrement;
}

:TSTX.A	XDEST_A_AD						is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x9 & bow=1 & src16_8_4=0x3 & as=0x0 & postIncrement) ... & XDEST_A_AD ... {
	setsubflags(XDEST_A_AD,0:$(REG_SIZE),XDEST_A_AD);
	build postIncrement;
}

:XORX.B	XSRC_B_AS, XDEST_B_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xE & bow=1 & tbl_bzero & postIncrementStore) ... & XSRC_B_AS ... & XDEST_B_AD ...  {
	# Operation Flags...
	$(OVERFLOW) = ((XDEST_B_AD s< 0x0) && (XSRC_B_AS s< 0x0)) ;	# V Flag
	# Operation...
	XDEST_B_AD = XDEST_B_AD ^ XSRC_B_AS;
	build tbl_bzero;
	# Result Flags...
	$(SIGN) = (XDEST_B_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_B_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_B_AD != 0x0);			# C Flag
	build postIncrementStore;
}

:XORX.W	XSRC_W_AS, XDEST_W_AD			is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0xE & bow=0 & tbl_wzero & postIncrementStore) ... & XSRC_W_AS ... & XDEST_W_AD ... {
	# Operation Flags...
	$(OVERFLOW) = ((XDEST_W_AD s< 0x0) && (XSRC_W_AS s< 0x0)) ;	# V Flag
	# Operation...
	XDEST_W_AD = XDEST_W_AD ^ XSRC_W_AS;
	build tbl_wzero;
	# Result Flags...
	$(SIGN) = (XDEST_W_AD s< 0x0);			# S Flag
	$(ZERO) = (XDEST_W_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_W_AD != 0x0);			# C Flag
	build postIncrementStore;
}

:XORX.A	XSRC_A_AS, XDEST_A_AD			is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0xE & bow=1 & postIncrementStore) ... & XSRC_A_AS ... & XDEST_A_AD ... {
	# Operation Flags...
	$(OVERFLOW) = ((XDEST_A_AD s< 0x0) && (XSRC_A_AS s< 0x0)) ;	# V Flag
	# Operation...
	XDEST_A_AD = XDEST_A_AD ^ XSRC_A_AS;
	XDEST_A_AD = sext(XDEST_A_AD[0,20]);
	# Result Flags...
	$(SIGN) = XDEST_A_AD[19, 1] == 1;
	$(ZERO) = (XDEST_A_AD == 0x0);			# Z Flag
	$(CARRY) = (XDEST_A_AD != 0x0);			# C Flag
	build postIncrementStore;
}


#############################
#
# Single Operand
#
#############################
# Repeat enabled

# Note: The manual says PUSHX doesn't use extension word. The manual is *WRONG*
:PUSHX.B XRREG_B_AS 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x2 & bow=0x1 & postRegIncrement & XRREG_B_AS {
	<top>
	local tmp = SP - 0x2;
	*:1 tmp = XRREG_B_AS;
	#Status bits are not affected
	build postRegIncrement;
	SP = tmp;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}	

:PUSHX.W XRREG_W_AS 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x2 & bow=0x0 & postRegIncrement & XRREG_W_AS {
	<top>
	local tmp = SP - 0x2;
	*:2 tmp = XRREG_W_AS;
	#Status bits are not affected
	build postRegIncrement;
	SP = tmp;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:PUSHX.A XRREG_A_AS 		is ctx_haveext=4 & ctx_al=0 & op16_12_4=0x1 & op16_8_4=0x2 & bow=0x1 & postRegIncrement & XRREG_A_AS {
	<top>
	local tmp = SP - 0x4;
	*:4 tmp = XRREG_A_AS & 0xfffff;
	#Status bits are not affected
	build postRegIncrement;
	SP = tmp;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}	

:RRAX.B XRREG_B_AS_DEST 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x0 & bow=0x1 & postRegIncrement & XRREG_B_AS_DEST {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	$(CARRY) = (XRREG_B_AS_DEST & 0x1);
	XRREG_B_AS_DEST = XRREG_B_AS_DEST s>> 1;
	# Result Flags...
	$(SIGN) = (XRREG_B_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XRREG_B_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRAX.W XRREG_W_AS_DEST 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x0 & bow=0x0 & postRegIncrement & XRREG_W_AS_DEST {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	$(CARRY) = XRREG_W_AS_DEST[0,1];
	XRREG_W_AS_DEST = XRREG_W_AS_DEST s>> 1; 
	# Result Flags...
	$(SIGN) = (XRREG_W_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XRREG_W_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRAX.A XRREG_A_AS_DEST 		is ctx_haveext=4 & ctx_al=0 & op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x0 & bow=0x1 & postRegIncrement & XRREG_A_AS_DEST {
	<top>
	$(CARRY) = XRREG_A_AS_DEST[0,1];
	XRREG_A_AS_DEST = (XRREG_A_AS_DEST << 12 s>> 13) & 0xfffff;
	$(OVERFLOW) = 0;
	$(SIGN) = (XRREG_A_AS_DEST[19,1] != 0);
	$(ZERO) = (XRREG_A_AS_DEST == 0);
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRCX.B XRREG_B_AS_DEST 		is ctx_haveext=4 & ctx_al=1 & ctx_zc & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x1 & postRegIncrement & XRREG_B_AS_DEST & repeat_carry {
	<top>
	# Operation Flags...
	build repeat_carry;
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	tmp:1 = $(CARRY);
	$(CARRY) = (XRREG_B_AS_DEST & 0x1);
	XRREG_B_AS_DEST = ((tmp << 0x7) | (XRREG_B_AS_DEST >> 0x1));
	# Result Flags...
	$(SIGN) = (XRREG_B_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XRREG_B_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRUX.B XRREG_B_AS_DEST 		is ctx_haveext=4 & ctx_zc=1 & ctx_al=1 & ctx_zc & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x1 & postRegIncrement & XRREG_B_AS_DEST & repeat_carry {
	<top>
	# Operation Flags...
	# build repeat_carry;
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	$(CARRY) = (XRREG_B_AS_DEST & 0x1);
	XRREG_B_AS_DEST = XRREG_B_AS_DEST >> 0x1;
	# Result Flags...
	$(SIGN) = (XRREG_B_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XRREG_B_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRCX.W XRREG_W_AS_DEST 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x0 & postRegIncrement & XRREG_W_AS_DEST & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	tmp:1 = $(CARRY);
	$(CARRY) = XRREG_W_AS_DEST[0,1];
	XRREG_W_AS_DEST = ((zext(tmp) << 0xF) | (XRREG_W_AS_DEST >> 0x1));
	# Result Flags...
	$(SIGN) = (XRREG_W_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XRREG_W_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRUX.W XRREG_W_AS_DEST 		is ctx_haveext=4 & ctx_zc=1 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x0 & postRegIncrement & XRREG_W_AS_DEST & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	$(OVERFLOW) = 0;					# V Flag
	# Operation...
	$(CARRY) = XRREG_W_AS_DEST[0,1];
	XRREG_W_AS_DEST = XRREG_W_AS_DEST >> 0x1;
	# Result Flags...
	$(SIGN) = (XRREG_W_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XRREG_W_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRCX.A XRREG_A_AS_DEST 		is ctx_haveext=4 & ctx_al=0 & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x1 & postRegIncrement & XRREG_A_AS_DEST & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	tmp:1 = $(CARRY);
	$(CARRY) = XRREG_A_AS_DEST[0,1];
	XRREG_A_AS_DEST = ((zext(tmp) << 0x13) | ((XRREG_A_AS_DEST >> 0x1) & 0x7FFFF));
	# Result Flags...
	$(SIGN) = XRREG_A_AS_DEST[19, 1] == 1;
	$(ZERO) = (XRREG_A_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:RRUX.A XRREG_A_AS_DEST 		is ctx_haveext=4 & ctx_zc=1 & ctx_al=0 & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x1 & postRegIncrement & XRREG_A_AS_DEST & repeat_carry {
	<top>
	build repeat_carry;
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	$(CARRY) = XRREG_A_AS_DEST[0,1];
	XRREG_A_AS_DEST = (XRREG_A_AS_DEST >> 0x1) & 0x7FFFF;
	# Result Flags...
	$(SIGN) = XRREG_A_AS_DEST[19, 1] == 1;			# S Flag
	$(ZERO) = (XRREG_A_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SWPBX.W XRREG_W_AS_DEST 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x1 & as=0x0 & bow=0x0 & postRegIncrement & XRREG_W_AS_DEST {
	<top>
	lowByte:1 = XRREG_W_AS_DEST[0,8];
	highByte:1 = XRREG_W_AS_DEST[8,8];
	XRREG_W_AS_DEST = (((zext(lowByte)) << 0x8) | zext(highByte));
	#Status bits are not affected
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SWPBX.A XRREG_A_AS_DEST2 		is ctx_haveext=4 & ctx_al=0 & op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x1 & as=0x0 & bow=0x0 & postRegIncrement & XRREG_A_AS_DEST2 {
	<top>
	lowByte:1 = XRREG_A_AS_DEST2[0,8];
	highByte:1 = XRREG_A_AS_DEST2[8,8];
	XRREG_A_AS_DEST2[8,8] = lowByte;
	XRREG_A_AS_DEST2[0,8] = highByte;
	XRREG_A_AS_DEST2 = zext(XRREG_A_AS_DEST2[0,20]);
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SXTX.W DST20_0_4 		is ctx_haveext=4 & ctx_al=1 & op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x1 & as=0x0 & bow=0x0 & postRegIncrement & DST20_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...	
	DST20_0_4 = sext(DST20_0_4:1) & 0xfffff;
	# Result Flags...
	$(SIGN) = (DST20_0_4[19,1] == 1);			# S Flag
	$(ZERO) = (DST20_0_4 == 0x0);				# Z Flag
	$(CARRY) = (DST20_0_4 != 0x0);				# C Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

:SXTX.A DST20_0_4		is ctx_haveext=4 & ctx_al=0 & op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x1 & as=0x0 & bow=0x0 & postRegIncrement & DST20_0_4 {
	<top>
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	DST20_0_4 = sext(DST20_0_4:1) & 0xfffff;
	# Result Flags...
	$(SIGN) = DST20_0_4[19, 1] == 1;
	$(ZERO) = (DST20_0_4 == 0x0);				# Z Flag
	$(CARRY) = (DST20_0_4 != 0x0);				# C Flag
	build postRegIncrement;
	if (CNT == 0) goto inst_next;
	CNT = CNT - 1;
	goto <top>;
}

#############################
# No Repeat
:PUSHX.B XREG_B_AS 		is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x2 & op16_7_1=0x0 & bow=0x1 & postRegIncrement) ... & XREG_B_AS {
	local tmp = SP - 2;
	*:1 tmp = XREG_B_AS;
	#Status bits are not affected
	build postRegIncrement;
	SP = tmp;
}	

:PUSHX.W XREG_W_AS 		is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x2 & op16_7_1=0x0 & bow=0x0 & postRegIncrement) ... & XREG_W_AS {
	local tmp = SP - 2;
	*:2 tmp = XREG_W_AS;
	#Status bits are not affected
	build postRegIncrement;
	SP = tmp;
}

:PUSHX.A XREG_A_AS 		is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x1 & op16_8_4=0x2 & op16_7_1=0x0 & bow=0x1 & postRegIncrement) ... & XREG_A_AS {
	local tmp_sp = SP - 4;
	*:$(REG_SIZE) tmp_sp = XREG_A_AS & 0xfffff;
	build postRegIncrement;
	SP = tmp_sp;
}	

:RRAX.B XREG_B_AS_DEST 	is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x0 & bow=0x1 & postRegIncrement) ... & XREG_B_AS_DEST {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	$(CARRY) = (XREG_B_AS_DEST & 0x1);
	XREG_B_AS_DEST = XREG_B_AS_DEST s>> 1;
	# Result Flags...
	$(SIGN) = (XREG_B_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XREG_B_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
}

:RRAX.W XREG_W_AS_DEST 	is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x0 & bow=0x0 & postRegIncrement) ... & XREG_W_AS_DEST {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag (reset)
	# Operation...
	$(CARRY) = XREG_W_AS_DEST[0,1];
	XREG_W_AS_DEST = XREG_W_AS_DEST s>> 1;
	# Result Flags...
	$(SIGN) = (XREG_W_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XREG_W_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
}

:RRAX.A XREG_A_AS_DEST 	is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x0 & bow=0x1 & postRegIncrement) ... & XREG_A_AS_DEST {
	$(CARRY) = XREG_A_AS_DEST[0,1];
	XREG_A_AS_DEST = (XREG_A_AS_DEST << 12 s>> 13) & 0xfffff;
	$(OVERFLOW) = 0;
	$(SIGN) = (XREG_A_AS_DEST[19,1] != 0);
	$(ZERO) = (XREG_A_AS_DEST == 0);
	build postRegIncrement;
}

:RRCX.B XREG_B_AS_DEST 	is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x1 & postRegIncrement) ... & XREG_B_AS_DEST {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	tmp:1 = $(CARRY);
	$(CARRY) = (XREG_B_AS_DEST & 0x1);
	XREG_B_AS_DEST = ((tmp << 0x7) | (XREG_B_AS_DEST >> 0x1));
	# Result Flags...
	$(SIGN) = (XREG_B_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XREG_B_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
}

:RRCX.W XREG_W_AS_DEST	is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x0 & postRegIncrement) ... & XREG_W_AS_DEST {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	tmp:1 = $(CARRY);
	$(CARRY) = XREG_W_AS_DEST[0,1];
	XREG_W_AS_DEST = ((zext(tmp) << 0xF) | (XREG_W_AS_DEST >> 0x1));
	# Result Flags...
	$(SIGN) = (XREG_W_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XREG_W_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
}

:RRCX.A XREG_A_AS_DEST 	is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x0 & bow=0x1 & postRegIncrement) ... & XREG_A_AS_DEST {
	# Operation Flags...
	$(OVERFLOW) = 0x0;					# V Flag
	# Operation...
	tmp:1 = $(CARRY);
	$(CARRY) = XREG_A_AS_DEST[0,1];
	XREG_A_AS_DEST = ((zext(tmp) << 0x13) | ((XREG_A_AS_DEST >> 0x1) & 0x7FFFF));
	# Result Flags...
	$(SIGN) = XREG_A_AS_DEST[19, 1] == 1;
	$(ZERO) = (XREG_A_AS_DEST == 0x0);			# Z Flag
	build postRegIncrement;
}

:SWPBX.W XREG_W_AS_DEST is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x1 & bow=0x0 & postRegIncrement) ... & XREG_W_AS_DEST {
	lowByte:1 = XREG_W_AS_DEST[0,8];
	highByte:1 = XREG_W_AS_DEST[8,8];
	XREG_W_AS_DEST = (((zext(lowByte)) << 0x8) | zext(highByte));
	#Status bits are not affected
	build postRegIncrement;
}

# Yes, for SXTX and SWPB, the normal width selectors are different.  Hence, for the A versions, we have a different dest reg subtable.
:SWPBX.A XREG_A_AS_DEST2 is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x1 & op16_8_4=0x0 & op16_7_1=0x1 & bow=0x0 & postRegIncrement) ... & XREG_A_AS_DEST2 {
	lowByte:1 = XREG_A_AS_DEST2[0,8];
	highByte:1 = XREG_A_AS_DEST2[8,8];
	XREG_A_AS_DEST2[8,8] = lowByte;
	XREG_A_AS_DEST2[0,8] = highByte;
	XREG_A_AS_DEST2 = zext(XREG_A_AS_DEST2[0,20]);
	build postRegIncrement;
}

:SXTX.W XREG_W_AS_DEST 	is ctx_haveext=7 & ctx_al=1 & (op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x1 & bow=0x0 & postRegIncrement) ... & XREG_W_AS_DEST {
	# Operation Flags...
	$(OVERFLOW) = 0x0;						# V Flag
	# Operation...	
	XREG_W_AS_DEST = sext(XREG_W_AS_DEST:1);
	# Result Flags...
	$(SIGN) = (XREG_W_AS_DEST s< 0x0);			# S Flag
	$(ZERO) = (XREG_W_AS_DEST == 0x0);			# Z Flag
	$(CARRY) = (XREG_W_AS_DEST != 0x0);			# C Flag
	build postRegIncrement;
}

# Yes, for SXTX and SWPB, the normal width selectors are different.  Hence, for the A versions, we have a different dest reg subtable.
:SXTX.A XREG_A_AS_DEST2	is ctx_haveext=7 & ctx_al=0 & (op16_12_4=0x1 & op16_8_4=0x1 & op16_7_1=0x1 & bow=0x0 & postRegIncrement) ... & XREG_A_AS_DEST2 {
	# Operation Flags...
	$(OVERFLOW) = 0x0;						# V Flag
	# Operation...	
	XREG_A_AS_DEST2 = sext(XREG_A_AS_DEST2:1) & 0xfffff;
	# Result Flags...
	$(SIGN) = XREG_A_AS_DEST2[19, 1] == 1;
	$(ZERO) = (XREG_A_AS_DEST2 == 0x0);			# Z Flag
	$(CARRY) = (XREG_A_AS_DEST2 != 0x0);			# C Flag
	build postRegIncrement;
}
