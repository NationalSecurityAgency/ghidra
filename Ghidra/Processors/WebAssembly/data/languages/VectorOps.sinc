# Ghidra only supports scalars up to 64 bits
define token I128 (64)
	f128_0 = (0, 63) hex
	f128_1 = (0, 63) hex
;

define token laneidx_1 (8)
    laneidx = (0, 7) dec
    laneidx0 = (0, 7)
    laneidx1 = (0, 7)
    laneidx2 = (0, 7)
    laneidx3 = (0, 7)
;

loadaddr2: memalign memoffset is memalign; memoffset; sp2_32 {
	addr:4 = memoffset:4 + sp2_32;
	export addr;
}

sp1_lane8_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 1;] {
	export *[register]:1 tmp_sp;
}

sp1_lane16_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 2;] {
	export *[register]:2 tmp_sp;
}

sp1_lane32_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 4;] {
	export *[register]:4 tmp_sp;
}

sp1_lane64_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 8;] {
	export *[register]:8 tmp_sp;
}

sp2_lane8_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 1;] {
	export *[register]:1 tmp_sp;
}

sp2_lane16_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 2;] {
	export *[register]:2 tmp_sp;
}

sp2_lane32_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 4;] {
	export *[register]:4 tmp_sp;
}

sp2_lane64_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 8;] {
	export *[register]:8 tmp_sp;
}

# Hack to show only the lane index in the disassembly
sp1_lane8: laneidx is sp1_lane8_val & laneidx { export sp1_lane8_val; }
sp1_lane16: laneidx is sp1_lane16_val & laneidx { export sp1_lane16_val; }
sp1_lane32: laneidx is sp1_lane32_val & laneidx { export sp1_lane32_val; }
sp1_lane64: laneidx is sp1_lane64_val & laneidx { export sp1_lane64_val; }
sp2_lane8: laneidx is sp2_lane8_val & laneidx { export sp2_lane8_val; }
sp2_lane16: laneidx is sp2_lane16_val & laneidx { export sp2_lane16_val; }
sp2_lane32: laneidx is sp2_lane32_val & laneidx { export sp2_lane32_val; }
sp2_lane64: laneidx is sp2_lane64_val & laneidx { export sp2_lane64_val; }

# Hack: take advantage of the fact that sp1 is immediately after sp2 in memory,
# such that lanes 16-31 overflow into sp1.
# (For some reason, conditioning on bit (4, 4) of the laneidx did not work - sp2 was always selected)
shuf0: is sp2_lane8_val { export sp2_lane8_val; }
shuf1: is sp2_lane8_val { export sp2_lane8_val; }
shuf2: is sp2_lane8_val { export sp2_lane8_val; }
shuf3: is sp2_lane8_val { export sp2_lane8_val; }
shuf4: is sp2_lane8_val { export sp2_lane8_val; }
shuf5: is sp2_lane8_val { export sp2_lane8_val; }
shuf6: is sp2_lane8_val { export sp2_lane8_val; }
shuf7: is sp2_lane8_val { export sp2_lane8_val; }
shuf8: is sp2_lane8_val { export sp2_lane8_val; }
shuf9: is sp2_lane8_val { export sp2_lane8_val; }
shuf10: is sp2_lane8_val { export sp2_lane8_val; }
shuf11: is sp2_lane8_val { export sp2_lane8_val; }
shuf12: is sp2_lane8_val { export sp2_lane8_val; }
shuf13: is sp2_lane8_val { export sp2_lane8_val; }
shuf14: is sp2_lane8_val { export sp2_lane8_val; }
shuf15: is sp2_lane8_val { export sp2_lane8_val; }

shuf_impl: is shuf0 ; shuf1 ; shuf2 ; shuf3 ; shuf4 ; shuf5 ; shuf6 ; shuf7 ; shuf8 ; shuf9 ; shuf10 ; shuf11 ; shuf12 ; shuf13 ; shuf14 ; shuf15 {
    t0o[0,8] = shuf0;
    t0o[8,8] = shuf1;
    t0o[16,8] = shuf2;
    t0o[24,8] = shuf3;
    t0o[32,8] = shuf4;
    t0o[40,8] = shuf5;
    t0o[48,8] = shuf6;
    t0o[56,8] = shuf7;
    t0o[64,8] = shuf8;
    t0o[72,8] = shuf9;
    t0o[80,8] = shuf10;
    t0o[88,8] = shuf11;
    t0o[96,8] = shuf12;
    t0o[104,8] = shuf13;
    t0o[112,8] = shuf14;
    t0o[120,8] = shuf15;
}

laneidx0_3: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
laneidx4_7: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
laneidx8_11: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
laneidx12_15: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}

shuf_disp: laneidx0_3 laneidx4_7 laneidx8_11 laneidx12_15 is laneidx0_3 ; laneidx4_7 ; laneidx8_11 ; laneidx12_15 {
}

## Vector instructions
# [i32] -> [v128]
:v128.load loadaddr is opc=0xFD; opc2_0; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128 = *:16 loadaddr;
}

# [i32] -> [v128]
:v128.load8x8_s loadaddr is opc=0xFD; opc2_1; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128[0,16] = sext(*:1 loadaddr);
    sp1_128[16,16] = sext(*:1 (loadaddr + 1));
    sp1_128[32,16] = sext(*:1 (loadaddr + 2));
    sp1_128[48,16] = sext(*:1 (loadaddr + 3));
    sp1_128[64,16] = sext(*:1 (loadaddr + 4));
    sp1_128[80,16] = sext(*:1 (loadaddr + 5));
    sp1_128[96,16] = sext(*:1 (loadaddr + 6));
    sp1_128[112,16] = sext(*:1 (loadaddr + 7));
}

# [i32] -> [v128]
:v128.load8x8_u loadaddr is opc=0xFD; opc2_2; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128[0,16] = zext(*:1 loadaddr);
    sp1_128[16,16] = zext(*:1 (loadaddr + 1));
    sp1_128[32,16] = zext(*:1 (loadaddr + 2));
    sp1_128[48,16] = zext(*:1 (loadaddr + 3));
    sp1_128[64,16] = zext(*:1 (loadaddr + 4));
    sp1_128[80,16] = zext(*:1 (loadaddr + 5));
    sp1_128[96,16] = zext(*:1 (loadaddr + 6));
    sp1_128[112,16] = zext(*:1 (loadaddr + 7));
}

# [i32] -> [v128]
:v128.load16x4_s loadaddr is opc=0xFD; opc2_3; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128[0,32] = sext(*:2 loadaddr);
    sp1_128[32,32] = sext(*:2 (loadaddr + 2));
    sp1_128[64,32] = sext(*:2 (loadaddr + 4));
    sp1_128[96,32] = sext(*:2 (loadaddr + 6));
}

# [i32] -> [v128]
:v128.load16x4_u loadaddr is opc=0xFD; opc2_4; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128[0,32] = zext(*:2 loadaddr);
    sp1_128[32,32] = zext(*:2 (loadaddr + 2));
    sp1_128[64,32] = zext(*:2 (loadaddr + 4));
    sp1_128[96,32] = zext(*:2 (loadaddr + 6));
}

# [i32] -> [v128]
:v128.load32x2_s loadaddr is opc=0xFD; opc2_5; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128[0,64] = sext(*:4 loadaddr);
    sp1_128[64,64] = sext(*:4 (loadaddr + 4));
}

# [i32] -> [v128]
:v128.load32x2_u loadaddr is opc=0xFD; opc2_6; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128[0,64] = zext(*:4 loadaddr);
    sp1_128[64,64] = zext(*:4 (loadaddr + 4));
}

# [i32] -> [v128]
:v128.load8_splat loadaddr is opc=0xFD; opc2_7; loadaddr; sp1_128; ctx_is_directive=0 {
    local tmp:1 = *:1 loadaddr;
    sp1_128[0,8] = tmp;
    sp1_128[8,8] = tmp;
    sp1_128[16,8] = tmp;
    sp1_128[24,8] = tmp;
    sp1_128[32,8] = tmp;
    sp1_128[40,8] = tmp;
    sp1_128[48,8] = tmp;
    sp1_128[56,8] = tmp;
    sp1_128[64,8] = tmp;
    sp1_128[72,8] = tmp;
    sp1_128[80,8] = tmp;
    sp1_128[88,8] = tmp;
    sp1_128[96,8] = tmp;
    sp1_128[104,8] = tmp;
    sp1_128[112,8] = tmp;
    sp1_128[120,8] = tmp;
}

# [i32] -> [v128]
:v128.load16_splat loadaddr is opc=0xFD; opc2_8; loadaddr; sp1_128; ctx_is_directive=0 {
    local tmp:2 = *:2 loadaddr;
    sp1_128[0,16] = tmp;
    sp1_128[16,16] = tmp;
    sp1_128[32,16] = tmp;
    sp1_128[48,16] = tmp;
    sp1_128[64,16] = tmp;
    sp1_128[80,16] = tmp;
    sp1_128[96,16] = tmp;
    sp1_128[112,16] = tmp;
}

# [i32] -> [v128]
:v128.load32_splat loadaddr is opc=0xFD; opc2_9; loadaddr; sp1_128; ctx_is_directive=0 {
    local tmp:4 = *:4 loadaddr;
    sp1_128[0,32] = tmp;
    sp1_128[32,32] = tmp;
    sp1_128[64,32] = tmp;
    sp1_128[96,32] = tmp;
}

# [i32] -> [v128]
:v128.load64_splat loadaddr is opc=0xFD; opc2_10; loadaddr; sp1_128; ctx_is_directive=0 {
    local tmp:8 = *:8 loadaddr;
    sp1_128[0,64] = tmp;
    sp1_128[64,64] = tmp;
}

# [i32 v128] -> []
:v128.store storeaddr is opc=0xFD; opc2_11; storeaddr; sp1_128; ctx_is_directive=0 {
    *:16 storeaddr = sp1_128;
}

# [] -> [v128]
:v128.const "i64x2" f128_0 f128_1 is opc=0xFD; opc2_12; f128_0; f128_1; sp0_128; ctx_is_directive=0 {
    sp0_128[0,64] = f128_0;
    sp0_128[64,64] = f128_1;
}

# [v128 v128] -> [v128]
:i8x16.shuffle shuf_disp is opc=0xFD; opc2_13; ( shuf_impl & shuf_disp ) ; sp2_128; ctx_is_directive=0 {
    sp2_128 = t0o;
}

define pcodeop i8x16_swizzle;
# [v128 v128] -> [v128]
:i8x16.swizzle is opc=0xFD; opc2_14; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_swizzle(sp1_128, sp2_128);
}

# [i32] -> [v128]
:i8x16.splat is opc=0xFD; opc2_15; sp1_128; sp1_32; ctx_is_directive=0 {
    local tmp:1 = sp1_32:1;
    sp1_128[0,8] = tmp;
    sp1_128[8,8] = tmp;
    sp1_128[16,8] = tmp;
    sp1_128[24,8] = tmp;
    sp1_128[32,8] = tmp;
    sp1_128[40,8] = tmp;
    sp1_128[48,8] = tmp;
    sp1_128[56,8] = tmp;
    sp1_128[64,8] = tmp;
    sp1_128[72,8] = tmp;
    sp1_128[80,8] = tmp;
    sp1_128[88,8] = tmp;
    sp1_128[96,8] = tmp;
    sp1_128[104,8] = tmp;
    sp1_128[112,8] = tmp;
    sp1_128[120,8] = tmp;
}

# [i32] -> [v128]
:i16x8.splat is opc=0xFD; opc2_16; sp1_128; sp1_32; ctx_is_directive=0 {
    local tmp:2 = sp1_32:2;
    sp1_128[0,16] = tmp;
    sp1_128[16,16] = tmp;
    sp1_128[32,16] = tmp;
    sp1_128[48,16] = tmp;
    sp1_128[64,16] = tmp;
    sp1_128[80,16] = tmp;
    sp1_128[96,16] = tmp;
    sp1_128[112,16] = tmp;
}

# [i32] -> [v128]
:i32x4.splat is opc=0xFD; opc2_17; sp1_128; sp1_32; ctx_is_directive=0 {
    local tmp:4 = sp1_32:4;
    sp1_128[0,32] = tmp;
    sp1_128[32,32] = tmp;
    sp1_128[64,32] = tmp;
    sp1_128[96,32] = tmp;
}

# [i64] -> [v128]
:i64x2.splat is opc=0xFD; opc2_18; sp1_128; sp1_64; ctx_is_directive=0 {
    local tmp:8 = sp1_64:8;
    sp1_128[0,64] = tmp;
    sp1_128[64,64] = tmp;
}

# [f32] -> [v128]
:f32x4.splat is opc=0xFD; opc2_19; sp1_128; sp1_32; ctx_is_directive=0 {
    local tmp:4 = sp1_32:4;
    sp1_128[0,32] = tmp;
    sp1_128[32,32] = tmp;
    sp1_128[64,32] = tmp;
    sp1_128[96,32] = tmp;
}

# [f64] -> [v128]
:f64x2.splat is opc=0xFD; opc2_20; sp1_128; sp1_64; ctx_is_directive=0 {
    local tmp:8 = sp1_64:8;
    sp1_128[0,64] = tmp;
    sp1_128[64,64] = tmp;
}

# [v128] -> [i32]
:i8x16.extract_lane_s sp1_lane8 is opc=0xFD; opc2_21; sp1_lane8; sp1_32; ctx_is_directive=0 {
    sp1_32 = sext(sp1_lane8);
}

# [v128] -> [i32]
:i8x16.extract_lane_u sp1_lane8 is opc=0xFD; opc2_22; sp1_lane8; sp1_32; ctx_is_directive=0 {
    sp1_32 = zext(sp1_lane8);
}

# [v128 i32] -> [v128]
:i8x16.replace_lane sp2_lane8 is opc=0xFD; opc2_23; sp1_32; sp2_lane8; ctx_is_directive=0 {
    sp2_lane8 = sp1_32:1;
}

# [v128] -> [i32]
:i16x8.extract_lane_s sp1_lane16 is opc=0xFD; opc2_24; sp1_lane16; sp1_32; ctx_is_directive=0 {
    sp1_32 = sext(sp1_lane16);
}

# [v128] -> [i32]
:i16x8.extract_lane_u sp1_lane16 is opc=0xFD; opc2_25; sp1_lane16; sp1_32; ctx_is_directive=0 {
    sp1_32 = zext(sp1_lane16);
}

# [v128 i32] -> [v128]
:i16x8.replace_lane sp2_lane16 is opc=0xFD; opc2_26; sp1_32; sp2_lane16; ctx_is_directive=0 {
    sp2_lane16 = sp1_32:2;
}

# [v128] -> [i32]
:i32x4.extract_lane sp1_lane32 is opc=0xFD; opc2_27; sp1_lane32; sp1_32; ctx_is_directive=0 {
    sp1_32 = sp1_lane32;
}

# [v128 i32] -> [v128]
:i32x4.replace_lane sp2_lane32 is opc=0xFD; opc2_28; sp1_32; sp2_lane32; ctx_is_directive=0 {
    sp2_lane32 = sp1_32;
}

# [v128] -> [i64]
:i64x2.extract_lane sp1_lane64 is opc=0xFD; opc2_29; sp1_lane64; sp1_64; ctx_is_directive=0 {
    sp1_64 = sp1_lane64;
}

# [v128 i64] -> [v128]
:i64x2.replace_lane sp2_lane64 is opc=0xFD; opc2_30; sp1_64; sp2_lane64; ctx_is_directive=0 {
    sp2_lane64 = sp1_64;
}

# [v128] -> [f32]
:f32x4.extract_lane sp1_lane32 is opc=0xFD; opc2_31; sp1_lane32; sp1_32; ctx_is_directive=0 {
    sp1_32 = sp1_lane32;
}

# [v128 f32] -> [v128]
:f32x4.replace_lane sp2_lane32 is opc=0xFD; opc2_32; sp1_32; sp2_lane32; ctx_is_directive=0 {
    sp2_lane32 = sp1_32;
}

# [v128] -> [f64]
:f64x2.extract_lane sp1_lane64 is opc=0xFD; opc2_33; sp1_lane64; sp1_64; ctx_is_directive=0 {
    sp1_64 = sp1_lane64;
}

# [v128 f64] -> [v128]
:f64x2.replace_lane sp2_lane64 is opc=0xFD; opc2_34; sp1_64; sp2_lane64; ctx_is_directive=0 {
    sp2_lane64 = sp1_64;
}

define pcodeop i8x16_eq;
# [v128 v128] -> [v128]
:i8x16.eq is opc=0xFD; opc2_35; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_eq(sp1_128, sp2_128);
}

define pcodeop i8x16_ne;
# [v128 v128] -> [v128]
:i8x16.ne is opc=0xFD; opc2_36; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_ne(sp1_128, sp2_128);
}

define pcodeop i8x16_lt_s;
# [v128 v128] -> [v128]
:i8x16.lt_s is opc=0xFD; opc2_37; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_lt_s(sp1_128, sp2_128);
}

define pcodeop i8x16_lt_u;
# [v128 v128] -> [v128]
:i8x16.lt_u is opc=0xFD; opc2_38; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_lt_u(sp1_128, sp2_128);
}

define pcodeop i8x16_gt_s;
# [v128 v128] -> [v128]
:i8x16.gt_s is opc=0xFD; opc2_39; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_gt_s(sp1_128, sp2_128);
}

define pcodeop i8x16_gt_u;
# [v128 v128] -> [v128]
:i8x16.gt_u is opc=0xFD; opc2_40; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_gt_u(sp1_128, sp2_128);
}

define pcodeop i8x16_le_s;
# [v128 v128] -> [v128]
:i8x16.le_s is opc=0xFD; opc2_41; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_le_s(sp1_128, sp2_128);
}

define pcodeop i8x16_le_u;
# [v128 v128] -> [v128]
:i8x16.le_u is opc=0xFD; opc2_42; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_le_u(sp1_128, sp2_128);
}

define pcodeop i8x16_ge_s;
# [v128 v128] -> [v128]
:i8x16.ge_s is opc=0xFD; opc2_43; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_ge_s(sp1_128, sp2_128);
}

define pcodeop i8x16_ge_u;
# [v128 v128] -> [v128]
:i8x16.ge_u is opc=0xFD; opc2_44; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_ge_u(sp1_128, sp2_128);
}

define pcodeop i16x8_eq;
# [v128 v128] -> [v128]
:i16x8.eq is opc=0xFD; opc2_45; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_eq(sp1_128, sp2_128);
}

define pcodeop i16x8_ne;
# [v128 v128] -> [v128]
:i16x8.ne is opc=0xFD; opc2_46; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_ne(sp1_128, sp2_128);
}

define pcodeop i16x8_lt_s;
# [v128 v128] -> [v128]
:i16x8.lt_s is opc=0xFD; opc2_47; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_lt_s(sp1_128, sp2_128);
}

define pcodeop i16x8_lt_u;
# [v128 v128] -> [v128]
:i16x8.lt_u is opc=0xFD; opc2_48; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_lt_u(sp1_128, sp2_128);
}

define pcodeop i16x8_gt_s;
# [v128 v128] -> [v128]
:i16x8.gt_s is opc=0xFD; opc2_49; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_gt_s(sp1_128, sp2_128);
}

define pcodeop i16x8_gt_u;
# [v128 v128] -> [v128]
:i16x8.gt_u is opc=0xFD; opc2_50; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_gt_u(sp1_128, sp2_128);
}

define pcodeop i16x8_le_s;
# [v128 v128] -> [v128]
:i16x8.le_s is opc=0xFD; opc2_51; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_le_s(sp1_128, sp2_128);
}

define pcodeop i16x8_le_u;
# [v128 v128] -> [v128]
:i16x8.le_u is opc=0xFD; opc2_52; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_le_u(sp1_128, sp2_128);
}

define pcodeop i16x8_ge_s;
# [v128 v128] -> [v128]
:i16x8.ge_s is opc=0xFD; opc2_53; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_ge_s(sp1_128, sp2_128);
}

define pcodeop i16x8_ge_u;
# [v128 v128] -> [v128]
:i16x8.ge_u is opc=0xFD; opc2_54; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_ge_u(sp1_128, sp2_128);
}

define pcodeop i32x4_eq;
# [v128 v128] -> [v128]
:i32x4.eq is opc=0xFD; opc2_55; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_eq(sp1_128, sp2_128);
}

define pcodeop i32x4_ne;
# [v128 v128] -> [v128]
:i32x4.ne is opc=0xFD; opc2_56; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_ne(sp1_128, sp2_128);
}

define pcodeop i32x4_lt_s;
# [v128 v128] -> [v128]
:i32x4.lt_s is opc=0xFD; opc2_57; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_lt_s(sp1_128, sp2_128);
}

define pcodeop i32x4_lt_u;
# [v128 v128] -> [v128]
:i32x4.lt_u is opc=0xFD; opc2_58; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_lt_u(sp1_128, sp2_128);
}

define pcodeop i32x4_gt_s;
# [v128 v128] -> [v128]
:i32x4.gt_s is opc=0xFD; opc2_59; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_gt_s(sp1_128, sp2_128);
}

define pcodeop i32x4_gt_u;
# [v128 v128] -> [v128]
:i32x4.gt_u is opc=0xFD; opc2_60; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_gt_u(sp1_128, sp2_128);
}

define pcodeop i32x4_le_s;
# [v128 v128] -> [v128]
:i32x4.le_s is opc=0xFD; opc2_61; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_le_s(sp1_128, sp2_128);
}

define pcodeop i32x4_le_u;
# [v128 v128] -> [v128]
:i32x4.le_u is opc=0xFD; opc2_62; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_le_u(sp1_128, sp2_128);
}

define pcodeop i32x4_ge_s;
# [v128 v128] -> [v128]
:i32x4.ge_s is opc=0xFD; opc2_63; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_ge_s(sp1_128, sp2_128);
}

define pcodeop i32x4_ge_u;
# [v128 v128] -> [v128]
:i32x4.ge_u is opc=0xFD; opc2_64; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_ge_u(sp1_128, sp2_128);
}

define pcodeop f32x4_eq;
# [v128 v128] -> [v128]
:f32x4.eq is opc=0xFD; opc2_65; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_eq(sp1_128, sp2_128);
}

define pcodeop f32x4_ne;
# [v128 v128] -> [v128]
:f32x4.ne is opc=0xFD; opc2_66; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_ne(sp1_128, sp2_128);
}

define pcodeop f32x4_lt;
# [v128 v128] -> [v128]
:f32x4.lt is opc=0xFD; opc2_67; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_lt(sp1_128, sp2_128);
}

define pcodeop f32x4_gt;
# [v128 v128] -> [v128]
:f32x4.gt is opc=0xFD; opc2_68; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_gt(sp1_128, sp2_128);
}

define pcodeop f32x4_le;
# [v128 v128] -> [v128]
:f32x4.le is opc=0xFD; opc2_69; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_le(sp1_128, sp2_128);
}

define pcodeop f32x4_ge;
# [v128 v128] -> [v128]
:f32x4.ge is opc=0xFD; opc2_70; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_ge(sp1_128, sp2_128);
}

define pcodeop f64x2_eq;
# [v128 v128] -> [v128]
:f64x2.eq is opc=0xFD; opc2_71; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_eq(sp1_128, sp2_128);
}

define pcodeop f64x2_ne;
# [v128 v128] -> [v128]
:f64x2.ne is opc=0xFD; opc2_72; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_ne(sp1_128, sp2_128);
}

define pcodeop f64x2_lt;
# [v128 v128] -> [v128]
:f64x2.lt is opc=0xFD; opc2_73; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_lt(sp1_128, sp2_128);
}

define pcodeop f64x2_gt;
# [v128 v128] -> [v128]
:f64x2.gt is opc=0xFD; opc2_74; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_gt(sp1_128, sp2_128);
}

define pcodeop f64x2_le;
# [v128 v128] -> [v128]
:f64x2.le is opc=0xFD; opc2_75; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_le(sp1_128, sp2_128);
}

define pcodeop f64x2_ge;
# [v128 v128] -> [v128]
:f64x2.ge is opc=0xFD; opc2_76; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_ge(sp1_128, sp2_128);
}

# [v128] -> [v128]
:v128.not is opc=0xFD; opc2_77; sp1_128; ctx_is_directive=0 {
    sp1_128 = ~sp1_128;
}

# [v128 v128] -> [v128]
:v128.and is opc=0xFD; opc2_78; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = sp2_128 & sp1_128;
}

# [v128 v128] -> [v128]
:v128.andnot is opc=0xFD; opc2_79; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = sp2_128 & ~sp1_128;
}

# [v128 v128] -> [v128]
:v128.or is opc=0xFD; opc2_80; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = sp2_128 | sp1_128;
}

# [v128 v128] -> [v128]
:v128.xor is opc=0xFD; opc2_81; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = sp2_128 ^ sp1_128;
}

define pcodeop v128_bitselect;
# [v128 v128 v128] -> [v128]
:v128.bitselect is opc=0xFD; opc2_82; sp1_128; sp2_128; sp3_128; ctx_is_directive=0 {
    sp3_128 = v128_bitselect(sp1_128, sp2_128, sp3_128);
}

# [v128] -> [i32]
:v128.any_true is opc=0xFD; opc2_83; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = zext(sp1_128 != 0);
}

# [i32 v128] -> [v128]
:v128.load8_lane loadaddr2 sp2_lane8 is opc=0xFD; opc2_84; loadaddr2; sp1_128; sp2_128; sp2_lane8; ctx_is_directive=0 {
    sp2_128 = sp1_128;
    sp2_lane8 = *:1 loadaddr2;
}

# [i32 v128] -> [v128]
:v128.load16_lane loadaddr2 sp2_lane16 is opc=0xFD; opc2_85; loadaddr2; sp1_128; sp2_128; sp2_lane16; ctx_is_directive=0 {
    sp2_128 = sp1_128;
    sp2_lane16 = *:2 loadaddr2;
}

# [i32 v128] -> [v128]
:v128.load32_lane loadaddr2 sp2_lane32 is opc=0xFD; opc2_86; loadaddr2; sp1_128; sp2_128; sp2_lane32; ctx_is_directive=0 {
    sp2_128 = sp1_128;
    sp2_lane32 = *:4 loadaddr2;
}

# [i32 v128] -> [v128]
:v128.load64_lane loadaddr2 sp2_lane64 is opc=0xFD; opc2_87; loadaddr2; sp1_128; sp2_128; sp2_lane64; ctx_is_directive=0 {
    sp2_128 = sp1_128;
    sp2_lane64 = *:8 loadaddr2;
}

# [i32 v128] -> []
:v128.store8_lane storeaddr sp1_lane8 is opc=0xFD; opc2_88; storeaddr; sp1_lane8; ctx_is_directive=0 {
    *:1 storeaddr = sp1_lane8;
}

# [i32 v128] -> []
:v128.store16_lane storeaddr sp1_lane16 is opc=0xFD; opc2_89; storeaddr; sp1_lane16; ctx_is_directive=0 {
    *:2 storeaddr = sp1_lane16;
}

# [i32 v128] -> []
:v128.store32_lane storeaddr sp1_lane32 is opc=0xFD; opc2_90; storeaddr; sp1_lane32; ctx_is_directive=0 {
    *:4 storeaddr = sp1_lane32;
}

# [i32 v128] -> []
:v128.store64_lane storeaddr sp1_lane64 is opc=0xFD; opc2_91; storeaddr; sp1_lane64; ctx_is_directive=0 {
    *:8 storeaddr = sp1_lane64;
}

# [i32] -> [v128]
:v128.load32_zero loadaddr is opc=0xFD; opc2_92; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128 = zext(*:4 loadaddr);
}

# [i32] -> [v128]
:v128.load64_zero loadaddr is opc=0xFD; opc2_93; loadaddr; sp1_128; ctx_is_directive=0 {
    sp1_128 = zext(*:8 loadaddr);
}

# [v128] -> [v128]
:f32x4.demote_f64x2_zero is opc=0xFD; opc2_94; sp1_128; ctx_is_directive=0 {
    t0o = 0;
    t0o[0, 32] = float2float(sp1_128[0, 64]);
    t0o[32, 32] = float2float(sp1_128[64, 64]);
    sp1_128 = t0o;
}

# [v128] -> [v128]
:f64x2.promote_low_f32x4 is opc=0xFD; opc2_95; sp1_128; ctx_is_directive=0 {
    t0o[0, 64] = float2float(sp1_128[0, 32]);
    t0o[64, 64] = float2float(sp1_128[32, 32]);
    sp1_128 = t0o;
}

define pcodeop i8x16_abs;
# [v128] -> [v128]
:i8x16.abs is opc=0xFD; opc2_96; sp1_128; ctx_is_directive=0 {
    sp1_128 = i8x16_abs(sp1_128);
}

# [v128] -> [v128]
:i8x16.neg is opc=0xFD; opc2_97; sp1_128; ctx_is_directive=0 {
    sp1_128[  0,8] = -sp1_128[  0,8];
    sp1_128[  8,8] = -sp1_128[  8,8];
    sp1_128[ 16,8] = -sp1_128[ 16,8];
    sp1_128[ 24,8] = -sp1_128[ 24,8];
    sp1_128[ 32,8] = -sp1_128[ 32,8];
    sp1_128[ 40,8] = -sp1_128[ 40,8];
    sp1_128[ 48,8] = -sp1_128[ 48,8];
    sp1_128[ 56,8] = -sp1_128[ 56,8];
    sp1_128[ 64,8] = -sp1_128[ 64,8];
    sp1_128[ 72,8] = -sp1_128[ 72,8];
    sp1_128[ 80,8] = -sp1_128[ 80,8];
    sp1_128[ 88,8] = -sp1_128[ 88,8];
    sp1_128[ 96,8] = -sp1_128[ 96,8];
    sp1_128[104,8] = -sp1_128[104,8];
    sp1_128[112,8] = -sp1_128[112,8];
    sp1_128[120,8] = -sp1_128[120,8];
}

define pcodeop i8x16_popcnt;
# [v128] -> [v128]
:i8x16.popcnt is opc=0xFD; opc2_98; sp1_128; ctx_is_directive=0 {
    sp1_128 = i8x16_popcnt(sp1_128);
}

define pcodeop i8x16_all_true;
# [v128] -> [i32]
:i8x16.all_true is opc=0xFD; opc2_99; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i8x16_all_true(sp1_128);
}

define pcodeop i8x16_bitmask;
# [v128] -> [i32]
:i8x16.bitmask is opc=0xFD; opc2_100; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i8x16_bitmask(sp1_128);
}

define pcodeop i8x16_narrow_i16x8_s;
# [v128 v128] -> [v128]
:i8x16.narrow_i16x8_s is opc=0xFD; opc2_101; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_narrow_i16x8_s(sp1_128, sp2_128);
}

define pcodeop i8x16_narrow_i16x8_u;
# [v128 v128] -> [v128]
:i8x16.narrow_i16x8_u is opc=0xFD; opc2_102; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_narrow_i16x8_u(sp1_128, sp2_128);
}

define pcodeop f32x4_ceil;
# [v128] -> [v128]
:f32x4.ceil is opc=0xFD; opc2_103; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_ceil(sp1_128);
}

define pcodeop f32x4_floor;
# [v128] -> [v128]
:f32x4.floor is opc=0xFD; opc2_104; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_floor(sp1_128);
}

define pcodeop f32x4_trunc;
# [v128] -> [v128]
:f32x4.trunc is opc=0xFD; opc2_105; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_trunc(sp1_128);
}

define pcodeop f32x4_nearest;
# [v128] -> [v128]
:f32x4.nearest is opc=0xFD; opc2_106; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_nearest(sp1_128);
}

define pcodeop i8x16_shl;
# [v128 i32] -> [v128]
:i8x16.shl is opc=0xFD; opc2_107; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_shl(sp1_32, sp2_128);
}

define pcodeop i8x16_shr_s;
# [v128 i32] -> [v128]
:i8x16.shr_s is opc=0xFD; opc2_108; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_shr_s(sp1_32, sp2_128);
}

define pcodeop i8x16_shr_u;
# [v128 i32] -> [v128]
:i8x16.shr_u is opc=0xFD; opc2_109; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_shr_u(sp1_32, sp2_128);
}

# [v128 v128] -> [v128]
:i8x16.add is opc=0xFD; opc2_110; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,8] = sp2_128[  0,8] + sp1_128[  0,8];
    sp2_128[  8,8] = sp2_128[  8,8] + sp1_128[  8,8];
    sp2_128[ 16,8] = sp2_128[ 16,8] + sp1_128[ 16,8];
    sp2_128[ 24,8] = sp2_128[ 24,8] + sp1_128[ 24,8];
    sp2_128[ 32,8] = sp2_128[ 32,8] + sp1_128[ 32,8];
    sp2_128[ 40,8] = sp2_128[ 40,8] + sp1_128[ 40,8];
    sp2_128[ 48,8] = sp2_128[ 48,8] + sp1_128[ 48,8];
    sp2_128[ 56,8] = sp2_128[ 56,8] + sp1_128[ 56,8];
    sp2_128[ 64,8] = sp2_128[ 64,8] + sp1_128[ 64,8];
    sp2_128[ 72,8] = sp2_128[ 72,8] + sp1_128[ 72,8];
    sp2_128[ 80,8] = sp2_128[ 80,8] + sp1_128[ 80,8];
    sp2_128[ 88,8] = sp2_128[ 88,8] + sp1_128[ 88,8];
    sp2_128[ 96,8] = sp2_128[ 96,8] + sp1_128[ 96,8];
    sp2_128[104,8] = sp2_128[104,8] + sp1_128[104,8];
    sp2_128[112,8] = sp2_128[112,8] + sp1_128[112,8];
    sp2_128[120,8] = sp2_128[120,8] + sp1_128[120,8];
}

define pcodeop i8x16_add_sat_s;
# [v128 v128] -> [v128]
:i8x16.add_sat_s is opc=0xFD; opc2_111; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_add_sat_s(sp1_128, sp2_128);
}

define pcodeop i8x16_add_sat_u;
# [v128 v128] -> [v128]
:i8x16.add_sat_u is opc=0xFD; opc2_112; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_add_sat_u(sp1_128, sp2_128);
}

# [v128 v128] -> [v128]
:i8x16.sub is opc=0xFD; opc2_113; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,8] = sp2_128[  0,8] - sp1_128[  0,8];
    sp2_128[  8,8] = sp2_128[  8,8] - sp1_128[  8,8];
    sp2_128[ 16,8] = sp2_128[ 16,8] - sp1_128[ 16,8];
    sp2_128[ 24,8] = sp2_128[ 24,8] - sp1_128[ 24,8];
    sp2_128[ 32,8] = sp2_128[ 32,8] - sp1_128[ 32,8];
    sp2_128[ 40,8] = sp2_128[ 40,8] - sp1_128[ 40,8];
    sp2_128[ 48,8] = sp2_128[ 48,8] - sp1_128[ 48,8];
    sp2_128[ 56,8] = sp2_128[ 56,8] - sp1_128[ 56,8];
    sp2_128[ 64,8] = sp2_128[ 64,8] - sp1_128[ 64,8];
    sp2_128[ 72,8] = sp2_128[ 72,8] - sp1_128[ 72,8];
    sp2_128[ 80,8] = sp2_128[ 80,8] - sp1_128[ 80,8];
    sp2_128[ 88,8] = sp2_128[ 88,8] - sp1_128[ 88,8];
    sp2_128[ 96,8] = sp2_128[ 96,8] - sp1_128[ 96,8];
    sp2_128[104,8] = sp2_128[104,8] - sp1_128[104,8];
    sp2_128[112,8] = sp2_128[112,8] - sp1_128[112,8];
    sp2_128[120,8] = sp2_128[120,8] - sp1_128[120,8];
}

define pcodeop i8x16_sub_sat_s;
# [v128 v128] -> [v128]
:i8x16.sub_sat_s is opc=0xFD; opc2_114; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_sub_sat_s(sp1_128, sp2_128);
}

define pcodeop i8x16_sub_sat_u;
# [v128 v128] -> [v128]
:i8x16.sub_sat_u is opc=0xFD; opc2_115; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_sub_sat_u(sp1_128, sp2_128);
}

define pcodeop f64x2_ceil;
# [v128] -> [v128]
:f64x2.ceil is opc=0xFD; opc2_116; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_ceil(sp1_128);
}

define pcodeop f64x2_floor;
# [v128] -> [v128]
:f64x2.floor is opc=0xFD; opc2_117; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_floor(sp1_128);
}

define pcodeop i8x16_min_s;
# [v128 v128] -> [v128]
:i8x16.min_s is opc=0xFD; opc2_118; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_min_s(sp1_128, sp2_128);
}

define pcodeop i8x16_min_u;
# [v128 v128] -> [v128]
:i8x16.min_u is opc=0xFD; opc2_119; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_min_u(sp1_128, sp2_128);
}

define pcodeop i8x16_max_s;
# [v128 v128] -> [v128]
:i8x16.max_s is opc=0xFD; opc2_120; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_max_s(sp1_128, sp2_128);
}

define pcodeop i8x16_max_u;
# [v128 v128] -> [v128]
:i8x16.max_u is opc=0xFD; opc2_121; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_max_u(sp1_128, sp2_128);
}

define pcodeop f64x2_trunc;
# [v128] -> [v128]
:f64x2.trunc is opc=0xFD; opc2_122; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_trunc(sp1_128);
}

define pcodeop i8x16_avgr_u;
# [v128 v128] -> [v128]
:i8x16.avgr_u is opc=0xFD; opc2_123; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i8x16_avgr_u(sp1_128, sp2_128);
}

define pcodeop i16x8_extadd_pairwise_i8x16_s;
# [v128] -> [v128]
:i16x8.extadd_pairwise_i8x16_s is opc=0xFD; opc2_124; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_extadd_pairwise_i8x16_s(sp1_128);
}

define pcodeop i16x8_extadd_pairwise_i8x16_u;
# [v128] -> [v128]
:i16x8.extadd_pairwise_i8x16_u is opc=0xFD; opc2_125; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_extadd_pairwise_i8x16_u(sp1_128);
}

define pcodeop i32x4_extadd_pairwise_i16x8_s;
# [v128] -> [v128]
:i32x4.extadd_pairwise_i16x8_s is opc=0xFD; opc2_126; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_extadd_pairwise_i16x8_s(sp1_128);
}

define pcodeop i32x4_extadd_pairwise_i16x8_u;
# [v128] -> [v128]
:i32x4.extadd_pairwise_i16x8_u is opc=0xFD; opc2_127; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_extadd_pairwise_i16x8_u(sp1_128);
}

define pcodeop i16x8_abs;
# [v128] -> [v128]
:i16x8.abs is opc=0xFD; opc2_128; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_abs(sp1_128);
}

# [v128] -> [v128]
:i16x8.neg is opc=0xFD; opc2_129; sp1_128; ctx_is_directive=0 {
    sp1_128[  0,16] = -sp1_128[  0,16];
    sp1_128[ 16,16] = -sp1_128[ 16,16];
    sp1_128[ 32,16] = -sp1_128[ 32,16];
    sp1_128[ 48,16] = -sp1_128[ 48,16];
    sp1_128[ 64,16] = -sp1_128[ 64,16];
    sp1_128[ 80,16] = -sp1_128[ 80,16];
    sp1_128[ 96,16] = -sp1_128[ 96,16];
    sp1_128[112,16] = -sp1_128[112,16];
}

define pcodeop i16x8_q15mulr_sat_s;
# [v128 v128] -> [v128]
:i16x8.q15mulr_sat_s is opc=0xFD; opc2_130; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_q15mulr_sat_s(sp1_128, sp2_128);
}

define pcodeop i16x8_all_true;
# [v128] -> [i32]
:i16x8.all_true is opc=0xFD; opc2_131; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i16x8_all_true(sp1_128);
}

define pcodeop i16x8_bitmask;
# [v128] -> [i32]
:i16x8.bitmask is opc=0xFD; opc2_132; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i16x8_bitmask(sp1_128);
}

define pcodeop i16x8_narrow_i32x4_s;
# [v128 v128] -> [v128]
:i16x8.narrow_i32x4_s is opc=0xFD; opc2_133; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_narrow_i32x4_s(sp1_128, sp2_128);
}

define pcodeop i16x8_narrow_i32x4_u;
# [v128 v128] -> [v128]
:i16x8.narrow_i32x4_u is opc=0xFD; opc2_134; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_narrow_i32x4_u(sp1_128, sp2_128);
}

define pcodeop i16x8_extend_low_i8x16_s;
# [v128] -> [v128]
:i16x8.extend_low_i8x16_s is opc=0xFD; opc2_135; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_extend_low_i8x16_s(sp1_128);
}

define pcodeop i16x8_extend_high_i8x16_s;
# [v128] -> [v128]
:i16x8.extend_high_i8x16_s is opc=0xFD; opc2_136; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_extend_high_i8x16_s(sp1_128);
}

define pcodeop i16x8_extend_low_i8x16_u;
# [v128] -> [v128]
:i16x8.extend_low_i8x16_u is opc=0xFD; opc2_137; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_extend_low_i8x16_u(sp1_128);
}

define pcodeop i16x8_extend_high_i8x16_u;
# [v128] -> [v128]
:i16x8.extend_high_i8x16_u is opc=0xFD; opc2_138; sp1_128; ctx_is_directive=0 {
    sp1_128 = i16x8_extend_high_i8x16_u(sp1_128);
}

define pcodeop i16x8_shl;
# [v128 i32] -> [v128]
:i16x8.shl is opc=0xFD; opc2_139; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_shl(sp1_32, sp2_128);
}

define pcodeop i16x8_shr_s;
# [v128 i32] -> [v128]
:i16x8.shr_s is opc=0xFD; opc2_140; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_shr_s(sp1_32, sp2_128);
}

define pcodeop i16x8_shr_u;
# [v128 i32] -> [v128]
:i16x8.shr_u is opc=0xFD; opc2_141; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_shr_u(sp1_32, sp2_128);
}

# [v128 v128] -> [v128]
:i16x8.add is opc=0xFD; opc2_142; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,16] = sp2_128[  0,16] + sp1_128[  0,16];
    sp2_128[ 16,16] = sp2_128[ 16,16] + sp1_128[ 16,16];
    sp2_128[ 32,16] = sp2_128[ 32,16] + sp1_128[ 32,16];
    sp2_128[ 48,16] = sp2_128[ 48,16] + sp1_128[ 48,16];
    sp2_128[ 64,16] = sp2_128[ 64,16] + sp1_128[ 64,16];
    sp2_128[ 80,16] = sp2_128[ 80,16] + sp1_128[ 80,16];
    sp2_128[ 96,16] = sp2_128[ 96,16] + sp1_128[ 96,16];
    sp2_128[112,16] = sp2_128[112,16] + sp1_128[112,16];
}

define pcodeop i16x8_add_sat_s;
# [v128 v128] -> [v128]
:i16x8.add_sat_s is opc=0xFD; opc2_143; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_add_sat_s(sp1_128, sp2_128);
}

define pcodeop i16x8_add_sat_u;
# [v128 v128] -> [v128]
:i16x8.add_sat_u is opc=0xFD; opc2_144; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_add_sat_u(sp1_128, sp2_128);
}

# [v128 v128] -> [v128]
:i16x8.sub is opc=0xFD; opc2_145; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,16] = sp2_128[  0,16] - sp1_128[  0,16];
    sp2_128[ 16,16] = sp2_128[ 16,16] - sp1_128[ 16,16];
    sp2_128[ 32,16] = sp2_128[ 32,16] - sp1_128[ 32,16];
    sp2_128[ 48,16] = sp2_128[ 48,16] - sp1_128[ 48,16];
    sp2_128[ 64,16] = sp2_128[ 64,16] - sp1_128[ 64,16];
    sp2_128[ 80,16] = sp2_128[ 80,16] - sp1_128[ 80,16];
    sp2_128[ 96,16] = sp2_128[ 96,16] - sp1_128[ 96,16];
    sp2_128[112,16] = sp2_128[112,16] - sp1_128[112,16];
}

define pcodeop i16x8_sub_sat_s;
# [v128 v128] -> [v128]
:i16x8.sub_sat_s is opc=0xFD; opc2_146; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_sub_sat_s(sp1_128, sp2_128);
}

define pcodeop i16x8_sub_sat_u;
# [v128 v128] -> [v128]
:i16x8.sub_sat_u is opc=0xFD; opc2_147; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_sub_sat_u(sp1_128, sp2_128);
}

define pcodeop f64x2_nearest;
# [v128] -> [v128]
:f64x2.nearest is opc=0xFD; opc2_148; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_nearest(sp1_128);
}

define pcodeop i16x8_mul;
# [v128 v128] -> [v128]
:i16x8.mul is opc=0xFD; opc2_149; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_mul(sp1_128, sp2_128);
}

define pcodeop i16x8_min_s;
# [v128 v128] -> [v128]
:i16x8.min_s is opc=0xFD; opc2_150; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_min_s(sp1_128, sp2_128);
}

define pcodeop i16x8_min_u;
# [v128 v128] -> [v128]
:i16x8.min_u is opc=0xFD; opc2_151; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_min_u(sp1_128, sp2_128);
}

define pcodeop i16x8_max_s;
# [v128 v128] -> [v128]
:i16x8.max_s is opc=0xFD; opc2_152; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_max_s(sp1_128, sp2_128);
}

define pcodeop i16x8_max_u;
# [v128 v128] -> [v128]
:i16x8.max_u is opc=0xFD; opc2_153; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_max_u(sp1_128, sp2_128);
}

define pcodeop i16x8_avgr_u;
# [v128 v128] -> [v128]
:i16x8.avgr_u is opc=0xFD; opc2_155; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_avgr_u(sp1_128, sp2_128);
}

define pcodeop i16x8_extmul_low_i8x16_s;
# [v128 v128] -> [v128]
:i16x8.extmul_low_i8x16_s is opc=0xFD; opc2_156; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_extmul_low_i8x16_s(sp1_128, sp2_128);
}

define pcodeop i16x8_extmul_high_i8x16_s;
# [v128 v128] -> [v128]
:i16x8.extmul_high_i8x16_s is opc=0xFD; opc2_157; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_extmul_high_i8x16_s(sp1_128, sp2_128);
}

define pcodeop i16x8_extmul_low_i8x16_u;
# [v128 v128] -> [v128]
:i16x8.extmul_low_i8x16_u is opc=0xFD; opc2_158; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_extmul_low_i8x16_u(sp1_128, sp2_128);
}

define pcodeop i16x8_extmul_high_i8x16_u;
# [v128 v128] -> [v128]
:i16x8.extmul_high_i8x16_u is opc=0xFD; opc2_159; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i16x8_extmul_high_i8x16_u(sp1_128, sp2_128);
}

define pcodeop i32x4_abs;
# [v128] -> [v128]
:i32x4.abs is opc=0xFD; opc2_160; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_abs(sp1_128);
}

# [v128] -> [v128]
:i32x4.neg is opc=0xFD; opc2_161; sp1_128; ctx_is_directive=0 {
    sp1_128[  0,32] = -sp1_128[  0,32];
    sp1_128[ 32,32] = -sp1_128[ 32,32];
    sp1_128[ 64,32] = -sp1_128[ 64,32];
    sp1_128[ 96,32] = -sp1_128[ 96,32];
}

define pcodeop i32x4_all_true;
# [v128] -> [i32]
:i32x4.all_true is opc=0xFD; opc2_163; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i32x4_all_true(sp1_128);
}

define pcodeop i32x4_bitmask;
# [v128] -> [i32]
:i32x4.bitmask is opc=0xFD; opc2_164; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i32x4_bitmask(sp1_128);
}

define pcodeop i32x4_extend_low_i16x8_s;
# [v128] -> [v128]
:i32x4.extend_low_i16x8_s is opc=0xFD; opc2_167; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_extend_low_i16x8_s(sp1_128);
}

define pcodeop i32x4_extend_high_i16x8_s;
# [v128] -> [v128]
:i32x4.extend_high_i16x8_s is opc=0xFD; opc2_168; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_extend_high_i16x8_s(sp1_128);
}

define pcodeop i32x4_extend_low_i16x8_u;
# [v128] -> [v128]
:i32x4.extend_low_i16x8_u is opc=0xFD; opc2_169; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_extend_low_i16x8_u(sp1_128);
}

define pcodeop i32x4_extend_high_i16x8_u;
# [v128] -> [v128]
:i32x4.extend_high_i16x8_u is opc=0xFD; opc2_170; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_extend_high_i16x8_u(sp1_128);
}

define pcodeop i32x4_shl;
# [v128 i32] -> [v128]
:i32x4.shl is opc=0xFD; opc2_171; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_shl(sp1_32, sp2_128);
}

define pcodeop i32x4_shr_s;
# [v128 i32] -> [v128]
:i32x4.shr_s is opc=0xFD; opc2_172; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_shr_s(sp1_32, sp2_128);
}

define pcodeop i32x4_shr_u;
# [v128 i32] -> [v128]
:i32x4.shr_u is opc=0xFD; opc2_173; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_shr_u(sp1_32, sp2_128);
}

# [v128 v128] -> [v128]
:i32x4.add is opc=0xFD; opc2_174; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,32] = sp2_128[  0,32] + sp1_128[  0,32];
    sp2_128[ 32,32] = sp2_128[ 32,32] + sp1_128[ 32,32];
    sp2_128[ 64,32] = sp2_128[ 64,32] + sp1_128[ 64,32];
    sp2_128[ 96,32] = sp2_128[ 96,32] + sp1_128[ 96,32];
}

# [v128 v128] -> [v128]
:i32x4.sub is opc=0xFD; opc2_177; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,32] = sp2_128[  0,32] - sp1_128[  0,32];
    sp2_128[ 32,32] = sp2_128[ 32,32] - sp1_128[ 32,32];
    sp2_128[ 64,32] = sp2_128[ 64,32] - sp1_128[ 64,32];
    sp2_128[ 96,32] = sp2_128[ 96,32] - sp1_128[ 96,32];
}

define pcodeop i32x4_mul;
# [v128 v128] -> [v128]
:i32x4.mul is opc=0xFD; opc2_181; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_mul(sp1_128, sp2_128);
}

define pcodeop i32x4_min_s;
# [v128 v128] -> [v128]
:i32x4.min_s is opc=0xFD; opc2_182; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_min_s(sp1_128, sp2_128);
}

define pcodeop i32x4_min_u;
# [v128 v128] -> [v128]
:i32x4.min_u is opc=0xFD; opc2_183; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_min_u(sp1_128, sp2_128);
}

define pcodeop i32x4_max_s;
# [v128 v128] -> [v128]
:i32x4.max_s is opc=0xFD; opc2_184; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_max_s(sp1_128, sp2_128);
}

define pcodeop i32x4_max_u;
# [v128 v128] -> [v128]
:i32x4.max_u is opc=0xFD; opc2_185; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_max_u(sp1_128, sp2_128);
}

define pcodeop i32x4_dot_i16x8_s;
# [v128 v128] -> [v128]
:i32x4.dot_i16x8_s is opc=0xFD; opc2_186; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_dot_i16x8_s(sp1_128, sp2_128);
}

define pcodeop i32x4_extmul_low_i16x8_s;
# [v128 v128] -> [v128]
:i32x4.extmul_low_i16x8_s is opc=0xFD; opc2_188; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_extmul_low_i16x8_s(sp1_128, sp2_128);
}

define pcodeop i32x4_extmul_high_i16x8_s;
# [v128 v128] -> [v128]
:i32x4.extmul_high_i16x8_s is opc=0xFD; opc2_189; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_extmul_high_i16x8_s(sp1_128, sp2_128);
}

define pcodeop i32x4_extmul_low_i16x8_u;
# [v128 v128] -> [v128]
:i32x4.extmul_low_i16x8_u is opc=0xFD; opc2_190; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_extmul_low_i16x8_u(sp1_128, sp2_128);
}

define pcodeop i32x4_extmul_high_i16x8_u;
# [v128 v128] -> [v128]
:i32x4.extmul_high_i16x8_u is opc=0xFD; opc2_191; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i32x4_extmul_high_i16x8_u(sp1_128, sp2_128);
}

define pcodeop i64x2_abs;
# [v128] -> [v128]
:i64x2.abs is opc=0xFD; opc2_192; sp1_128; ctx_is_directive=0 {
    sp1_128 = i64x2_abs(sp1_128);
}

# [v128] -> [v128]
:i64x2.neg is opc=0xFD; opc2_193; sp1_128; ctx_is_directive=0 {
    sp1_128[  0,64] = -sp1_128[  0,64];
    sp1_128[ 64,64] = -sp1_128[ 64,64];
}

define pcodeop i64x2_all_true;
# [v128] -> [i32]
:i64x2.all_true is opc=0xFD; opc2_195; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i64x2_all_true(sp1_128);
}

define pcodeop i64x2_bitmask;
# [v128] -> [i32]
:i64x2.bitmask is opc=0xFD; opc2_196; sp1_128; sp1_32; ctx_is_directive=0 {
    sp1_32 = i64x2_bitmask(sp1_128);
}

define pcodeop i64x2_extend_low_i32x4_s;
# [v128] -> [v128]
:i64x2.extend_low_i32x4_s is opc=0xFD; opc2_199; sp1_128; ctx_is_directive=0 {
    sp1_128 = i64x2_extend_low_i32x4_s(sp1_128);
}

define pcodeop i64x2_extend_high_i32x4_s;
# [v128] -> [v128]
:i64x2.extend_high_i32x4_s is opc=0xFD; opc2_200; sp1_128; ctx_is_directive=0 {
    sp1_128 = i64x2_extend_high_i32x4_s(sp1_128);
}

define pcodeop i64x2_extend_low_i32x4_u;
# [v128] -> [v128]
:i64x2.extend_low_i32x4_u is opc=0xFD; opc2_201; sp1_128; ctx_is_directive=0 {
    sp1_128 = i64x2_extend_low_i32x4_u(sp1_128);
}

define pcodeop i64x2_extend_high_i32x4_u;
# [v128] -> [v128]
:i64x2.extend_high_i32x4_u is opc=0xFD; opc2_202; sp1_128; ctx_is_directive=0 {
    sp1_128 = i64x2_extend_high_i32x4_u(sp1_128);
}

define pcodeop i64x2_shl;
# [v128 i32] -> [v128]
:i64x2.shl is opc=0xFD; opc2_203; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_shl(sp1_32, sp2_128);
}

define pcodeop i64x2_shr_s;
# [v128 i32] -> [v128]
:i64x2.shr_s is opc=0xFD; opc2_204; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_shr_s(sp1_32, sp2_128);
}

define pcodeop i64x2_shr_u;
# [v128 i32] -> [v128]
:i64x2.shr_u is opc=0xFD; opc2_205; sp1_32; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_shr_u(sp1_32, sp2_128);
}

# [v128 v128] -> [v128]
:i64x2.add is opc=0xFD; opc2_206; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,64] = sp2_128[  0,64] + sp1_128[  0,64];
    sp2_128[ 64,64] = sp2_128[ 64,64] + sp1_128[ 64,64];
}

# [v128 v128] -> [v128]
:i64x2.sub is opc=0xFD; opc2_209; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,64] = sp2_128[  0,64] - sp1_128[  0,64];
    sp2_128[ 64,64] = sp2_128[ 64,64] - sp1_128[ 64,64];
}

define pcodeop i64x2_mul;
# [v128 v128] -> [v128]
:i64x2.mul is opc=0xFD; opc2_213; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_mul(sp1_128, sp2_128);
}

define pcodeop i64x2_eq;
# [v128 v128] -> [v128]
:i64x2.eq is opc=0xFD; opc2_214; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_eq(sp1_128, sp2_128);
}

define pcodeop i64x2_ne;
# [v128 v128] -> [v128]
:i64x2.ne is opc=0xFD; opc2_215; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_ne(sp1_128, sp2_128);
}

define pcodeop i64x2_lt_s;
# [v128 v128] -> [v128]
:i64x2.lt_s is opc=0xFD; opc2_216; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_lt_s(sp1_128, sp2_128);
}

define pcodeop i64x2_gt_s;
# [v128 v128] -> [v128]
:i64x2.gt_s is opc=0xFD; opc2_217; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_gt_s(sp1_128, sp2_128);
}

define pcodeop i64x2_le_s;
# [v128 v128] -> [v128]
:i64x2.le_s is opc=0xFD; opc2_218; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_le_s(sp1_128, sp2_128);
}

define pcodeop i64x2_ge_s;
# [v128 v128] -> [v128]
:i64x2.ge_s is opc=0xFD; opc2_219; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_ge_s(sp1_128, sp2_128);
}

define pcodeop i64x2_extmul_low_i32x4_s;
# [v128 v128] -> [v128]
:i64x2.extmul_low_i32x4_s is opc=0xFD; opc2_220; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_extmul_low_i32x4_s(sp1_128, sp2_128);
}

define pcodeop i64x2_extmul_high_i32x4_s;
# [v128 v128] -> [v128]
:i64x2.extmul_high_i32x4_s is opc=0xFD; opc2_221; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_extmul_high_i32x4_s(sp1_128, sp2_128);
}

define pcodeop i64x2_extmul_low_i32x4_u;
# [v128 v128] -> [v128]
:i64x2.extmul_low_i32x4_u is opc=0xFD; opc2_222; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_extmul_low_i32x4_u(sp1_128, sp2_128);
}

define pcodeop i64x2_extmul_high_i32x4_u;
# [v128 v128] -> [v128]
:i64x2.extmul_high_i32x4_u is opc=0xFD; opc2_223; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = i64x2_extmul_high_i32x4_u(sp1_128, sp2_128);
}

define pcodeop f32x4_abs;
# [v128] -> [v128]
:f32x4.abs is opc=0xFD; opc2_224; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_abs(sp1_128);
}

# [v128] -> [v128]
:f32x4.neg is opc=0xFD; opc2_225; sp1_128; ctx_is_directive=0 {
    sp1_128[  0,32] = f- sp1_128[  0,32];
    sp1_128[ 32,32] = f- sp1_128[ 32,32];
    sp1_128[ 64,32] = f- sp1_128[ 64,32];
    sp1_128[ 96,32] = f- sp1_128[ 96,32];
}

define pcodeop f32x4_sqrt;
# [v128] -> [v128]
:f32x4.sqrt is opc=0xFD; opc2_227; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_sqrt(sp1_128);
}

# [v128 v128] -> [v128]
:f32x4.add is opc=0xFD; opc2_228; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,32] = sp2_128[  0,32] f+ sp1_128[  0,32];
    sp2_128[ 32,32] = sp2_128[ 32,32] f+ sp1_128[ 32,32];
    sp2_128[ 64,32] = sp2_128[ 64,32] f+ sp1_128[ 64,32];
    sp2_128[ 96,32] = sp2_128[ 96,32] f+ sp1_128[ 96,32];
}

# [v128 v128] -> [v128]
:f32x4.sub is opc=0xFD; opc2_229; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,32] = sp2_128[  0,32] f- sp1_128[  0,32];
    sp2_128[ 32,32] = sp2_128[ 32,32] f- sp1_128[ 32,32];
    sp2_128[ 64,32] = sp2_128[ 64,32] f- sp1_128[ 64,32];
    sp2_128[ 96,32] = sp2_128[ 96,32] f- sp1_128[ 96,32];
}

# [v128 v128] -> [v128]
:f32x4.mul is opc=0xFD; opc2_230; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,32] = sp2_128[  0,32] f* sp1_128[  0,32];
    sp2_128[ 32,32] = sp2_128[ 32,32] f* sp1_128[ 32,32];
    sp2_128[ 64,32] = sp2_128[ 64,32] f* sp1_128[ 64,32];
    sp2_128[ 96,32] = sp2_128[ 96,32] f* sp1_128[ 96,32];
}

# [v128 v128] -> [v128]
:f32x4.div is opc=0xFD; opc2_231; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,32] = sp2_128[  0,32] f/ sp1_128[  0,32];
    sp2_128[ 32,32] = sp2_128[ 32,32] f/ sp1_128[ 32,32];
    sp2_128[ 64,32] = sp2_128[ 64,32] f/ sp1_128[ 64,32];
    sp2_128[ 96,32] = sp2_128[ 96,32] f/ sp1_128[ 96,32];
}

define pcodeop f32x4_min;
# [v128 v128] -> [v128]
:f32x4.min is opc=0xFD; opc2_232; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_min(sp1_128, sp2_128);
}

define pcodeop f32x4_max;
# [v128 v128] -> [v128]
:f32x4.max is opc=0xFD; opc2_233; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_max(sp1_128, sp2_128);
}

define pcodeop f32x4_pmin;
# [v128 v128] -> [v128]
:f32x4.pmin is opc=0xFD; opc2_234; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_pmin(sp1_128, sp2_128);
}

define pcodeop f32x4_pmax;
# [v128 v128] -> [v128]
:f32x4.pmax is opc=0xFD; opc2_235; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f32x4_pmax(sp1_128, sp2_128);
}

define pcodeop f64x2_abs;
# [v128] -> [v128]
:f64x2.abs is opc=0xFD; opc2_236; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_abs(sp1_128);
}

# [v128] -> [v128]
:f64x2.neg is opc=0xFD; opc2_237; sp1_128; ctx_is_directive=0 {
    sp1_128[  0,64] = f- sp1_128[  0,64];
    sp1_128[ 64,64] = f- sp1_128[ 64,64];
}

define pcodeop f64x2_sqrt;
# [v128] -> [v128]
:f64x2.sqrt is opc=0xFD; opc2_239; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_sqrt(sp1_128);
}

# [v128 v128] -> [v128]
:f64x2.add is opc=0xFD; opc2_240; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,64] = sp2_128[  0,64] f+ sp1_128[  0,64];
    sp2_128[ 64,64] = sp2_128[ 64,64] f+ sp1_128[ 64,64];
}

# [v128 v128] -> [v128]
:f64x2.sub is opc=0xFD; opc2_241; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,64] = sp2_128[  0,64] f- sp1_128[  0,64];
    sp2_128[ 64,64] = sp2_128[ 64,64] f- sp1_128[ 64,64];
}

# [v128 v128] -> [v128]
:f64x2.mul is opc=0xFD; opc2_242; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,64] = sp2_128[  0,64] f* sp1_128[  0,64];
    sp2_128[ 64,64] = sp2_128[ 64,64] f* sp1_128[ 64,64];
}

# [v128 v128] -> [v128]
:f64x2.div is opc=0xFD; opc2_243; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128[  0,64] = sp2_128[  0,64] f/ sp1_128[  0,64];
    sp2_128[ 64,64] = sp2_128[ 64,64] f/ sp1_128[ 64,64];
}

define pcodeop f64x2_min;
# [v128 v128] -> [v128]
:f64x2.min is opc=0xFD; opc2_244; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_min(sp1_128, sp2_128);
}

define pcodeop f64x2_max;
# [v128 v128] -> [v128]
:f64x2.max is opc=0xFD; opc2_245; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_max(sp1_128, sp2_128);
}

define pcodeop f64x2_pmin;
# [v128 v128] -> [v128]
:f64x2.pmin is opc=0xFD; opc2_246; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_pmin(sp1_128, sp2_128);
}

define pcodeop f64x2_pmax;
# [v128 v128] -> [v128]
:f64x2.pmax is opc=0xFD; opc2_247; sp1_128; sp2_128; ctx_is_directive=0 {
    sp2_128 = f64x2_pmax(sp1_128, sp2_128);
}

define pcodeop i32x4_trunc_sat_f32x4_s;
# [v128] -> [v128]
:i32x4.trunc_sat_f32x4_s is opc=0xFD; opc2_248; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_trunc_sat_f32x4_s(sp1_128);
}

define pcodeop i32x4_trunc_sat_f32x4_u;
# [v128] -> [v128]
:i32x4.trunc_sat_f32x4_u is opc=0xFD; opc2_249; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_trunc_sat_f32x4_u(sp1_128);
}

define pcodeop f32x4_convert_i32x4_s;
# [v128] -> [v128]
:f32x4.convert_i32x4_s is opc=0xFD; opc2_250; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_convert_i32x4_s(sp1_128);
}

define pcodeop f32x4_convert_i32x4_u;
# [v128] -> [v128]
:f32x4.convert_i32x4_u is opc=0xFD; opc2_251; sp1_128; ctx_is_directive=0 {
    sp1_128 = f32x4_convert_i32x4_u(sp1_128);
}

define pcodeop i32x4_trunc_sat_f64x2_s_zero;
# [v128] -> [v128]
:i32x4.trunc_sat_f64x2_s_zero is opc=0xFD; opc2_252; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_trunc_sat_f64x2_s_zero(sp1_128);
}

define pcodeop i32x4_trunc_sat_f64x2_u_zero;
# [v128] -> [v128]
:i32x4.trunc_sat_f64x2_u_zero is opc=0xFD; opc2_253; sp1_128; ctx_is_directive=0 {
    sp1_128 = i32x4_trunc_sat_f64x2_u_zero(sp1_128);
}

define pcodeop f64x2_convert_low_i32x4_s;
# [v128] -> [v128]
:f64x2.convert_low_i32x4_s is opc=0xFD; opc2_254; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_convert_low_i32x4_s(sp1_128);
}

define pcodeop f64x2_convert_low_i32x4_u;
# [v128] -> [v128]
:f64x2.convert_low_i32x4_u is opc=0xFD; opc2_255; sp1_128; ctx_is_directive=0 {
    sp1_128 = f64x2_convert_low_i32x4_u(sp1_128);
}
