/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Native build files are already applied in development mode (indicated by presence of the
// Generic project).  Only need to apply them if we are in a distribution.
if (findProject(':Generic') == null) {
	apply from: "../../../GPL/utils.gradle"
	apply from: "../../../GPL/nativePlatforms.gradle"
	apply from: "../../../GPL/nativeBuildProperties.gradle"
}

// Define the source files that are compiled and linked to become the decompiler.
// The decompiler source is a bit weird in that all the cpp and headers all live in
// the same directory with other files that are not used by the decompiler.
// That is why we have to list every cpp file that makes up the decomplier.
// NOTE: The bison/flex generated files are assumed to be up-to-date.
//       The task `generateParsers` should be executed if needed.
// builtBy lexSleigh

def core_files = [
	"address.cc",
	"float.cc",
	"marshal.cc",
	"opcodes.cc",
	"pcoderaw.cc",
	"space.cc",
	"translate.cc",
	"xml.cc"
]

def decompiler_files = [
	"action.cc",
	"architecture.cc",
	"block.cc",
	"blockaction.cc",
	"capability.cc",
	"cast.cc",
	"comment.cc",
	"condexe.cc",
	"constseq.cc",
	"coreaction.cc",
	"cover.cc",
	"cpool.cc",
	"crc32.cc",
	"database.cc",
	"double.cc",
	"dynamic.cc",
	"emulate.cc",
	"emulateutil.cc",
	"flow.cc",
	"fspec.cc",
	"funcdata.cc",
	"funcdata_block.cc",
	"funcdata_op.cc",
	"funcdata_varnode.cc",
	"globalcontext.cc",
	"graph.cc",
	"heritage.cc",
	"jumptable.cc",
	"loadimage.cc",
	"memstate.cc",
	"merge.cc",
	"modelrules.cc",
	"multiprecision.cc",
	"op.cc",
	"opbehavior.cc",
	"options.cc",
	"override.cc",
	"paramid.cc",
	"pcodeinject.cc",
	"prefersplit.cc",
	"prettyprint.cc",
	"printc.cc",
	"printjava.cc",
	"printlanguage.cc",
	"rangeutil.cc",
	"ruleaction.cc",
	"signature.cc",
	"stringmanage.cc",
	"subflow.cc",
	"transform.cc",
	"type.cc",
	"typeop.cc",
	"unionresolve.cc",
	"userop.cc",
	"variable.cc",
	"varmap.cc",
	"varnode.cc"
]

def decompiler_opt_files = [
	"comment_ghidra.cc",
	"cpool_ghidra.cc",
	"database_ghidra.cc",
	"ghidra_arch.cc",
	"ghidra_context.cc",
	"ghidra_process.cc",
	"ghidra_translate.cc",
	"inject_ghidra.cc",
	"loadimage_ghidra.cc",
	"signature_ghidra.cc",
	"string_ghidra.cc",
	"typegrp_ghidra.cc"
]

def decompiler_debug_files = [
	"bfd_arch.cc",
	"callgraph.cc",
	"codedata.cc",
	"consolemain.cc",
	"grammar.cc",
	"ifacedecomp.cc",
	"ifaceterm.cc",
	"inject_sleigh.cc",
	"interface.cc",
	"loadimage_bfd.cc",
	"loadimage_xml.cc",
	"libdecomp.cc",
	"raw_arch.cc",
	"rulecompile.cc",
	"sleigh_arch.cc",
	"testfunction.cc",
	"unify.cc",
	"xml_arch.cc"
]

def sleigh_common_files = [
	"compression.cc",
	"context.cc",
	"filemanage.cc",
	"pcodecompile.cc",
	"pcodeparse.cc",
	"semantics.cc",
	"slaformat.cc",
	"sleigh.cc",
	"sleighbase.cc",
	"slghpatexpress.cc",
	"slghpattern.cc",
	"slghsymbol.cc"
]

def sleigh_files = [
	"slgh_compile.cc",
	"slghparse.cc",
	"slghscan.cc"
]

def sleigh_debug_files = [
	"globalcontext.cc"
]

/**
 * Try to find libbfd*.so or a static libbfd.a for linking decomp_dbg
 */
def linkBFDUnix = {
	def stdout = new ByteArrayOutputStream()
	exec {
		ignoreExitValue false /* fail and abort if there is an error */
		commandLine 'bash', '-c', 'ld.bfd -v | grep -o \"[0-9].*$\"'
		standardOutput = stdout
	}
	def lib = "-lbfd-" + stdout.toString().trim()
	stdout.reset()
	def ld = "ld -o /dev/null " + lib + " 2>&1 | grep -o \"cannot find -\""
	exec {
		ignoreExitValue true /* it would fail and abort otherwise */
		commandLine 'bash', '-c', ld
		standardOutput = stdout
	}
	/* Use libbfd-* if found */
	if (stdout.toString().trim() == "")
		return lib + " -Wl,--no-whole-archive -liberty -lsframe -lz -lzstd"
	/* Fallback to libbfd */
	return "-lbfd -Wl,--no-whole-archive -liberty -lsframe -lz -lzstd"
}

/**
 * Define the "native build model" for building the decompiler executables.
 * Options:
 * -PsysZlib	Build against system zlib (ignored for Windows)
 * -Pdebug	Build debug interfaces (not for Windows)
 * -Plto	Enable Link Time Optimization (Gcc and Clang; not for debug interfaces)
 */
model {
	components {
		decompile(NativeExecutableSpec) {
			baseName "decompile"
			// these tell gradle for which platforms to build a decompiler executable.
			targetPlatform "win_x86_64"
			targetPlatform "linux_x86_64"
			targetPlatform "linux_arm_64"
			targetPlatform "mac_x86_64"
			targetPlatform "mac_arm_64"
			targetPlatform "freebsd_x86_64"
			targetPlatform "freebsd_arm_64"
			sources {
				cpp {
					source {
						srcDir "src/decompile/cpp"
						include core_files
						include decompiler_files
						include decompiler_opt_files
					}
					exportedHeaders {
						srcDir "src/decompile/cpp"
					}
				}
			}
			binaries.all { b ->
				if (b.toolChain in Gcc || b.toolChain in Clang) {
					b.cppCompiler.args "-O2"
					if (project.hasProperty('lto')) {
						b.cppCompiler.args "-flto"
						b.linker.args "-flto"
					}
				}
			}
		} // end decompile

		sleigh(NativeExecutableSpec) {
			targetPlatform "win_x86_64"
			targetPlatform "linux_x86_64"
			targetPlatform "linux_arm_64"
			targetPlatform "mac_x86_64"
			targetPlatform "mac_arm_64"
			targetPlatform "freebsd_x86_64"
			targetPlatform "freebsd_arm_64"
			sources {
				cpp {
					source {
						srcDir "src/decompile/cpp"
						include core_files
						include sleigh_common_files
						include sleigh_files
					}
					exportedHeaders {
						srcDir "src/decompile/cpp"
					}
				}
				if (isCurrentWindows() || !project.hasProperty('sysZlib')) {
					c {
						source {
							srcDir "src/decompile/zlib"
							include "*.c"
						}
					}
				}
			}
			binaries.all { b ->
				if (b.toolChain in Gcc || b.toolChain in Clang) {
					b.cppCompiler.args "-O2"
					if (project.hasProperty('sysZlib')) {
						b.linker.args "-lz"
					}
					if (project.hasProperty('lto')) {
						b.cppCompiler.args "-flto"
						if (!project.hasProperty('sysZlib')) {
							b.cCompiler.args "-flto"
						}
						b.linker.args "-flto"
					}
				}
				if (isCurrentWindows() || !project.hasProperty('sysZlib')) {
					b.cppCompiler.define "LOCAL_ZLIB"
					b.cCompiler.define "NO_GZIP"
				}
			}
		} // end sleigh

		if (project.hasProperty('debug')) {
			decomp_dbg(NativeExecutableSpec) {
				baseName "decomp_dbg"
				targetPlatform "linux_x86_64"
				targetPlatform "linux_arm_64"
				targetPlatform "mac_x86_64"
				targetPlatform "mac_arm_64"
				targetPlatform "freebsd_x86_64"
				sources {
					cpp {
						source {
							srcDir "src/decompile/cpp"
							include core_files
							include decompiler_files
							include decompiler_debug_files
							include sleigh_common_files
						}
						exportedHeaders {
							srcDir "src/decompile/cpp"
						}
					}
				}
				binaries.all { b ->
					if (b.toolChain in Gcc || b.toolChain in Clang) {
						b.cppCompiler.args "-g"
						b.linker.args linkBFDUnix().split(" ")
					}
					else if (b.toolChain in VisualCpp) {
						b.cppCompiler.args "/Zi"
						b.cppCompiler.args "/FS"
						b.linker.args "/DEBUG"
					}
					b.cppCompiler.define "CPUI_DEBUG"
					b.cppCompiler.define "__TERMINAL__"
				}
			} // end decomp_dbg

			sleigh_dbg(NativeExecutableSpec) {
				targetPlatform "linux_x86_64"
				targetPlatform "linux_arm_64"
				targetPlatform "mac_x86_64"
				targetPlatform "mac_arm_64"
				targetPlatform "freebsd_x86_64"
				sources {
					cpp {
						source {
							srcDir "src/decompile/cpp"
							include core_files
							include sleigh_common_files
							include sleigh_files
							include sleigh_debug_files
						}
						exportedHeaders {
							srcDir "src/decompile/cpp"
						}
					}
					if (isCurrentWindows() || !project.hasProperty('sysZlib')) {
						c {
							source {
								srcDir "src/decompile/zlib"
								include "*.c"
							}
						}
					}
				}
				binaries.all { b ->
					if (b.toolChain in Gcc || b.toolChain in Clang) {
						b.cppCompiler.args "-g"
						if (project.hasProperty('sysZlib')) {
							b.linker.args "-lz"
						}
					}
					else if (b.toolChain in VisualCpp) {
						b.cppCompiler.args "/Zi"
						b.cppCompiler.args "/FS"
						b.linker.args "/DEBUG"
					}
					if (isCurrentWindows() || !project.hasProperty('sysZlib')) {
						b.cppCompiler.define "LOCAL_ZLIB"
					}
					b.cppCompiler.define "YYDEBUG"
				}
			} // end sleigh_dbg
		} // end debug
	} // end components

	binaries {
		all { b ->
			if (b.toolChain in Gcc || b.toolChain in Clang) {
				b.cppCompiler.args "-std=c++11"
				b.cppCompiler.args "-Wall"
				b.cppCompiler.args "-Wno-sign-compare"
				if (b.targetPlatform.operatingSystem.linux) {
					b.cppCompiler.define "LINUX"
					b.cppCompiler.define "_LINUX"
				}
			}
			else if (b.toolChain in VisualCpp) {
				b.cppCompiler.args "/EHsc"
				b.cppCompiler.define "_SECURE_SCL=0"
				b.cppCompiler.define "_HAS_ITERATOR_DEBUGGING=0"
				if (b.targetPlatform.operatingSystem.windows) {
					b.cppCompiler.define "WINDOWS"
					b.cppCompiler.define "_WINDOWS"
					b.cppCompiler.define "WIN32"
					b.cppCompiler.define "_WIN32"
					if (b.targetPlatform.name == "win_x86_64") {
						b.cppCompiler.define "WIN64"
						b.cppCompiler.define "_WIN64"
					}	
				}
				b.cCompiler.args "/W3"
				b.cCompiler.args "/O2"
				b.cCompiler.args "/Oy"			// Omit frame pointer
				b.cCompiler.define "_CRT_SECURE_NO_DEPRECATE"
				b.cCompiler.define "_CRT_NONSTDC_NO_DEPRECATE"
				b.cCompiler.define "ZLIB_WINAPI"
			}
		} // end all
	} // end binaries
} // end model
