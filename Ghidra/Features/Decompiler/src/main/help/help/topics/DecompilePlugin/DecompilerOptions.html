<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Decompiler Options</title>
<link rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
<link rel="stylesheet" type="text/css" href="../../shared/languages.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="Decompiler.html" title="Decompiler">
<link rel="up" href="Decompiler.html" title="Decompiler">
<link rel="prev" href="DecompilerAnnotations.html" title="Program Annotations Affecting the Decompiler">
<link rel="next" href="DecompilerWindow.html" title="Decompiler Window">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="DecompilerOptions"></a>Decompiler Options</h1></div></div></div>
  
<div class="simplesect">
<div class="titlepage"></div>
  <p>
    This lists configuration options that explicitly affect the behavior of the decompiler or
    its output, independent of the code that is being decompiled. The bulk of these are
    accessible by selecting the Code Browser menu
    </p>
<div class="informalexample">
      <span class="bold"><strong>Edit -&gt; Tool Options</strong></span>
    </div>
<p>
    and then picking the <span class="emphasis"><em>Decompiler</em></span> sub-folder. These options are associated
    with the particular tool (Code Browser) being used and will apply to decompilation of any Program
    being analyzed by that tool. The three categories of options are:
    </p>
<div class="informalexample">
      <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
<a class="xref" href="DecompilerOptions.html#GeneralOptions" title="General Options">&#8220;General Options&#8221;</a> affecting the engine behavior</li>
<li class="listitem" style="list-style-type: disc">
<a class="xref" href="DecompilerOptions.html#AnalysisOptions" title="Analysis Options">&#8220;Analysis Options&#8221;</a> affecting the decompiler's transformation process</li>
<li class="listitem" style="list-style-type: disc">
<a class="xref" href="DecompilerOptions.html#DisplayOptions" title="Display Options">&#8220;Display Options&#8221;</a> affecting the final presentation of decompiler output</li>
</ul></div>
    </div>
<p>
  </p>
  <p>
    Options that are specific to the particular Program being analyzed are accessed by
    selecting the Code Browser menu
    </p>
<div class="informalexample">
      <span class="bold"><strong>Edit -&gt; Options for &lt;Program&gt;</strong></span>
    </div>
<p>
    Picking the <span class="emphasis"><em>Decompiler</em></span> tab shows <a class="xref" href="DecompilerOptions.html#ProgramOptions" title="Program Options">&#8220;Program Options&#8221;</a>
    that only affect the decompiler.  Picking the <a class="xref" href="DecompilerOptions.html#ExtensionOptions" title="Specification Extensions">&#8220;Specification Extensions&#8221;</a> tab
    shows a table of the available prototype models, call-fixups, and callother-fixups. These
    affect more than just the decompiler but are also documented here.
  </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="GeneralOptions"></a>General Options</h2></div></div></div>
  
  <p>
    These options govern what resources are available to the Plug-in and the decompiler engine but do
    not affect how analysis is performed or results are displayed.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="GeneralCacheSize"></a><span class="term"><span class="bold"><strong>Cache Size (Functions)</strong></span></span>
</dt>
<dd>
	<p>
	  Decompilation results for a single function can be compute intensive to produce.
	  This option specifies the number of functions whose decompilation results
	  can be cached simultaneously. When navigating to a function that
	  has been recently cached, as when navigating back and forth between a few functions,
	  a new decompilation is not triggered.
	</p>
      </dd>
<dt>
<a name="GeneralMaxPayload"></a><span class="term"><span class="bold"><strong>Decompiler Max-Payload (MBytes)</strong></span></span>
</dt>
<dd>
	<p>
	  This is a limit on the number of bytes that can be produced by the decompiler process as output
	  when decompiling a single function. A payload includes the actual characters to be displayed in
	  the window, additional token markup, symbol information, and other details of the underlying
	  syntax tree. The limit is specified in megabytes of data. If the limit is exceeded for a single
	  function, decompilation is aborted for that function, and an error message
	  "Decompiler results exceeded payload limit ..." is displayed.
	</p>
      </dd>
<dt>
<a name="GeneralTimeout"></a><span class="term"><span class="bold"><strong>Decompiler Timeout (seconds)</strong></span></span>
</dt>
<dd>
	<p>
	  This option sets an upper limit on the number of seconds the decompiler spends attempting
	  to analyze one function before aborting.
	  It is currently <span class="bold"><strong>not</strong></span> enforced for the Decompilation
	  Window.  Instead it applies to the DecompilerSwitchAnalyzer, the <code class="code">analyzeHeadless</code> command, scripts, or other
	  plug-ins that make use of the decompiler service.
	</p>
      </dd>
<dt>
<a name="GeneralMaxInstruction"></a><span class="term"><span class="bold"><strong>Max Instructions per Function</strong></span></span>
</dt>
<dd>
    <p>
      This option sets a maximum number of machine instructions that the decompiler will attempt
      to analyze for a single function, as a safeguard against analyzing a long sequence
      of zeroes or other constant data. The decompiler will quickly throw an exception if it
      traces control-flow into more than the indicated number of instructions.
    </p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="AnalysisOptions"></a>Analysis Options</h2></div></div></div>
  
  <p>
    These options directly affect how the decompiler performs its analysis, either by
    toggling specific analysis passes or changing how it treats various annotations.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="AnalysisAliasBlocking"></a><span class="term"><span class="bold"><strong>Alias Blocking</strong></span></span>
</dt>
<dd>
	<p>
	  When deciding if an individual stack location has become dead, the decompiler
	  must consider <span class="emphasis"><em>aliases</em></span>, pointers onto the stack that could
	  be used to modify the location within a called function.  One strong heuristic the decompiler
	  uses is; if the user has explicitly created a variable on the stack between the
	  base location referenced by the pointer and the individual stack location, then
	  the decompiler can assume that the pointer is not an alias of the stack location.
	  The alias is <span class="emphasis"><em>blocked</em></span> by the explicit variable.
	  However, if the user's explicit variable is labeling something that isn't
	  really an explicit variable, like a field within a larger structure for instance,
	  the decompiler may incorrectly consider the stack location as dead and start removing
	  live code.
	</p>
	<p>
	  In order to support the exploratory labeling of stack locations, the user can use this
	  setting to specify what data-types should be considered blocking. The four options are:
          </p>
<div class="informalexample">
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>None</strong></span> - No data-type is considered blocking.</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Structures</strong></span> - Only structured data-types are blocking.</li>
<li class="listitem" style="list-style-type: disc"><span class="bold"><strong>Structures and Arrays</strong></span></li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>All Data-types</strong></span> - All data-types are blocking.</li>
</ul></div>
	  </div>
<p>
	  Selecting <span class="emphasis"><em>None</em></span> is the equivalent of turning off the heuristic. Selecting anything
	  except <span class="emphasis"><em>All Data-types</em></span> allows users to safely label small variables without
	  knowing immediately if the stack location is part of a larger structure or array.
	</p>
      </dd>
<dt>
<a name="AnalysisForLoops"></a><span class="term"><span class="bold"><strong>Recover -for- loops</strong></span></span>
</dt>
<dd>
	<p>
	  When this is toggle <span class="emphasis"><em>on</em></span>, the decompiler attempts to pinpoint
	  variables that control the iteration over specific loops in the function body.
	  When these <span class="emphasis"><em>loop</em></span> variables are discovered, the loop is
	  rendered using a standard <span class="bold"><strong>for</strong></span> loop header
	  that contains an initializer statement, condition, and iterating statement.
	  </p>
<div class="informalexample">
	    <code class="code">for (iVar2 = 10; iVar2 &lt; len; iVar2 = iVar2 + 1) { ...</code>
	  </div>
<p>
	</p>
	<p>
	  If the toggle is <span class="emphasis"><em>off</em></span>, the loop is displayed using
	  <span class="bold"><strong>while</strong></span> syntax, with any initializer and
	  iterating statements mixed in with the loop body or preceding basic blocks.
	</p>
      </dd>
<dt>
<a name="AnalysisUnreachable"></a><span class="term"><span class="bold"><strong>Eliminate unreachable code</strong></span></span>
</dt>
<dd>
	<p>
	  When this is toggled <span class="emphasis"><em>on</em></span>, the decompiler eliminates code that it
	  considers unreachable.  This usually happens when, due to constant propagation and other
	  analysis, the decompiler decides that a boolean value controlling a conditional branch can
	  only take one possible value and removes the branch corresponding to the other value. Toggling
	  this to <span class="emphasis"><em>off</em></span> lets the user see the dead code, which is typically demarcated
	  by the control-flow structure -- <code class="code">if (false) { ... }</code>.
	</p>
      </dd>
<dt>
<a name="AnalysisIgnoreUnimplemented"></a><span class="term"><span class="bold"><strong>Ignore unimplemented instructions</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler treats instructions whose semantics
	  have been formally marked <span class="bold"><strong>unimplemented</strong></span> as if they do
	  nothing (no operation). Crucially, control-flow falls through to the next instruction.
	  In this case, the decompiler inserts the warning "Control flow ignored unimplemented
	  instructions" as a comment in the function header, but the exact point at which
	  instruction was ignored may not be clear.
	  If this option is toggled <span class="emphasis"><em>off</em></span>, the decompiler inserts the built-in
	  function <code class="code">halt_unimplemented()</code> at the point of the unimplemented instruction, and
	  control-flow does not fall through.
	</p>
      </dd>
<dt>
<a name="AnalysisInferConstants"></a><span class="term"><span class="bold"><strong>Infer constant pointers</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler infers a data-type for constants
	  it determines are likely pointers. In the basic heuristic,
          each constant is considered as an address, and if that address starts a known data or function element
          in the program, the constant is assumed to be a pointer.  The constants are treated like
	  any other source of data-type information, and the inferred data-types are freely propagated by
	  the decompiler to other parts of the function.
	</p>
      </dd>
<dt>
<a name="AnalysisReadOnly"></a><span class="term"><span class="bold"><strong>Respect read-only flags</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler treats any values in memory
          marked <span class="emphasis"><em>read-only</em></span> as constant. If a read-only memory location is explicitly
	  referenced by the function being decompiled, it is considered to be unchanging, and the initial
	  value present in the Program is pulled in to the data-flow of the function as a constant.
	  Due to <span class="emphasis"><em>Constant Propagation</em></span> and other transformations, read-only memory
	  can have a large effect on decompiler output.
	</p>
	<p>
           Typically as part of the import process, Ghidra marks memory blocks as read-only if they
           are tagged as such by a section header or other meta-data in the original binary.
	   Users can actively set whether specific memory regions are considered read-only through the
	  <span class="emphasis"><em>Memory Manager</em></span>, and individual data elements can be marked
	  as <span class="emphasis"><em>constant</em></span> via the <span class="bold"><strong>Mutability</strong></span> setting
	  (See <a class="xref" href="DecompilerAnnotations.html#AnnoteMutability" title="Data Mutability">&#8220;Data Mutability&#8221;</a>). 
	</p>
      </dd>
<dt>
<a name="AnalysisExtendedPrecision"></a><span class="term"><span class="bold"><strong>Simplify extended integer operations</strong></span></span>
</dt>
<dd>
	<p>
	  This toggles whether the decompiler attempts to simplify double precision arithmetic operations,
          where a single logical operation is split into two parts, calculating the high and low pieces
	  of the result in separate instructions.  Decompiler support for this kind of transform is currently
	  limited, and only certain constructions are simplified.
	</p>
      </dd>
<dt>
<a name="AnalysisPredicate"></a><span class="term"><span class="bold"><strong>Simplify predication</strong></span></span>
</dt>
<dd>
	<p>
	  When this option is active, the decompiler simplifies code sequences containing
	  <span class="emphasis"><em>predicated</em></span> instructions. A predicated instruction is executed
	  conditionally based on a boolean value, the <span class="bold"><strong>predicate</strong></span>,
	  and a sequence of instructions can share the same predicate. The decompiler merges the
	  resulting <code class="code">if/else</code> blocks that share the same predicate so that the condition is only
	  printed once.
	</p>
      </dd>
<dt>
<a name="AnalysisInPlace"></a><span class="term"><span class="bold"><strong>Use in-place assignment operators</strong></span></span>
</dt>
<dd>
	<p>
	  When toggled <span class="emphasis"><em>on</em></span>, the decompiler employs in-place assignment operators,
	  such as <code class="code">+=</code> and <code class="code">&lt;&lt;=</code>, in its output syntax.
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="DisplayOptions"></a>Display Options</h2></div></div></div>
  
  <p>
    These options do not change the decompiler's analysis but only affect how the results are presented.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="DisplayBackgroundColor"></a><span class="term"><span class="bold"><strong>Background Color</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the background color for the Decompiler window.
	</p>
      </dd>
<dt>
<a name="DisplayTokenColor"></a><span class="term"><span class="bold"><strong>Color for &lt;token&gt;</strong></span></span>
</dt>
<dd>
	<p>
	  Assign colors to the different types of language tokens emitted by the decompiler.
	  These include:
          </p>
<div class="informalexample">
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc"><span class="bold"><strong>Comments</strong></span></li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Constants</strong></span> - including integer, floating-point, character, and string</li>
<li class="listitem" style="list-style-type: disc"><span class="bold"><strong>Functions names</strong></span></li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Globals</strong></span> - names of variables with global scope</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Keywords</strong></span> - reserved names in the language being emitted</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Parameters</strong></span> - names of function input variables</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Types</strong></span> - names of data-types in variable declarations and casts</li>
<li class="listitem" style="list-style-type: disc">
<span class="bold"><strong>Variables</strong></span> - names of local variables</li>
</ul></div>
	  </div>
<p>
	</p>
      </dd>
<dt>
<a name="DisplayColorDefault"></a><span class="term"><span class="bold"><strong>Color Default</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the color to any characters emitted by the decompiler that do not fall into one of token types
	  listed above. This includes delimiter characters like commas and parentheses as well as various <span class="emphasis"><em>operator</em></span>
	  characters.
	</p>
      </dd>
<dt>
<a name="DisplayCurrentHighlight"></a><span class="term"><span class="bold"><strong>Color for Current Variable Highlight</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the background color used to highlight the token currently under the cursor in a Decompiler Window.
	</p>
      </dd>
<dt>
<a name="DisplayFindHighlight"></a><span class="term"><span class="bold"><strong>Color for Highlighting Find Matches</strong></span></span>
</dt>
<dd>
	<p>
	  Assign the background color used to highlight characters matching the current <span class="emphasis"><em>Find</em></span> pattern.
	  See <a class="xref" href="DecompilerWindow.html#ActionFind" title="Find ...">&#8220;Find ...&#8221;</a>.
	</p>
      </dd>
<dt>
<a name="DisplayCommentIndent"></a><span class="term"><span class="bold"><strong>Comment line indent level</strong></span></span>
</dt>
<dd>
	<p>
	  Set the number of characters that comment lines are indented within decompiler output. This applies only
	  to comments within the body of the function being displayed.  Comments at the head of the function
	  are not indented.
	</p>
      </dd>
<dt>
<a name="DisplayCommentStyle"></a><span class="term"><span class="bold"><strong>Comment style</strong></span></span>
</dt>
<dd>
	<p>
	  Set the language syntax used to delimit comments emitted as part of decompiler output. For C and Java,
	  the choices are <code class="code">/* C style comments */</code> and <code class="code">// C++ style comments</code>.
	</p>
      </dd>
<dt>
<a name="DisplayDisableCasts"></a><span class="term"><span class="bold"><strong>Disable printing of type casts</strong></span></span>
</dt>
<dd>
	<p>
	  Set whether the syntax for <span class="emphasis"><em>type casts</em></span> is emitted in decompiler output.
	  If this is toggled on, type cast syntax is never displayed, even when rules of the language
	  require it. So individual statements may no longer be formally accurate.
	</p>
      </dd>
<dt>
<a name="CommentOptions"></a><span class="term"><span class="bold"><strong>Display &lt;kind-of&gt; Comments</strong></span></span>
</dt>
<dd>
	<p>
	  Set whether a specific kind of comment can be incorporated into decompiler output. Comments in
	  Ghidra are categorized based on their placement within the Listing Window, and the decompiler
	  in general tries to display comments where appropriate. See the discussion in <a class="xref" href="DecompilerAnnotations.html#AnnoteComments" title="Comments">&#8220;Comments&#8221;</a>.
	  Each kind of comment has its own toggle and can be individually included or excluded from decompiler output. 
	  </p>
<div class="informalexample">
	    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>PLATE</strong></span> - Whether plate comments <span class="emphasis"><em>within the body of the function</em></span> are displayed
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>PRE</strong></span>
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>POST</strong></span>
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>EOL</strong></span>
	      </li>
</ul></div>
	  </div>
<p>
	</p>
      </dd>
<dt>
<a name="DisplayHeaderComment"></a><span class="term"><span class="bold"><strong>Display Header comment</strong></span></span>
</dt>
<dd>
	<p>
	  Toggle whether the decompiler emits comments at the head (before the beginning) of a function.
	  The header is built from Plate comments placed at the <span class="emphasis"><em>entry point</em></span> of the
	  function. See the discussion in <a class="xref" href="DecompilerAnnotations.html#AnnoteComments" title="Comments">&#8220;Comments&#8221;</a>.
	  The inclusion of other Plate comments is controlled by the <span class="bold"><strong>Display PLATE comments</strong></span> toggle, described above. 
	</p>
      </dd>
<dt>
<a name="DisplayLineNumbers"></a><span class="term"><span class="bold"><strong>Display Line Numbers</strong></span></span>
</dt>
<dd>
	<p>
	  Toggle whether line numbers are displayed in any Decompiler Window.  If toggled
	  on, each Decompiler Window reserves space to display a numbers down the left
	  side of the window, labeling each line of output produced by the decompiler.
	  Line numbers are associated with the window itself and are not formally part of
	  the decompiler's output.
	</p>
      </dd>
<dt>
<a name="DisplayNamespaces"></a><span class="term"><span class="bold"><strong>Display Namespaces</strong></span></span>
</dt>
<dd>
	<p>
	  Control how the decompiler displays namespace information associated
	  with function and variable symbols. The possible settings are:
	  </p>
<div class="informalexample">
	    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Always</strong></span> - Always display the entire namespace path
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Never</strong></span> - Never display the namespace path
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Minimally</strong></span> - Display the minimal path that distinguishes the symbol 
	      </li>
</ul></div>
	  </div>
<p>
	</p>
	<p>
	  The <span class="bold"><strong>Minimally</strong></span> setting, which is the default, will only emit the portion
	  of the namespace path necessary to distinguish the symbol from other symbols with the same base name used
	  by the function, or if a portion of the path is completely outside the function's scope.
	</p>
	<p>
	  The <span class="bold"><strong>Never</strong></span> setting never displays any of the namespace path under any
	  circumstances and may produce output that is ambiguous and doesn't formally parse.
	</p>
      </dd>
<dt>
<a name="DisplayWarningComments"></a><span class="term"><span class="bold"><strong>Display Warning comments</strong></span></span>
</dt>
<dd>
	<p>
	  Toggle whether decompiler generated <span class="emphasis"><em>WARNING</em></span> comments are displayed as part
	  of the output. The decompiler generates these comments, independent of those laid down by users, to
	  indicate unusual conditions or possible errors (See <a class="xref" href="DecompilerAnnotations.html#CommentWarnings" title="Warning Comments">&#8220;Warning Comments&#8221;</a>). 
	</p>
      </dd>
<dt>
<a name="DisplayFont"></a><span class="term"><span class="bold"><strong>Font</strong></span></span>
</dt>
<dd>
	<p>
	  Set the typeface used to render characters in any Decompiler Window. Indentation is generally clearer
	  using a monospaced (fixed width) font, but any font available to the system can be used.  The size of
	  the font can also be controlled from this option.
	</p>
      </dd>
<dt>
<a name="DisplayIntegerFormat"></a><span class="term"><span class="bold"><strong>Integer format</strong></span></span>
</dt>
<dd>
	<p>
	  Set how integer constants are formatted in the decompiler output.
	  The possible settings are:
	  </p>
<div class="informalexample">
	    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Best Fit</strong></span> - Select the most <span class="emphasis"><em>natural</em></span> representation
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Force Decimal</strong></span> - Always use a decimal representation
	      </li>
<li class="listitem" style="list-style-type: disc">
		<span class="bold"><strong>Force Hexadecimal</strong></span> - Always use a hexadecimal representation
	      </li>
</ul></div>
	  </div>
<p>
	  For <span class="bold"><strong>Best Fit</strong></span>, a representation is selected based on how
	  close it is to either a <span class="emphasis"><em>round</em></span> decimal value (10, 100, 1000, etc.) or
	  a round hexadecimal value (0x10, 0x100, 0x1000, etc.)
	</p>
      </dd>
<dt>
<a name="DisplayMaxChar"></a><span class="term"><span class="bold"><strong>Maximum characters in a code line</strong></span></span>
</dt>
<dd>
	<p>
	  Set the maximum number of characters in a line of code emitted by the decompiler before a line break
	  is forced.  The decompiler will not split an individual token across lines. So line breaks frequently
	  will come before the maximum number of characters is reached, and technically a single token can
	  extend the line beyond the maximum.
	</p>
      </dd>
<dt>
<a name="DisplayIndentLevel"></a><span class="term"><span class="bold"><strong>Number of characters per indent level</strong></span></span>
</dt>
<dd>
	<p>
	  Set the amount of indenting used to print statements within a nested scope in the
	  decompiler output.  Each level of nesting (for function bodies,
	  loop bodies, <span class="bold"><strong>if/else</strong></span> bodies, etc.)
	  bodies adds this number characters.
	</p>
      </dd>
<dt>
<a name="DisplayNull"></a><span class="term"><span class="bold"><strong>Print 'NULL' for null pointers</strong></span></span>
</dt>
<dd>
	<p>
	  Set how null pointers are displayed in decompiler output.  If this is toggled
	  on, the decompiler will print a constant pointer value of zero (a <span class="bold"><strong>null</strong></span> pointer)
	  using the special token <code class="code">NULL</code>.  Otherwise the pointer value is represented with the '0' character,
	  which is then type cast into a pointer.
	</p>
      </dd>
<dt>
<a name="DisplayConvention"></a><span class="term"><span class="bold"><strong>Print calling convention name</strong></span></span>
</dt>
<dd>
	<p>
	  Set whether the <span class="emphasis"><em>calling convention</em></span> is printed as part of the function
	  declaration in decompiler output. If this option is turned on, the name of the calling convention
	  is printed just prior to the return value data-type within the function declaration.  All functions
	  in Ghidra have an associated calling convention (or prototype model) that is used during
	  decompiler analysis.  See the discussion in <a class="xref" href="DecompilerConcepts.html#ConceptPrototypeModel" title="Prototype Model">&#8220;Prototype Model&#8221;</a>.
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>

<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ProgramOptions"></a>Program Options</h2></div></div></div>
  
  <p>
    Changes to these options affect only the decompiler and only for
    the current Program being analyzed.
  </p>
  <p>
    </p>
<div class="informalexample">
    <div class="variablelist"><dl class="variablelist">
<dt>
<a name="OptionProtoEval"></a><span class="term"><span class="bold"><strong>Prototype Evaluation</strong></span></span>
</dt>
<dd>
	<p>
	  Sets the calling convention (prototype model) used when decompiling a function where
	  the convention is not known (i.e. marked as "unknown").  Many architectures have multiple
	  calling conventions, <code class="code">__stdcall</code>, <code class="code">__thiscall</code> etc.  See the
	  discussion in <a class="xref" href="DecompilerConcepts.html#ConceptPrototypeModel" title="Prototype Model">&#8220;Prototype Model&#8221;</a>.  
	</p>
      </dd>
</dl></div>
    </div>
<p>
  </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ExtensionOptions"></a>Specification Extensions</h2></div></div></div>
  
  <p>
    This tab displays elements from the Program's <span class="emphasis"><em>compiler specification</em></span> and
    <span class="emphasis"><em>processor specification</em></span> and allows the user to add or remove
    <span class="bold"><strong>extensions</strong></span>, including prototype models, call-fixups, and
    callother-fixups.
  </p>
  <p>
    Every program has a <span class="emphasis"><em>core</em></span> set of specification elements,
    loaded from the <a class="xref" href="DecompilerConcepts.html#ConceptSpecification" title="SLEIGH Specification Files">&#8220;SLEIGH Specification Files&#8221;</a>, that cannot
    be modified or removed. Extensions, however, can be added to this core specification. Any extension
    imported from this dialog is directly associated with the active Program and is stored permanently
    with it.
  </p>
  <p>
    Users can change or reimport an extension, if new information points to a better definition.
    Users have full control over an extension, and unlike a core element, can tailor it specifically
    to the Program.  
  </p>
  <p>
    This options tab presents a table of all specification elements.
    Each element, whether core or an extension, is displayed on a separate row with three columns:
    </p>
<div class="informalexample">
      <div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; ">
<li class="listitem" style="list-style-type: none">
<span class="bold"><strong>Extension Type</strong></span> - indicating the type of element</li>
<li class="listitem" style="list-style-type: none">
<span class="bold"><strong>Name</strong></span> - showing the formal name of the element</li>
<li class="listitem" style="list-style-type: none">
<span class="bold"><strong>Status</strong></span> - indicating whether the element is core or an extension</li>
</ul></div>
    </div>
<p>
    The core elements of the specification have a blank Status column, and any extension
    is labeled either as "extension" or "override".
  </p>
  <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ExtendTypes"></a>Extension Types</h3></div></div></div>
    
    <p>
      Each of the element types described here represents an XML tag of the same name, which, if
      present in the table, must either be in the <span class="emphasis"><em>compiler specification</em></span> file,
      the <span class="emphasis"><em>processor specification</em></span> file, or provided to Ghidra as an
      import document.
      </p>
<div class="informalexample">
	<div class="variablelist"><dl class="variablelist">
<dt><span class="term"><span class="bold"><strong>prototype</strong></span></span></dt>
<dd>
	    <p>
	      This element is a <a class="xref" href="DecompilerConcepts.html#ConceptPrototypeModel" title="Prototype Model">&#8220;Prototype Model&#8221;</a> that holds a specific named set
	      of parameter passing details. It
	      can be applied to individual functions by name, typically via the "Calling Convention" menu
	      in the <a class="ulink" href="help/topics/FunctionPlugin/Variables.htm#Edit_Function" target="_top">Function Editor Dialog</a>.
	      See the documentation on <a class="xref" href="DecompilerAnnotations.html#AnnotePrototype" title="Function Prototypes">&#8220;Function Prototypes&#8221;</a> for how they affect decompilation.
	    </p>
	    <p>
	      The XML tag, <code class="code">&lt;prototype&gt;</code> always has a <span class="bold"><strong>name</strong></span> attribute
	      that defines the formal name of the prototype model, which must be unique across all models.
	      </p>
<pre class="programlisting">
&lt;prototype name="__stdcall" extrapop="unknown" stackshift="4"&gt;
  &lt;input&gt;
    &lt;pentry minsize="1" maxsize="500" align="4"&gt;
      &lt;addr offset="4" space="stack"/&gt;
    &lt;/pentry&gt;
  &lt;/input&gt;
  &lt;output&gt;
  ...
	      </pre>
<p>
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>callfixup</strong></span></span></dt>
<dd>
	    <p>
	      This element is a Call-fixup, which can be used to substitute a specific p-code
	      sequence for CALL instructions during decompilation, as described in
	      <a class="xref" href="DecompilerAnnotations.html#AnnotePrototype" title="Function Prototypes">&#8220;Function Prototypes&#8221;</a>.
	    </p>
	    <p>
	      The <code class="code">&lt;callfixup&gt;</code> tag has a <span class="bold"><strong>name</strong></span>
	      attribute listing the formal name, which must be unique across all call-fixups.
	      </p>
<pre class="programlisting">
&lt;callfixup name="EH_prolog3"&gt;
  &lt;pcode&gt;
    &lt;body&gt;&lt;![CDATA&lt;
      EBP = ESP + 4;
      tmp = * EBP;
      ESP = ESP - tmp;
      ESP = ESP - 24;
    ]]&gt;&lt;/body&gt;
  &lt;/pcode&gt;
&lt;/callfixup&gt;
	      </pre>
<p>
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>callotherfixup</strong></span></span></dt>
<dd>
	    <p>
	      This element is a Callother-fixup, which can be used to substitute a specific p-code
	      sequence for CALLOTHER p-code operations.  A CALLOTHER
	      is a black-box, or unspecified p-code operation, see <a class="xref" href="DecompilerConcepts.html#ConceptCallother" title="User-defined P-code Operations - CALLOTHER">&#8220;User-defined P-code Operations - CALLOTHER&#8221;</a>.
	    </p>
	    <p>
	      The <code class="code">&lt;callotherfixup&gt;</code> tag has a
	      <span class="bold"><strong>targetop</strong></span> attribute which lists the
	      name of the particular CALLOTHER operation it substitutes for.
	      </p>
<pre class="programlisting">
&lt;callotherfixup targetop="dynamicPush"&gt;
  &lt;pcode&gt;
    &lt;input name="amount"/&gt;
    &lt;body&gt;&lt;![CDATA[
      RSP = RSP + amount;
    ]]&gt;&lt;/body&gt;
  &lt;/pcode&gt;
&lt;/callotherfixup&gt;
	      </pre>
<p>
	    </p>
	  </dd>
</dl></div>
      </div>
<p>
    </p>
  </div>
  <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ExtendStatus"></a>Status</h3></div></div></div>
    
    <p>
      The Status column labels an element as either a core specification
      or an extension; it also gives an indication of whether the element
      is about to be installed or removed.
    </p>
    <p>
      With no changes pending, the column will show one of the three main values:
      </p>
<div class="informalexample">
	<div class="variablelist"><dl class="variablelist">
<dt><span class="term"><span class="emphasis"><em>&lt;blank&gt;</em></span></span></dt>
<dd>
	    <p>
	      A blank Status column indicates that the element is a core part of the
	      specification, originating from one of the <span class="emphasis"><em>specification files</em></span>.
	      These elements cannot be changed or removed.
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>extension</strong></span></span></dt>
<dd>
	    <p>
	      Indicates that the element is a program specific extension that has been
	      added to the specification.
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>override</strong></span></span></dt>
<dd>
	    <p>
	      Indicates that the element, which must be a <span class="bold"><strong>callotherfixup</strong></span>,
	      is an extension that overrides a core element with the same target.  The extension
	      effectively replaces the p-code injection of the core element with a user supplied one.
	      If this type of extension is later removed, the core element becomes active again.
	    </p>
	  </dd>
</dl></div>
      </div>
<p>
    </p>
    <p>
      If the user has either imported additional extensions or selected an extension for removal but
      has not yet clicked the <span class="emphasis"><em>Apply</em></span> button in the Options dialog, the Status column
      may show one of the following values, indicating a pending change.
      </p>
<div class="informalexample">
	<div class="variablelist"><dl class="variablelist">
<dt><span class="term"><span class="bold"><strong>install</strong></span></span></dt>
<dd>
	    <p>
	      Indicates a new extension that will be installed.
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>remove</strong></span></span></dt>
<dd>
	    <p>
	      Indicates an extension that is about to be removed.
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>replace</strong></span></span></dt>
<dd>
	    <p>
	      Indicates a new extension that will replace a current
	      extension with the same name.
	    </p>
	  </dd>
<dt><span class="term"><span class="bold"><strong>override pending</strong></span></span></dt>
<dd>
	    <p>
	      Indicates a new extension that will override a core element when
	      it is installed.
	    </p>
	  </dd>
</dl></div>
      </div>
<p>
    </p>
  </div>
  <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ExtendImport"></a>Importing a New Extension</h3></div></div></div>
    
    <p>
      The <span class="emphasis"><em>Import</em></span> button at the bottom of the
      "Specification Extensions" pane allows the user to import one of the
      three element types, <span class="bold"><strong>prototype</strong></span>,
      <span class="bold"><strong>callfixup</strong></span>, or <span class="bold"><strong>callotherfixup</strong></span>,
      into the program as a new extension.
      The user must supply a properly formed XML document, as a file, that fully describes the new
      extension.  Clicking the <span class="emphasis"><em>Import</em></span> button brings up a File Chooser dialog,
      from which the user must select their prepared XML file.  Once <span class="emphasis"><em>Ok</em></span> is
      clicked, the file is read in and validated.  If there are any problems with the validation, or if
      the new extension's name collides with a core element, the import does not succeed and
      an error message will be displayed. Otherwise, the import is accepted, and the table is updated
      to indicate the pending change.
    </p>
    <p>
      The final change to the program, installing the new extension, will not happen until the
      <span class="emphasis"><em>Apply</em></span> button, at the bottom of the Options dialog, is clicked.
    </p>
    <p>
      The XML file describing the extension <span class="emphasis"><em>must</em></span> have one of the tags,
      <code class="code">&lt;prototype&gt;</code>, <code class="code">&lt;callfixup&gt;</code>, or <code class="code">&lt;callotherfixup&gt;</code>,
      as its single root element. Users can find numerous examples within the compiler
      and processor specification files that come as part of Ghidra's installation.
      See <a class="xref" href="DecompilerConcepts.html#ConceptSpecification" title="SLEIGH Specification Files">&#8220;SLEIGH Specification Files&#8221;</a>.
    </p>
    <p>
      In the case of <span class="bold"><strong>prototype</strong></span> and <span class="bold"><strong>callfixup</strong></span>
      elements, extensions cannot replace existing core elements, so the new extension <span class="emphasis"><em>must not</em></span>
      have a name that matches an existing core element.  If a new <span class="bold"><strong>callotherfixup</strong></span>
      extension has a targetop that matches a core element, the extension is automatically treated as an override.
    </p>
    <p>
      Existing extensions can be replaced simply by importing a new extension with the same name or targetop.
    </p>
  </div>
  <div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ExtendRemove"></a>Removing an Extension</h3></div></div></div>
    
    <p>
      The <span class="emphasis"><em>Remove</em></span> button at the bottom of the "Specification Extensions" pane allows
      the user to remove a previously installed extension.  A row from the table is selected first, which
      must have a Status of <span class="bold"><strong>extension</strong></span> or <span class="bold"><strong>override</strong></span>.
      Core elements of the specification cannot be removed.
      Clicking the <span class="emphasis"><em>Remove</em></span> button brings up a confirmation dialog, and if
      <span class="emphasis"><em>Ok</em></span> is clicked, the selected extension is marked for removal.  The Status of the row
      changes to <span class="bold"><strong>remove</strong></span>, reflecting this.
    </p>
    <p>
      The final change to the program, removing the extension, will not happen until the
      <span class="emphasis"><em>Apply</em></span> button, at the bottom of the Options dialog, is clicked.
    </p>
    <p>
      If a <span class="bold"><strong>prototype</strong></span> or <span class="bold"><strong>callfixup</strong></span> is removed,
      all functions are checked to see if they have the matching calling convention or call-fixup set.
      A function with matching calling convention is changed to have the <span class="emphasis"><em>default</em></span> convention, which is always a core element.
      A function with matching call-fixup is changed to have no call-fixup.
    </p>
  </div>
</div>

</div></body>
</html>
