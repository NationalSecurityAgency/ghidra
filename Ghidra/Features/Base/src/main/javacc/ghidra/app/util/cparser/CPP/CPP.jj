/* ###
 * IP: Copyright Distribution Permitted
 * NOTE: Copyright contributed code
 */
/*
  Copyright notice: let's see... Hmmm, this example started out with little promise,
  with very little restrictions. The prospect of its publication has led me to make it more
  presentable. I also moved it to about 98% completion, with enough didactic constructs
  to serve as learning example. With that in mind, (C) Copyright Malome T. Khomo 1999.
  Some rights  reserved, Whatever changes you make, just retain this notice, and if you have enhancements
  to make it really useful and want your enhancements integrated into it please submit them
  to mkhomo@ostecs.com or through metamata.com

  A C and C++ preprocessor scanner/parser defintion for use with JavaCC. A C Preprocessor
  is usually called "CPP". But since that's been taken, so CPP.PreProcessor it is. This file is
  named cpp.jj and it whall be in the package named CPP. Tested under JDK 1.2/JavaCC 1.1 only.
  USAGE:

      mkdir cpp;
      cp cpp.jj cpp [ on UNIX]
      copy cpp.jj cpp [ in DOS ]
      cd cpp
      javacc cpp.jj
      cd ..
      javac -g cpp/PreProcessor.java [ on UNIX]
      javac -g cpp\PreProcessor.java [ in DOS ]
      java CPP.Preprocessor [CompilerSwitches] C_or_CPLUSPLUS_SourceFiles ...

  You can do the usual Jar archiving and classpath to it.

  In the DOS environment I run a batch script that contains the following (sample) compile command
  java CPP.PreProcessor -I"\Program Files\DevStudio\Vc\Include" -Iapa -D_DLL -D_M_IX86=500 -D_MSC_VER=9090 -D_INTEGRAL_MAX_BITS=32 apa\apax.c>apax.i

  In the last few months I ran this less on Solaris, so I could have problems there I have not checked.

  Created by Malome Khomo (mkhomo@ostecs.com) Jan 23, 1999, stopped Nov 22, 1999

  Motivation:
  The C and C++ examples distributed with JavaCC do not include PreProcessing, and it
  is not possible to use those parsers without one.

  The grammar for the PP used here was initially lifted off Borland (now Inprise)
  3.1 C++ Programmer's Guide (pp158). I found it impossible to formulate in JavaCC as-is.
   The unfortunate consequence is that this implementation is not based on any known
  formal grammar specification. There are vestiges of the Inprise grammar I reintroduced
  but it is a very precarious implementation. If you feed it obfuscated code you're on
  your own.


  Sriram has been patient but I lost a lot of time discovering the limits of String.indexOf()
  so I am releasing only basic macro functionality. What's missing is substitution of line
  continuations, concatenating and quoting of macro parameters. I suspect it misses a few
  substitutions because I have to manually stop it from doing the wrong things...

  Productions: (as required by K&R-C, ANSI-C and C++ ARM)
  I have tried to make this preprocessor compatible to all three. Therefore it will
  happily take '#' at column 1 as agreed by all, but will also allow whitespace immediately
  after as allowed in K&R, unlike ANSI, but then it will also accept non-newline white
  space immediately before '#" as allowed in ANSI but not in K&R.

  Here is what you will need to finish as an exercise ....

  <COMMENTS>		- replace with single space, may be excising too much
  <CONTINUED_LINES>	- Join them back into a single line, again replace with single space

  <MACRO>
  arg1 ## arg2: Concatenate two macro arguments in the body of the replacement text
  #arg:   : Surround arg with quote marks

  <TEXT>
  outer text				Join continuation lines with single space replacement

  <PREDEFINES>
  __LINE__, __FILE__ etc derive from PPToken.BeginLine and FileStack entries...

  <INTERMEDIATES>
  Supporting the -E option would be nice. Currently it only emits to stdout. The next nice
  to have feature would be emitting to an FileInputStream of a receiving C++ or C parser....

  I cheated in places and used exceptions to implement primary logic because I did not know
  when tokenizing whether the image is numeric or not, at a time when the issue was a
  distraction. I have not gone back to clean up. PPToken.compareTo[Zero]() may be
  changed to use Character.isDigit() or some such legal test. You will notice the
  inconvenience when you run the parser under a debugger.

  What may be useful but not necessary: GetOpts allows you to set manifest constants
  so that you can influence the compile-time directives.
  GetOpt does the usual thing with -I<filename> -D<key[=val]> -U<key>.  There's a couple
  of lame selective print statements that sometimes obviates the huge debug output. It's
  not well thought out, but it is a little like sendmail's -d. So far -v announcess the
  following:  1-translation,2-includes,3-def key,4-def key=val,5-def macro,6-ifdef test
  ,7-if condition,8-macro substitution. Don't expect too much from commandline if you're
  using the DOS   interface. The buffer is limited to 126 characters and blocks after
  type-ahead of 15 characters before it quietly throws away additional characters. You
  will fare better puting the command in a DOS Batch file.

  What does this thing demonstrate:
  -	Recursive non-static parser (through include calls) obviating the need to see <EOF>
    The NoMas() non-terminal unwinds the rather deep <EOF> match.
  */

options {
    STATIC = false;
    JAVA_UNICODE_ESCAPE = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(PreProcessor)

package ghidra.app.util.cparser.CPP;

import ghidra.util.Msg;
import ghidra.util.StringUtilities;
import ghidra.util.task.TaskMonitor;

import java.util.*;
import java.io.*;
import java.math.BigInteger;
import ghidra.program.util.AddressEvaluator; 

@SuppressWarnings("all") // ignore warnings from generated code
public class PreProcessor {
	class PPToken extends Token /* For Productions */{

		private String path = null;

		public PPToken(PPToken ptk) {
			super();
			this.kind = ptk.kind;
			this.image = ptk.image;
			this.beginLine = ptk.beginLine;
			this.truth = ptk.truth;
			this.comparison = ptk.comparison;
			this.contradict = ptk.contradict;
		}

		public PPToken(Token tk) {
			super();
			this.kind = tk.kind;
			this.image = tk.image;
			this.beginLine = tk.beginLine;
			this.comparison = 0;
			this.truth = false;
			contradict = false;
		}

		public PPToken(Token tk, boolean truth) {
			super();
			this.kind = tk.kind;
			this.image = tk.image;
			this.beginLine = tk.beginLine;
			this.comparison = 0;
			this.truth = truth;
			contradict = false;
		}

		public PPToken(String val) {
			super();
			this.kind = 0;
			this.image = val;
			this.beginLine = 0;
			this.comparison = 0;
			this.truth = false;
			contradict = false;
		}

		boolean truth;
		boolean contradict;
		boolean emitExecSave;
		int comparison;
		
		ArrayList <StringBuffer> appendList = new ArrayList();
        ArrayList <Boolean> expandList = new ArrayList();
                
        void append(String str, boolean expand) {
           if (image != null & image.length()>0) {
               appendList.add(new StringBuffer(image));
               expandList.add(true);
               image = null;
           }
           int endIndex = appendList.size() - 1;
           if (endIndex >= 0 && (str.strip().length()==0 || expand == expandList.get(endIndex)) ) {
        	   // just add to the last image so it can expand properly
        	   StringBuffer lastStr = appendList.get(endIndex);
        	   lastStr.append(str);
        	   return;
           }
           
           appendList.add(new StringBuffer(str));
           expandList.add(expand);
        }
        
//        void append(PPToken tok, boolean expand) {
//           if (tok.image != null && tok.image.length() > 0) {
//              append(tok.image, expand);
//              return;
//           }
//		   int cnt = 0;
//           for (String string : appendList) {
//              append(string, expandList.get(cnt));
//           }
//        }

		void setTruth(boolean truth) {
			this.truth = truth;
			this.contradict = false;
		}

		void setContra(boolean truth) {
			this.contradict = truth;
		}

		void setKind(int kind) {
			this.kind = kind;
		}

		void setLine(int line) {
			this.beginLine = line;
		}

		void setEmitSave(boolean truth) {
			this.emitExecSave = truth;
		}

		void setPath(String path) {
			this.path = path;
		}

		String getPath() {
			return path;
		}

		// For hashtable
		public boolean equals(Object t) {
			if (t.getClass() == getClass()) {
				return this.image.equals(((PPToken) t).image);
			} else
				try {
					if (t.getClass() == Class.forName("CPP.Token")) {
						return this.image.equals(((Token) t).image);
					} else if (t.getClass() == Class
							.forName("java.lang.String")) {
						return this.image.equals((String) t);
					}
				} catch (ClassNotFoundException e) {
					addParseMessage(null, "PPToken.equals: " + e.getMessage());
				}
			return false;
		}

		double Double() {
			return Double.parseDouble(this.image);
		}

		int Integer() {
			return Integer.parseInt(this.image);
		}

		void fixupNumericValue(PPToken val) {
			int opos = val.image.indexOf('(');
			if (opos >= 0) {
				int cpos = val.image.lastIndexOf(')');
				if (cpos >= 0 && cpos != opos + 1) {
					val.image = val.image.substring(opos + 1, cpos - 1).trim();
				}
			}
			val.image = defs.expand(val.image, true);
			val.kind = getNumericType(val.image);
		}

		int compareToZero() {
			try {
				switch (this.kind) {
					case PreProcessor.FP_NUMERIC:
					case PreProcessor.FP_LITERAL:
						Double thisFP = new Double(this.image);
						Double zeroFP = new Double(0.0);
						comparison = thisFP.compareTo(zeroFP);
						break;
					case PreProcessor.INTEGER_LITERAL:
					case PreProcessor.NUMERIC:
						BigInteger value = getLongValue(this.image);
						comparison = value.compareTo(BigInteger.ZERO);
						break;
					case PreProcessor.CHAR_NUMERIC:
					case PreProcessor.CHAR_LITERAL:
						char ch = getCharacterValue(this.image);
                        BigInteger charValue = BigInteger.valueOf(ch);
                        comparison = charValue.compareTo(BigInteger.ZERO);
                        break;    
					case PreProcessor.ITEM:
					case PreProcessor.MANIFEST:
					case PreProcessor.VALUES:
						if (isDef(this) == true) {
							PPToken repVal = (PPToken) getDef(this);
						}
						break;
					default:
						addParseMessage(null, "Cannot compareToZero Token: " + image + " kind " + kind);
						break;
				}
			}
			catch (Exception e) {
				addParseMessage(null, "CMP2Zero:Numeric Conversion Error: " + e.getMessage());
			}
			return comparison;
		}

		int compareTo(PPToken that) {
			Double thisFP = new Double(0.0);
			Double thatFP = new Double(0.0);
			String thisVal = null;
			String thatVal = null;
			try {
				switch (this.kind) {
					case PreProcessor.FP_NUMERIC:
					case PreProcessor.FP_LITERAL:
						thisFP = new Double(this.image);
						break;
					case PreProcessor.NUMERIC:
					case PreProcessor.INTEGER_LITERAL:
						thisFP = new Double(getLongValue(this.image).doubleValue());
						break;
					case PreProcessor.CHAR_NUMERIC:
					case PreProcessor.CHAR_LITERAL:
						char ch = getCharacterValue(this.image);
						thisFP = new Double((double)ch);
                        break;						
					default:
						PPToken replVal = (PPToken) getDef(this); // not a PPToken
						if (replVal == null) {
							replVal = new PPToken(this);
							// addParseMessage(null,
							// "Missing numeric value for: "+image+" at "
							// +curFileStackTop
							// ()+"'"+beginLine+". PreProcessor expects one.");
						}
						thisVal = replVal.image;
						fixupNumericValue(replVal);
						thisFP = getDoubleValue(replVal.image);
				}
			}
			catch (NumberFormatException e) {
				thisFP = null;
			}
			catch (Exception e) {
				thisFP = null;
				// addParseMessage(null, "Numeric Conversion Error for '" + this.image
				// + "' in " + curFileStackTop() + " line " + that.beginLine +
				// " : "+e.getMessage());
			}
			try {
				switch (that.kind) {
					case PreProcessor.FP_NUMERIC:
					case PreProcessor.FP_LITERAL:
						thatFP = new Double(that.image);
						break;
					case PreProcessor.NUMERIC:
					case PreProcessor.INTEGER_LITERAL:
						thatFP = new Double(getLongValue(that.image).doubleValue());
						break;
					case PreProcessor.CHAR_NUMERIC:
					case PreProcessor.CHAR_LITERAL:
						char ch = getCharacterValue(this.image);
						thisFP = new Double((double)ch);
                        break;
					default:
						PPToken replVal = (PPToken) getDef(that); // not a PPToken
						if (replVal == null) {
							replVal = new PPToken(that);
							// addParseMessage(null,
							// "Missing numeric value for: "+image+" at "
							// +curFileStackTop
							// ()+"'"+beginLine+". PreProcessor expects one.");
						}
						thatVal = replVal.image;
						fixupNumericValue(replVal);
						thatFP = getDoubleValue(replVal.image);
				}
			}
			catch (NumberFormatException e) {
				thatFP = null;
			}
			catch (Exception e) {
				thatFP = null;
				// addParseMessage(null, "Numeric Conversion Error in " +
				// curFileStackTop() + " line " + that.beginLine +
				// " : "+e.getMessage());
			}
			if (this.image.equals(that.image)) {
				return 0;
			}
			if (this.image.equals(thatVal)) {
				return 0;
			}
			if (thisVal != null && thisVal.equals(that.image)) {
				return 0;
			}
			if (thisVal != null && thisVal.equals(thatVal)) {
				return 0;
			}
			if (thisFP != null && thatFP != null) {
				comparison = thisFP.compareTo(thatFP);
			}
			else if (thisFP != null && thatFP == null) {
				comparison = 1;
			}
			else if (thisFP == null && thatFP != null) {
				comparison = -1;
			}
			else if (thisVal != null && thatVal != null) {
				comparison = thisVal.compareTo(thatVal);
			}
			return comparison;
		}

		PPToken computeBinary(Token op, PPToken val2) { 
			BigInteger tvalue = BigInteger.ZERO;
			BigInteger result = BigInteger.ZERO;
			BigInteger vvalue = BigInteger.ZERO;
			try {
				tvalue = getLongValue(getDef(this).image);
				vvalue = getLongValue(getDef(val2).image);
			}
			catch (Exception e) {
			}
			switch (op.kind) {
				case MINUS:
					result = tvalue.subtract(vvalue);
					break;
				case PLUS:
					result = tvalue.add(vvalue);
					break;
				case TIMES:
					result = tvalue.multiply(vvalue);
					break;
				case AND:
					result = tvalue.and(vvalue);
					break;
				case OR:
					result = tvalue.or(vvalue);
					break;
				case RSH:
					result = tvalue.shiftRight(vvalue.intValue());
					break;
				case LSH:
					result = tvalue.shiftLeft(vvalue.intValue());
					break;
			}
			PPToken t = new PPToken(result.toString());
			t.kind = NUMERIC;
			t.setTruth(!BigInteger.ZERO.equals(result));
			return t;
        }

        PPToken computeUnary(Token op) { 
			BigInteger tvalue = BigInteger.ZERO;
			BigInteger result = BigInteger.ZERO;
			try {
				tvalue = getLongValue(getDef(this).image);
			}
			catch (Exception e) {
			}
			switch (op.kind) {
				case MINUS:
					result = tvalue.negate();
					break;
				case NOT:
					result = (BigInteger.ZERO.equals(tvalue) ? BigInteger.ZERO : BigInteger.ONE);
					break;
			}
			PPToken t = new PPToken(result.toString());
			t.kind = NUMERIC;
			t.setTruth(!BigInteger.ZERO.equals(result));
			return t;
        }

		boolean getEmitSave() {
			return emitExecSave;
		}

		boolean getTruth() {
			if (contradict == false)
				return truth;
			else
				return !truth;
		}

		void join() {
			StringBuffer buf = new StringBuffer(image);
			int pos = image.length();
			while (pos > 0) {
				pos = image.lastIndexOf("\\\n", pos);
				if (pos >= 0) {
					buf.replace(pos, pos + 2, " ");
					pos--;
					continue;
				}
				pos = image.lastIndexOf("\\\r\n", pos);
				if (pos >= 0) {
					buf.replace(pos, pos + 3, " ");
					pos--;
					continue;
				}
				pos = image.lastIndexOf("\\\r", pos);
				if (pos >= 0) {
					buf.replace(pos, pos + 2, " ");
					pos--;
					continue;
				}
			}
			image = buf.toString();
		}

        void emit(boolean expand) {
        	if (expand && appendList.isEmpty()) {
                image = defs.expand(image, true);  
        	} else {
        		int cnt = 0;
        		for (StringBuffer string : appendList) {
        			if (expand && expandList.get(cnt++)) {
        				image += defs.expand(string.toString(), true);
        			} else {
        				image += string;
        			}
				}
    		}
    		if (image.length() == 1 && image.startsWith("\n")) {
               image = (!emitExecSwitch ? "///-\n" : "\n");
            }
    		print(image);
        }

	}

	// Command Line cursor
	int shift;

	// Emmitter switch
	boolean emitExecSwitch = true;

	// Hastable for storing #include file names
	HashSet<String> files = new HashSet<String>();

	// Stack for keeping shadowed (include) files
	Stack<String> fileStack = new Stack<String>();

	// Stack for keeping directive states
	Stack<PPToken> execStack = new Stack<PPToken>();

	// Token string for Include Directory Pathlist
	Vector<String> pathList = new Vector<String>();

	int ifDepth = 0;
	
	//Hastable for storing #defs
	DefineTable defs = new DefineTable();

	// output stream to print to
	PrintStream outputStream = System.out;

	// header files that have already been parsed, and the count of number of
	// times they have been parsed
	private HashMap<String, Integer> alreadyDone;

    private StringBuilder parseMessages = new StringBuilder();

    // true if parse was successful
    private boolean parseSuccess = false;
    
    private TaskMonitor monitor = null;

	// Toggle printing
	private int verboseLevel = 0;

	public int verboseLevel() {
		int vl = verboseLevel;
		return vl;
	}

	public String curFileStackTop() {
		return (fileStack.empty() ? "" : fileStack.peek().toString());
	}

	// get the define table for outside processing
	public DefineTable getDefinitions() {
		return defs;
	}
	
    // Get a def from the manifest constant list, from a defined string
	public PPToken getDef(PPToken def) {
		if (verboseLevel == 6 || verboseLevel == 5 || verboseLevel == 4 || verboseLevel == 3)
			println("Defs: containsKey: " + def.image + " = " + defs.containsKey(def.image));
		PPToken pt = defs.get(def.image);
		if (pt != null && pt.image.length() > 0) {
			String expanded = defs.expand(pt.image, false);
			pt = new PPToken(pt);
			pt.image = expanded;
		}
		else {
			// no Def, it is what it is!
			pt = def;
		}
		return pt;
	}
    
    // Get a define definition by name from the list
    public String getDef(String name) {
            PPToken pt = defs.get(name);
            String val = name;
			if (pt != null && pt.image.length() > 0) {
				val = defs.expand(pt.image, false);
			}
			else {
				// no Def, it is what it is!
			}
            return val;
    }

	// Add a def to the manifest constant list
	private void setDef(PPToken def) {
		if (verboseLevel == 3 || verboseLevel == 6)
			println(curFileStackTop() + "'" + def.beginLine + ": Defining: "
					+ def.image);
		if (emitExecSwitch == true) {
			defs.put(def.image, new PPToken(""));
			// setDef(def.image, "");
		}
	}

	// Add a def to the manifest constant list
	private void setDef(PPToken key, PPToken val) {
		if (verboseLevel == 4 || verboseLevel == 6)
			println(curFileStackTop() + "'" + key.beginLine
					+ ": Defining text: " + key.image + " = " + val.image);
		if (emitExecSwitch == true) {
			// val.expand(false);
			val.image = val.image.trim();
			val.setPath(curFileStackTop());
			defs.put(key.image, val);
		}
	}

	// Add an arg vector to the argument list
	private void setArg(PPToken key, Vector val) {
		if (verboseLevel == 4 || verboseLevel == 6) {
			print(curFileStackTop() + "'" + key.beginLine + ": Defining text: "
					+ key.image + " (");
			for (int i = 0; i < val.size(); i++) {
				if (i == 0) {
					print(((PPToken) val.elementAt(i)).image);
				} else if (i < val.size() - 1) {
					print("," + ((PPToken) val.elementAt(i)).image);
				} else {
					println("," + ((PPToken) val.elementAt(i)).image + ")");
				}
			}
		}
		if (emitExecSwitch == true) {
			defs.putArg(key.image, val);
		}
	}

	// Add a macro to the manifest constant and substitution list
	private void setMacro(PPToken key, Vector marg, PPToken val) {
		if (verboseLevel == 5 || verboseLevel == 6)
			println(curFileStackTop() + "'" + key.beginLine
					+ ": Defining text: " + key.image + " = " + val.image);
		if (emitExecSwitch == true) {
			setDef(key, val);
		}
		if (verboseLevel == 5 || verboseLevel == 6) {
			println("\t" + curFileStackTop() + "'" + key.beginLine
					+ ": Defining text: " + key.image + " (");
			for (int i = 0; marg!=null && i < marg.size(); i++) {
				if (i == 0) {
					print(((PPToken) marg.elementAt(i)).image);
				} else if (i < marg.size() - 1) {
					print("," + ((PPToken) marg.elementAt(i)).image);
				} else {
					println("," + ((PPToken) marg.elementAt(i)).image + ")");
				}
			}
		}
		if (emitExecSwitch == true) {
		  if (marg != null) {
			setArg(key, marg);
	      }
		}
	}

	// Remove a def from the manifest constant list
	private void UnDefine(PPToken def) {
		if (isArg(def)) {
			Forget(def);
		}
		if (isDef(def)) {
			if (emitExecSwitch == true) {
				defs.remove(def.image);
			}
		}
	}

	// Forget a macro from the substitution list
	private void Forget(PPToken val) {
		if (emitExecSwitch == true) {
			defs.removeArg(val.image);
		}
	}

	private void localPlace(PPToken inc, boolean xsym) throws ParseException {
		String def = inc.image;
		File incFile = null;
		FileInputStream fis = null;
		String srcPath = null;
		try {
			if (srcPath == null) {
				srcPath = "." + File.separator;
			}
			incFile = new File(srcPath + def);
			if (incFile.exists()) {
				fis = new java.io.FileInputStream(incFile);
			} else {
				incFile = new File(srcPath + def.toLowerCase());
				if (incFile.exists()) {
					fis = new java.io.FileInputStream(incFile);
				}
			}
		} catch (FileNotFoundException fene) {
			addParseMessage(incFile.getName(), fene.getMessage());
		}
		if (fis == null) {
			// addParseMessage(null,
			// "Warning: No relative path to #include \""+def+"\"\nThis is a design/configuration flaw. Trying the standard places...");
			standardPlace(inc, xsym);
		} else {
			if (verboseLevel == 2) {
				print("Line " + inc.beginLine + ": " + curFileStackTop()
						+ " => ");
			}
			swapFileStreams(incFile, fis);
		}
	}

	private void swapFileStreams(File incFile, FileInputStream fis) throws ParseException {
	    String fullPath = incFile.getAbsolutePath();
		if (verboseLevel == 2)
			print(fullPath + "\n");
		else if (verboseLevel == 1)
			println("Parsing stream " + fullPath + " ... ");

		boolean alreadyIncluded = addFile(fullPath);
		if (!alreadyIncluded)
		{
			StringBuffer pad = new StringBuffer();
			for (String element : fileStack) {
				pad.append("   ");
			}
            addParseMessage(null, "    " + pad + fullPath);
		}
		    
		PreProcessor parser = null;
		try {
			//
			// check how many times this file occurs on the stack to try to
			// detect inclusion recursion
			int pos = -1;
			int count = 0;
			do {
				pos = fileStack.indexOf(fullPath, pos + 1);
				if (pos >= 0) {
					count++;
				}
				if (count > 5) {
					addParseMessage(fullPath,
						"Error: Possible infinite inclusion recursion detected: \n" + fileStack);
					return;
				}
			} while (pos != -1);

			// check if this has already been done
			Integer val = alreadyDone.get(fullPath);
			if (val == null) {
				val = Integer.valueOf(0);
			}
			// Must parse headers multiple times, MS uses headers to set pack()
			// still useful for debugging
				
			val = val + 1;
			alreadyDone.put(fullPath, val);

			fileStack.push(fullPath);
			parser = new PreProcessor(this);
			parser.ReInit(fis);
			parser.Input();
			fileStack.pop();
        } catch (ParseException e) {
			addParseMessage(incFile.getName(), "ERROR parsing Included File: " + e.getMessage());
			throw e;
		}
		catch (TokenMgrError e) {
			addParseMessage(incFile.getName(), "ERROR parsing Included File: " + e.getMessage());
			throw e;
		}
	}

	private void standardPlace(PPToken inc, boolean xsym) throws ParseException {
		includeFile(inc, xsym);
	}

	// Returns true if constant is def
	private boolean isNDef(PPToken def) {
		if (verboseLevel == 6) {
			print("Line " + def.beginLine + ": " + curFileStackTop()
					+ " Check isNDef " + def.image);
		}
		if (defs.containsKey(def.image) == false) {
			if (verboseLevel == 6)
				println("True");
			return true;
		}
		if (verboseLevel == 6)
			println("False");
		return false;
	}

	// Returns true if constant is def
	public boolean isDef(PPToken def) {
		if (verboseLevel == 6) {
			print("Line " + def.beginLine + ": " + curFileStackTop()
					+ " Check isDef " + def.image);
		}
		if (defs.containsKey(def.image) == true) {
			if (verboseLevel == 6)
				println("True");
			return true;
		}
		;
		if (verboseLevel == 6)
			println("False");
		return false;
	}

	// Returns true if macro argument is defined
	public boolean isArg(PPToken arg) {
		if (verboseLevel == 6) {
			print("Line " + arg.beginLine + ": " + curFileStackTop()
					+ " Check isArg " + arg.image);
		}
		if (defs.isArg(arg.image) == true) {
			if (verboseLevel == 6)
				println("True");
			return true;
		}
		;
		if (verboseLevel == 6)
			println("False");
		return false;
	}
	
//	void bufAppendWithComment(PPToken buf, Token u) {
//	    if (emitExecSwitch==true)
//	        buf.append(u.image,true);
//	    else
//	        buf.append("///- " + u.image, false);
//	}
	
	void bufAppendWithComment(PPToken buf, Token u, Token previous, boolean commentNL) {
		String str = u.image;
		if (!emitExecSwitch) {
			if (commentNL) {
				// if not emmitting, replace any embedded \n with a \n-comment
				str = str.replace("\n", "\n///- ");
			}
			if (previous == null || previous.image.length() == 0) {
				str = "///- " + str;
			}
		}
		buf.append(str, emitExecSwitch);
	}

	// Parse include file
	private void includeFile(PPToken inc, boolean xsym) throws ParseException {
		String ft = inc.image;
		String fn = new String(ft);
		// get rid of any errant quoting or whitespace
		fn = fn.trim();

		// Check for quoted include file name, protects embedded spaces
		if (fn.startsWith("\"") && fn.indexOf('\"', 1) > 0) {
			fn = fn.substring(1, fn.indexOf('\"', 1));
		}

		// Check for <> include file name, protects embedded spaces
		if (fn.startsWith("<") && fn.indexOf('>', 1) > 0) {
			fn = fn.substring(1, fn.indexOf('>', 1));
		}

		FileInputStream fis = null;
		File iFile = null;
		int i;
		
		for (i = 0; i < pathList.size(); i++) {
			iFile = getFile(pathList.elementAt(i), fn, xsym);
			// don't include the same file name
			if (iFile != null
					&& iFile.getAbsolutePath().equals(fileStack.peek())) {
				continue;
			}
			fis = getFIS(iFile);
			if (fis != null) {
				break;
			}
		}
		if (fis == null) {
			iFile = new File(fileStack.lastElement());
			iFile = getFile(iFile.getParent(), fn, xsym);
			fis = getFIS(iFile);
		}
		if (fis == null) {
			addParseMessage(null, "WARNING: No path to #include " + ft +
				"    Assuming not needed!" + "\u005cnUse -I option");
			addParseMessage(null, "    Current Include Path: ");
			for (String element : fileStack) {
				addParseMessage(null, "     :   " + element);
			}
		} else {
			if (verboseLevel == 2) {
				print("Line " + inc.beginLine + ": " + curFileStackTop() + " => ");
			}

			swapFileStreams(iFile, fis);
			if (verboseLevel == 1) {
				addParseMessage(null, "Include depth " + fileStack.size() + ": Done!");
			}
		}
	}

	private File getFile(String parent, String filename) {
		return getFile(parent, filename, true);
	}

	private File getFile(String parent, String filename, boolean possibleXsym) {
		File file = findFile(parent, filename, possibleXsym);
		if (file != null) {
			return file;
		}
		// filename lower
		file = findFile(parent, filename.toLowerCase(), possibleXsym);
		if (file != null) {
			return file;
		}
		// parent and filename lower
		file = findFile(parent.toLowerCase(), filename.toLowerCase(),
				possibleXsym);
		if (file != null) {
			return file;
		}
		// parent and filename upper
		file = findFile(parent.toUpperCase(), filename.toUpperCase(),
				possibleXsym);
		return file;
	}

	private File findFile(String parent, String filename, boolean possibleXsym) {
		File iFile = null;

		iFile = new File(parent + File.separator + filename);
		if (iFile.exists())
			return iFile;

		// try just in this directory
		File sameiFile = new File(parent + File.separator
				+ (new File(filename)).getName());
		if (sameiFile.exists())
			return sameiFile;
			
		// try all files in this directory doing to-lower on both input file and output file
		// if match return it
		File folder = new File(parent);
		if (folder.isDirectory()) {
			File[] listOfFiles = folder.listFiles();
	
			if (listOfFiles != null) {
				for (File file : listOfFiles) {
					if (file.isFile() && filename.compareToIgnoreCase(file.getName()) == 0) {
						return file;
					}
				}
			}
		}
		
		if (possibleXsym) {
			String child = "";
			// look up parent chain, looking for a file that has an Xsym in it
			while (iFile != null && iFile.getParent() != null) {
				if (child.length() <= 0) {
					child = iFile.getName();
				} else {
					child = iFile.getName() + File.separator + child;
				}
				iFile = iFile.getParentFile();
				if (!iFile.exists()) {
					File frameFile = new File(iFile.getAbsolutePath()
							+ ".framework" + File.separator + iFile.getName());
					if (!frameFile.exists())
						continue;
					iFile = frameFile;
				}
				if (!iFile.isFile()) {
					if (iFile.getName().equals("..")) {
						return getFile(iFile.getParent(), child);
					}
					return null;
				}
				FileInputStream fis = getFIS(iFile);
				if (fis == null) {
					return null;
				}
				String nPath = "";

				try {
					try {
						// open the file
						BufferedReader br = new BufferedReader(
								new InputStreamReader(fis));
						String str = br.readLine();
						// check for XSym
						if (str == null || !str.equals("XSym")) {
							File subFile = getFile(iFile.getParent()
									+ File.separator + "Headers", child, true);
							if (subFile != null) {
								return subFile;
							}
							return getFile(iFile.getParent(), child, true);
						}
						str = br.readLine();
						str = br.readLine();
						// pull out the file link
						nPath = br.readLine();

						if (nPath.length() <= 0) {
							return null;
						}

						// recreate the full file
						iFile = new File(iFile.getParent() + File.separator
								+ nPath + File.separator + child);

						// recurse
						return getFile(iFile.getParent(), iFile.getName(), true);
					} finally {
						fis.close();
					}
				} catch (IOException e) {
				}
				return null;
			}
			// if found, re-create the file name with the new indirection
		}
		return null;
	}

	private FileInputStream getFIS(File iFile) {
		if (iFile == null) {
			return null;
		}
		FileInputStream fis = null;
		try {
			if (iFile.exists())
				fis = new java.io.FileInputStream(iFile);
			if (fis == null) {
				// try lower case
				File lowerFile = new File(iFile.getParent(), iFile.getName()
						.toLowerCase());
				if (lowerFile.exists())
					fis = new java.io.FileInputStream(lowerFile);
			}
		} catch (FileNotFoundException fene) {
			addParseMessage(null, fene.getMessage() + " " + iFile);
		}
		return fis;
	}

	// Add an include file to those already included, return true if already included
	private boolean addFile(String file) {
	    if (files.contains(file)) {
	      return true;
	    }
		files.add(file);
		return false;
	}
	
	private void printCommentedLines(boolean emitSwitch, String line, String state) {
		StringBuffer buf = new StringBuffer("///");
		buf.append(emitSwitch ? "+ " : "- " );
		buf.append(line);
		if (emitSwitch && state != null) {
			buf.append(" ===" + state);
		}
		buf.append("\n");
		print(buf.toString());
		// "#else if " + t.image + (emitExecSwitch == false ? "" : " ===" + t.getTruth()) + "\n"
    }

	// Print String
	private void print(String text) {
		outputStream.print(text);
	}

	// Print NewLine String
	private void println(String text) {
		outputStream.println(" " + text);
	}

	// Prints out all the files used in parsing the source
	private void printFiles() {

		Iterator<String> eFiles = files.iterator();

		while (eFiles.hasNext()) {
			addParseMessage(null, "PreProcessor: " + eFiles.next());
		}
	}

	// Run the command-line parser
	private int getopt(String args[]) throws ParseException {
		int argc = args.length, i;
		for (i = 0; i < argc; i++) {
			String argString = args[i];
			switch (argString.charAt(0)) {
			case '-':
				String optValue = "";
				if (argString.length() > 2) {
					optValue = argString.substring(2);
				} else if (i < args.length - 1) {
					optValue = args[++i];
				}
				switch (argString.charAt(1)) {
				case 'I':
					addIncludePath(optValue);
					continue; // continue loop
				case 'D':
					String key,
					val;
					StringTokenizer parms = new StringTokenizer(optValue, "=");
					if (parms.hasMoreTokens()) {
						key = parms.nextToken();
						if (parms.hasMoreTokens()) {
							val = parms.nextToken();
						} else {
							val = "";
						}
						if (verboseLevel == 3 || verboseLevel == 6) {
							addParseMessage(null, "Predefining " + key + " to " + val);
						}
						Token k, v;
						k = new Token();
						v = new Token();
						k.image = key;
						v.image = val;
						v.kind = getNumericType(val);
						k.kind = PreProcessor.ITEM;
						PPToken ppk = new PPToken(k);
						PPToken ppv = new PPToken(v);
						setDef(ppk, ppv);
						if (verboseLevel == 3 || verboseLevel == 6) {
							addParseMessage(null, "Defs: containsKey: " + key + " = " +
										defs.containsKey(key) + " " + defs.size());
						}
					} else {
						if (verboseLevel == 3 || verboseLevel == 6) {
							addParseMessage(null, "Predefining " + optValue);
						}
						Token k = new Token();
						k.image = argString.substring(2);
						PPToken ppk = new PPToken(k);
						k.kind = PreProcessor.ITEM;
						setDef(ppk);
					}
					continue; // continue loop
				case 'U': // usefulness unlikely in simple versions of this
							// parser
					defs.remove(optValue);
					// check String.equal() in defs
					continue; // continue loop
				case 'v':
					try {
						verboseLevel = Integer.parseInt(optValue, 10);
					} catch (NumberFormatException nfe) {
						addParseMessage(null, "Verbose Level Error: " + nfe.getMessage());
						throw new ParseException("Bad verbosity level " + optValue);
					}
					continue; // continue loop
				case 'O':
					try {
						setOutputStream(new java.io.FileOutputStream(optValue));
					} catch (FileNotFoundException exc) {
						addParseMessage(null, "Couldn't create file " + optValue);
						throw new ParseException("Couldn't create file " + optValue);
					}
					continue;
				default:
					addParseMessage(null, "Unknown option: " + argString);
					throw new ParseException("Unknown option: " + argString);
				}
			default:
				break; // will quit loop;
			}
			return i;
		}
		return i;
	}

	public void addIncludePath(String path) {
		pathList.addElement(path);
	}
	
	public void addIncludePaths(String[] paths) {
		if (paths == null || paths.length < 1) {
			return;
		}
		
		for (String path : paths) {
			addIncludePath(path);
		}
	}

	public int getNumericType(String val) {
		try {
			Double.parseDouble(val);
			return PreProcessor.FP_NUMERIC;
		} catch (NumberFormatException nfe) {
			try {
				if (val.endsWith("L") || val.endsWith("l") || val.endsWith("U")) {
					val = val.substring(0, val.length() - 1);
				}
				if (val.startsWith("0x") || val.startsWith("0X")) {
					Integer.parseInt(val.substring(2), 16);
				} else {
					Integer.parseInt(val);
				}
				return PreProcessor.NUMERIC;
			} catch (NumberFormatException exc) {
			}
		}
		return PreProcessor.ITEM;
	}

	public Double getDoubleValue(String val) {
		double value = 0.0;
		try {
			value = Double.parseDouble(val);
		} catch (NumberFormatException nfe) {
			value = getLongValue(val).doubleValue();
		}
		return value;
	}

	private BigInteger getLongValue(String str) throws NumberFormatException {
		try {
			if (str.endsWith("L") || str.endsWith("l") || str.endsWith("U")) {
				str = str.substring(0, str.length() - 1);
				return getLongValue(str);
			}
			
			if (str.startsWith("--")) {
			    str = str.substring(2, str.length());
			}

			if (str.startsWith("0x") || str.startsWith("0X")) {
				return new BigInteger(str.substring(2), 16);
			}
			return new BigInteger(str);
		} catch (NumberFormatException exc) {
		}
		throw new NumberFormatException("Couldn't parse number: \'" + str + "\'");
	}
	
	private char getCharacterValue(String str) {
	    String charStr = str;
		if (charStr.charAt(0) == 'L') {
			charStr = charStr.substring(1);
		}
		// strip off "''"
		charStr = charStr.substring(1, charStr.length()-1);
		charStr = StringUtilities.convertEscapeSequences(charStr);
		return charStr.charAt(0);
	}

	private void addParseMessage(String filename, String message) {
	    if (filename != null) { 
		   parseMessages.append("   In file " + filename + "\n");
        }
	    parseMessages.append(message + "\n");
	}
	
	public String getParseMessages() {
		return parseMessages.toString();
	}

	public boolean didParseSucceed() {
	  return parseSuccess;
	}

	public void setArgs(String[] args) throws ParseException {
		shift = getopt(args);
	}

	public void setOutputStream(OutputStream fos) {
		outputStream = new PrintStream(fos);
	}

	public boolean parse(String filename) throws ParseException {
		if (verboseLevel == 1) {
			addParseMessage(null,
				"PreProcessor:  Reading from file " + filename + " . . .");
		}

		FileInputStream fis = null;
		try {
			fis = new java.io.FileInputStream(filename);
		} catch (FileNotFoundException e1) {
		}
		if (fis == null) {
			for (int i = 0; i < pathList.size(); i++) {
				File iFile = getFile(pathList.elementAt(i), filename);
				fis = getFIS(iFile);
				if (fis != null) {
					filename = iFile.getAbsolutePath();
					break;
				}
			}
		}
		if (fis == null) {
			String msg = "PreProcessor:  File " + filename + " not found.";
			addParseMessage(null, msg);
			Msg.error(this, msg);
			return false;
		}	
		fileStack.push(filename);
		alreadyDone = new HashMap<String, Integer>();
		ReInit(fis);
		try {
			Input();
			fileStack.pop();
			if (fileStack.size() == 0) {
				if (verboseLevel == 1) {
					addParseMessage(null,
						"PreProcessor:  Java program parsed successfully.");
				}
			}
		} catch (ParseException e) {
			addParseMessage(filename, "PreProcessor Parse Error:  " + e.getMessage());
			throw e;
		} catch (TokenMgrError e) {
			addParseMessage(filename, "PreProcessor Token Error:  " + e.getMessage());
			throw e;
		}
		return true;
	}

	PreProcessor(PreProcessor parent) {
		this(System.in);
		// suck the state out from the parent processor

		this.defs = parent.defs;
		this.execStack = parent.execStack;
		this.files = parent.files;
		this.fileStack = parent.fileStack;
		this.ifDepth = parent.ifDepth;
		this.outputStream = parent.outputStream;
		this.pathList = parent.pathList;
		this.shift = parent.shift;
		this.alreadyDone = parent.alreadyDone;
		this.verboseLevel = parent.verboseLevel;
		this.parseMessages = parent.parseMessages;
	}

	public PreProcessor(String[] args) throws ParseException {
		this(System.in);
		shift = getopt(args);

		if (args.length - shift == 0) {
			if (verboseLevel == 1) {
				addParseMessage(null,
					"PreProcessor:  Reading from standard input . . .");
			}
			fileStack.push("stdin");
		} else
			while (args.length - shift >= 1) {
				parse(args[shift]);
				shift++;
			}

	}

	public PreProcessor(String filename) throws ParseException {
		this(System.in);
		try {
			FileInputStream fis = new java.io.FileInputStream(filename);
			ReInit(fis);
		} catch (java.io.FileNotFoundException e) {
			addParseMessage(null, "PreProcessor:  File " + filename
					+ " not found.");
			addParseMessage(null, "Usage is one of:");
			addParseMessage(null, "         java PreProcessor < inputfile ...");
			addParseMessage(null, "OR");
			addParseMessage(null, "         java PreProcessor inputfile ...");
			return;
		}
	}

	public PreProcessor() throws ParseException {
		this(System.in);
	}
	
	public void setMonitor(TaskMonitor monitor) {
	    this.monitor = monitor;
	}

	// Run the parser
	public static void main(String args[]) {
		try {
			PreProcessor parser = new PreProcessor(args);
		} catch (ParseException e) {
			System.out.println("PreProcessor:  Encountered errors during parse.");
			System.out.println("PreProcessor: " + e.getMessage());
		}
	}
}

PARSER_END(PreProcessor)


//PARSER PRODUCITONS SECTION

void Input() :
{
    PPToken b;
    int conditionDepth=execStack.size();
    PPToken ppt = new PPToken("\n#line 1: \""+curFileStackTop()+"\"\n");
    ppt.emit(false);
}
{
    ( b=TranslationUnit()
        {
           if (monitor != null && monitor.isCancelled()) {
              throw new ParseException("Parsing Canceled");
           }
           if (b.getTruth()==false) break;
        }
    )*
    {
        if (conditionDepth!=execStack.size()) {
            addParseMessage(null, "Imbalance in sequence/nesting of compile-time conditions/logic in input file "+curFileStackTop());
            addParseMessage(null, "              " + execStack);
            // pop off conditionals, so we can get back on track
            while (conditionDepth != execStack.size() && execStack.size() > 0) {
            	PPToken olde = execStack.pop();;
                emitExecSwitch = olde.getEmitSave();
            }
        }
        // Out of translation units
        return;
    }

}


PPToken TranslationUnit() : {PPToken b;}
{
    (LOOKAHEAD(2) b=Group() {if (b.getTruth()==false) break;})+{return b;}
}

void NoMas() : {}
{
    <EOF>
}

PPToken Group() : {PPToken b;}
{
    LOOKAHEAD(2)  b=GroupPart(){ return b;}  |
    (LOOKAHEAD(2) b=IFSection(){if (b.getTruth()==false) return b;})+{return b;}
}


PPToken GroupPart() : { PPToken t,u=new PPToken("");Token v=new Token();v.image="";}
{
    (LOOKAHEAD(2)
     (t=Text()
      // (v=<WS>{u.image+=v.image;})*
     ){
         /* ==>> HERE IS WHERE WE EMIT <<=== */
         // t.append(u.image, true);
         if (emitExecSwitch==true) { t.emit(true); } else t.emit(false);
         t.image="";
         u.image="";
     }
    )+
      { t.setTruth(true); return t;}
    |   LOOKAHEAD(3)(LOOKAHEAD(2)t=IFSection()  {return t;})+
    |   t=ControlLine(){return t;}
}

PPToken ControlLine() : {PPToken t = new PPToken(""), u = null; Vector vals = new Vector();}
{
    (LOOKAHEAD(2)
     Define() |
     Include() |
     UnDef() |
     Pragma() |
     Error() |
     Warning() |
     Info() |
     LineInfo() ){
        if (vals!=null&&vals.size()==0) vals = null;
        t.setTruth(true);
        return t;
    } |
    NoMas(){
        t.setTruth(false);
        return t;
    }
}

PPToken IFSection() : {PPToken ifg, group;}
{
    ifg = IFGroup()
    {
        group = GroupPart();
        return group;
    }
}

PPToken IFGroup() : { PPToken t, e, olde; }
{
    (e=If() t=IfCondition(){
         e.setEmitSave(emitExecSwitch);
         e.setTruth(t.getTruth());
         execStack.push(e);
         printCommentedLines(emitExecSwitch, "#if " + t.image, "" + t.getTruth());
         if (emitExecSwitch==true) emitExecSwitch = e.getTruth();
         if (verboseLevel==6||verboseLevel==7) {
             println("["+execStack.size()+"]"+"If "+t.getTruth()+" : "+emitExecSwitch);
         }
     } |
     e=ElIf() t=ElseIfCondition(){
         e.setTruth(t.getTruth());
         if (execStack.size()==0) {
             addParseMessage(null,curFileStackTop()+"'"+t.beginLine+"Unbalanced IF directive detected");
	         throw new ParseException(curFileStackTop()+"'"+t.beginLine+"Unbalanced IF directive detected");
         }
         olde = (PPToken) execStack.pop();
         emitExecSwitch = olde.getEmitSave();
         printCommentedLines(emitExecSwitch, "#elif " + t.image, "" + t.getTruth());
         e.setEmitSave(emitExecSwitch);
         if (!olde.getTruth() && emitExecSwitch==true)
             emitExecSwitch = e.getTruth();
         else
             emitExecSwitch = false;
         if (olde.getTruth()) e.setTruth(true);  // if previous "if" already true, carry forward
         execStack.push(e);
         if (verboseLevel==6||verboseLevel==7) {
             println("["+execStack.size()+"]"+"ElIf "+t.getTruth()+" : "+emitExecSwitch);
         }
     } |
     e=IfDef() t=IfDefExpr() {
         t.setEmitSave(emitExecSwitch);
         execStack.push(t);
         printCommentedLines(emitExecSwitch, "#ifdef " + t.image, "" + t.getTruth());
         if (emitExecSwitch==true) emitExecSwitch = t.getTruth();
         if (verboseLevel==6||verboseLevel==7) {
             println("["+execStack.size()+"]"+"IfDef "+t.getTruth()+" : "+emitExecSwitch);
         }
     } |
     e=IfNDef() t=IfNDefExpr() {
         t.setEmitSave(emitExecSwitch);
         execStack.push(t);
         printCommentedLines(emitExecSwitch, "#ifndef " + t.image, "" + t.getTruth());
         if (emitExecSwitch==true) emitExecSwitch = t.getTruth();
         if (verboseLevel==6||verboseLevel==7) {
             println("["+execStack.size()+"]"+"IfNDef "+t.getTruth()+" : "+emitExecSwitch);
         }
     } |
     t=Else(){
         if (execStack.size()==0) {
             addParseMessage(null, curFileStackTop()+"'"+t.beginLine+"Unbalanced ELSE directive detected");
             throw new ParseException (curFileStackTop()+"'"+t.beginLine+"Unbalanced IF directive detected");
         }
         olde = (PPToken) execStack.pop();
         emitExecSwitch = olde.getEmitSave();
         printCommentedLines(emitExecSwitch, "#else", "" + t.getTruth()); 
         t.setEmitSave(emitExecSwitch);
         if (emitExecSwitch && olde.getTruth()) emitExecSwitch = false;
         execStack.push(t);
         if (verboseLevel==6||verboseLevel==7) {
             println("["+execStack.size()+"]"+curFileStackTop()+"'"+t.beginLine+": Else now "+t.getTruth()+" : "+emitExecSwitch);
         }
     } |
     t=EndIf(){
         if (execStack.size()==0) {
            addParseMessage(null, curFileStackTop()+"'"+t.beginLine+"Unbalanced ENDIF directive detected");
            throw new ParseException(curFileStackTop()+"'"+t.beginLine+"Unbalanced IF directive detected");
         }
         olde = (PPToken) execStack.pop();
         boolean newExecSwitch = olde.getEmitSave();
         printCommentedLines(newExecSwitch, "#endif", "" + emitExecSwitch);
         emitExecSwitch = newExecSwitch;
         if (verboseLevel==6||verboseLevel==7) {
             println("["+execStack.size()+"]"+curFileStackTop()+"'"+t.beginLine+": Endif "+" : "+emitExecSwitch);
         }
     }

    ) { return t; }
}


PPToken IfCondition() : {PPToken t;}
{
    t=CompoundConditionalExpression(){return t;}
}

PPToken ElseIfCondition() : {PPToken t;}
{
    t=CompoundConditionalExpression(){return t;}
}

PPToken Include() : {Token t;PPToken pt;int conditionDepth=execStack.size();}
{
    (t=<RELATIVE>{
         pt=new PPToken(t);
         if (emitExecSwitch==true) {
             localPlace(pt, true);
             println("\n#line "+t.beginLine+": \""+curFileStackTop()+"\"");
         } else {
             printCommentedLines(emitExecSwitch, "#include <"+t.beginLine+">", "");
         }
     }
     |t=<STANDARD>{
         pt=new PPToken(t);
         if (emitExecSwitch==true) {
             standardPlace(pt, true);
             println("\n#line "+t.beginLine+": \""+curFileStackTop()+"\"");
         } else {
             printCommentedLines(emitExecSwitch, "#include \""+t.beginLine+"\"", "");
         }
     }
     |t=<MACEXPPATH>{
         pt=new PPToken(t);
         pt.image = defs.expand(pt.image, true);
         if (emitExecSwitch==true) {
             standardPlace(pt, true);
             println("\n#line "+t.beginLine+": \""+curFileStackTop()+"\"");
         }
     }
     |t=<XSYMLINKPATH>{
         pt=new PPToken(t);
         if (emitExecSwitch==true) {
             localPlace(pt, true);
             println("\n#line "+t.beginLine+": \""+curFileStackTop()+"\"");
         }
     }
    ){
        if (conditionDepth!=execStack.size()) {
            addParseMessage(null, "Imbalance in sequence/nesting of compile-time conditions/logic in included file "+t.image);
            addParseMessage(null, "              " + execStack);
            // pop off conditionals, so we can get back on track
            while (conditionDepth != execStack.size() && execStack.size() > 0) {
            	PPToken olde = execStack.pop();
                emitExecSwitch = olde.getEmitSave();
            }
        }
        return pt;
    }
}

PPToken LineInfo() : {Token t; Token u;}
{
    (
      t=<LINEINFO>
     |
      (t=<NUMERIC>)  {
         t.image = "#line " + t.image + ": \""+curFileStackTop()+"\"";
         println(t.image);
         token_source.SwitchTo(DEFAULT);   // bad stuff, but the only way to get back to default lexer
      }
    )
       {return new PPToken(t);}
}


PPToken Define() : {Token t,u=null,v=null,w=null,x=null;Vector dargs = null; }
{
    (LOOKAHEAD(2)  // supports current lexer
     (t=<MANIFEST>
      [LOOKAHEAD(2) ({u=new Token(); if (dargs==null) { dargs = new Vector(); }} ( u=MacroArgs() { dargs.add(u);})* <MACROARGSEND> | u=MacroVals() )
       [(w=MacroVals(){   if (x==null) {
	                           if (dargs != null) {
	                              x=w;
	                           } else {
	                              x=u;x.image+=w.image;
	                           }
	                       } else {
	                           x.image+=w.image;
	                       }
                           v=x;
                       }
             )+] ] ) |
     LOOKAHEAD(2) //  questionable
     (t=<MANIFEST>
      u=MacroArgs(){if (dargs==null) { dargs = new Vector(); } dargs.add(u);}
      [LOOKAHEAD(2)v=Define()]) |
     LOOKAHEAD(2) //  questionable
     (t=<MANIFEST>
      [ (u=MacroArgs(){if (dargs==null) { dargs = new Vector(); } dargs.add(u);})+
        [v=MacroVals()] ]) |
     (t=<MANIFEST> //  questionable
      (<WS>)+ u=Define() )
    ){
        PPToken pt=new PPToken(t);
        if (isDef(pt)==false) {
            if (u!=null&&v!=null) {
                PPToken pv=new PPToken(v);
                setMacro(pt,dargs,pv);
                printCommentedLines(emitExecSwitch, "#define " + pt.image + "("+dargs+")  " + pv.image, "" + "DEFINED");
            } else if (u==null&&v==null) {
                setDef(pt);
                printCommentedLines(emitExecSwitch, "#define " + pt.image, "" + "DEFINED");
            } else if (v!=null) {
                PPToken pv=new PPToken(v);
                setDef(pt,pv);
                printCommentedLines(emitExecSwitch, "#define " + pt.image + "  " + pv.image, "" + "DEFINED");
            } else if (u!=null) {
                if (dargs != null) {
                    PPToken pv=new PPToken("");
                    setMacro(pt,dargs,pv);
                    printCommentedLines(emitExecSwitch, "#define " + pt.image + "("+dargs+")  " + pv.image, "" + "DEFINED");
                } else {
                    PPToken pu=new PPToken(u);
                    setDef(pt,pu);
                    printCommentedLines(emitExecSwitch, "#define " + pt.image + "  " + pu.image, "" + "DEFINED"); 
                }
            }
        } else {
            if (verboseLevel==5||verboseLevel==6) println("PreProcessor: "+curFileStackTop()+"'"+t.beginLine+": "+t.image+" aready defined. Undefine first.");
        }

        return pt;
    }
}

PPToken UnDef() : {Token t;}
{
    (t=<CONSTITUENT> ) {
        PPToken pt=new PPToken(t);
        if (isDef(pt)==true) {
            UnDefine(pt);
        }
        printCommentedLines(emitExecSwitch, "#undef " + pt.image, null);
        return pt;
    }
}

PPToken MacroArgs() : {Token t,u=null;}
{
    (
      t=<MACROMV> |
      t=<MACROMVTAG >
    )
    {return new PPToken(t);}
}

PPToken MacroVals() : {Token s,t,u=new Token();u.image="";}
{
    (u=Values() |
     (LOOKAHEAD(2)(t=<MACRORV> {u.image+=t.image;} | t=<MACRORVCMT> { t.image="/"; } | t=<MQUOTED_VALUE> { u.image+="\""+t.image+"\"";}))+
     [LOOKAHEAD(2) (LOOKAHEAD(2)t=Values(){u.image+=t.image;})+  ]
     ) {return new PPToken(u);}
}

PPToken Pragma() :
{Token t,u=null; }
{   (LOOKAHEAD(2)(t=<PRAGMA_EXPRN> { if (u==null) { u = t; } else { u.image += t.image; } } ))+ {
       PPToken pt = new PPToken("#pragma");
       pt.append(u.image,emitExecSwitch);
       if (emitExecSwitch==true) {
    	   println("#pragma" + defs.expand(u.image,true));
       } else {
    	   printCommentedLines(emitExecSwitch, "#pragma" + u.image, null);
       }
       return pt;
    }
}

PPToken IfDef() :
{Token t;}
{   t=<IFDEFED>{
        PPToken pt=new PPToken(t);
        if (verboseLevel()==7) print(curFileStackTop()+"'"+t.beginLine+": "+t.image+": ");
        pt.setTruth(isDef(pt));
        return pt;
    }
}

PPToken IfDefExpr() :
{Token t;}
{   t=<IFDEF_EXPRN>{
        PPToken pt=new PPToken(t);
        if (verboseLevel()==7) print(curFileStackTop()+"'"+t.beginLine+": "+t.image+": ");
        pt.setTruth(isDef(pt));
        return pt;
    }
}


PPToken IfNDef() :
{Token t;}
{   t=<IFNDEFED> {
        PPToken pt=new PPToken(t);
        if (verboseLevel==6||verboseLevel==7) {
            print(curFileStackTop()+"'"+t.beginLine+" IFNDEF: ");
        }
        pt.setTruth(isNDef(pt));
        return pt;
    }
}

PPToken IfNDefExpr() :
{Token t;}
{   t=<IFNDEF_EXPRN> {
        PPToken pt=new PPToken(t);
        if (verboseLevel()==7) print(curFileStackTop()+"'"+t.beginLine+": "+t.image+": ");
        pt.setTruth(isNDef(pt));
        return pt;
    }
}

PPToken Error() :
{Token t;}
{   t=<ERROR_EXPRN>{
        printCommentedLines(emitExecSwitch, "#error " + t.image, "Error!");
        if (emitExecSwitch==true) {
            addParseMessage(null, curFileStackTop()+"'"+t.beginLine+" #error Error:");
            addParseMessage(null, t.image);
			throw new ParseException("PreProcessor hit #error \"" + t.image + "\"");
        }
        return new PPToken(t);
    }
}

PPToken Warning() :
{Token t;}
{   t=<WARNING_EXPRN>{
        printCommentedLines(emitExecSwitch, "#warning " + t.image, "Warning!");
        if (emitExecSwitch==true) {
            addParseMessage(null, curFileStackTop()+"'"+t.beginLine+" Warning: ");
            addParseMessage(null, t.image);
        }
        return new PPToken(t);
    }
}

PPToken Info() :
{Token t;}
{   t=<INFO_EXPRN>{
        if (emitExecSwitch==true) {
            Msg.info(this, curFileStackTop()+"'"+t.beginLine+" Info: ");
            Msg.info(this, t.image);
        }
        return new PPToken(t);
    }
}

PPToken EndIf() :
{Token t;}
{   t=<ENDIF>{return new PPToken(t);}
}

PPToken Else() :
{Token t;}
{   t=<ELSE>{
        return new PPToken(t);
    }
}

PPToken If() :
{Token t;}
{   t=<IF>{
        if (verboseLevel==6||verboseLevel==7) {
            print(curFileStackTop()+"'"+t.beginLine+" IF: ");
        }
        return new PPToken(t);
    }
}

PPToken ElIf() :
{Token t;}
{   t=<ELIF>{
        if (verboseLevel==6||verboseLevel==7) {
            print(curFileStackTop()+"'"+t.beginLine+" ElseIf: ");
        }
        return new PPToken(t);
    }
}

PPToken Values() :
{Token t;}
{
    (
    t=<VALUES> {
        t.kind = getNumericType(t.image);
    }|
    t=QuotedValue() |
    t=<VALUESCMT> {
      t.image = "/";
    } |
    t=<MOREVAL>
    ){
        PPToken pt=new PPToken(t);
        pt.join();
        return pt;
    }
}

PPToken QuotedValue() :
{Token t,u;t=new Token();t.image="\"";}
{
    u=<QUOTED_VALUE>{t.image+=u.image; t.image+="\"";return new PPToken(t);}
}

PPToken Text() :
{Token u, nl, lastToken = null; PPToken buf = new PPToken(""); }
{
    ( LOOKAHEAD(3)
      (LOOKAHEAD(2)(u=<OUTER_TEXT> { bufAppendWithComment(buf,u,lastToken,false); lastToken = u; }
                    (LOOKAHEAD(2) nl=NewLines() { bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; } )* |

                    u=<OTHER_TEXT> { bufAppendWithComment(buf,u,lastToken,false); lastToken = u; } )
       [LOOKAHEAD(2)nl=NewLines() { bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; }]
       [(LOOKAHEAD(2)(u=QuotedText() { bufAppendWithComment(buf,u,lastToken,true); lastToken = u; }
                    [LOOKAHEAD(2) nl=NewLines(){ bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; }] |
                    u=<OTHER_TEXT> { bufAppendWithComment(buf,u,lastToken,false); lastToken = u; })
           [LOOKAHEAD(2) nl=NewLines() { bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; } ]
           [LOOKAHEAD(2) u=<OTHER_TEXT> { bufAppendWithComment(buf,u,lastToken,false); lastToken = u; }]
           [LOOKAHEAD(2) nl=NewLines() { bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; }])+]
       [LOOKAHEAD(2) u=<OTHER_TEXT> { bufAppendWithComment(buf,u,lastToken,false); lastToken = u; }
        (LOOKAHEAD(2) nl=NewLines(){ bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; })*])+|
                
      (LOOKAHEAD(2)(u=QuotedText() { bufAppendWithComment(buf,u,lastToken,true); lastToken = u; }
                    [LOOKAHEAD(2) nl=NewLines(){ bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; }] |
                    u=<OTHER_TEXT> { bufAppendWithComment(buf, u,lastToken,false); lastToken = u; })
       [LOOKAHEAD(2) nl=NewLines() { bufAppendWithComment(buf,nl,lastToken,false); lastToken = null; }]
       [LOOKAHEAD(2) u=<OTHER_TEXT> { bufAppendWithComment(buf, u,lastToken,false); lastToken = u; }]
       [LOOKAHEAD(2) nl=NewLines() { bufAppendWithComment(buf, nl,lastToken,false); lastToken = null; }])+ |
       
      nl=NewLines() {
          //bufAppendWithComment(buf,nl);
          lastToken = null;
      }
    ) { return buf;}
}


PPToken NewLines() :
{Token t;}
{
    // only <NEWLINE> is essential for output,
    // the rest are fluff to emulate real preprocessor output
    // #if and #def newlines have been returned to their skip sections
    (
    t=<NEWLINE>  |    // general newline
//    t=<CMNTNL>   |    // newline coming from /* */  // stripped for now
    t=<EOLCMNTNL> |    // newline coming from //
    t=<ERRLINE>  |
    t=<LINLINE>  |
    t=<PRAGLINE>  |
    t=<IFDLINE>  |
    t=<IFNDLINE> |
    t=<DIRLINE> |
    t=<UNDLINE> |
    t=<CONLINE> |
    t=<INCLINE>
    ) {return new PPToken(t);}
}

PPToken QuotedText() :
{Token t = null; Token r = null; }
{
    (t=<QUOTED_TEXT>
      {
        if (r == null) {
           r = t;
        } else {
    	  r.image = r.image.substring(0,r.image.length()) + t.image.substring(1);
        }
       }
     )+
    
    { return new PPToken(r); }
}


PPToken CompoundConditionalExpression() :
{PPToken t,i,e;}
{
   (LOOKAHEAD(2) t=ConditionalExpression() |
      (LOOKAHEAD(2) t=CompoundOrExpression() |
                    t=CompoundAndExpression() )
    )
   {return new PPToken(t);}
}
                                 
PPToken CompoundAndExpression() :
{PPToken t,u,v;}
{
    t=ConditionalExpression()
      ( LOOKAHEAD(2)
        u=LogAnd(){
            if (verboseLevel()==7) print(u.image);
        }
        v=ConditionalExpression(){
            t.setTruth(t.getTruth()==true&&v.getTruth()==true);
            if (verboseLevel()==7) print(": ");
        })*{return t;}
}

PPToken CompoundOrExpression() :
{PPToken t,u,v;}
{
    t=ConditionalExpression()
      ( LOOKAHEAD(2)
        u=LogOr(){
            if (verboseLevel()==7) print(u.image);
        }
        v=ConditionalExpression(){
            t.setTruth(t.getTruth()==true||v.getTruth()==true);
            if (verboseLevel()==7) print(": ");
        })*{return t;}
}

PPToken ConditionalExpression() :
{PPToken t,u,i,e;}
{
    (t=LogicalOrExpression()
     (LOOKAHEAD(2)
       u=Qmark() i=LogicalOrExpression() u=ElseMark() e=LogicalOrExpression()
       { if (t.getTruth()==true) t=i; else t=e; }
      )*
    )
    {return t;}
}

PPToken LogicalOrExpression() :
{PPToken t,u,v;}
{
    (t=LogicalAndExpression()
     (LOOKAHEAD(2)
      u=LogOr(){
          if (verboseLevel()==7) print(u.image);
      }
      v=LogicalAndExpression(){
          t.setTruth(t.getTruth()==true||v.getTruth()==true);
          if (verboseLevel()==7) print(": ");
      })*
    ){return t;}
}

PPToken LogicalAndExpression() :
{PPToken t,u,v;}
{
    (t=EqualityExpression()
     ( LOOKAHEAD(2)
       u=LogAnd(){
           if (verboseLevel()==7) print(u.image);
       }
       v=EqualityExpression(){
           t.setTruth(t.getTruth()==true&&v.getTruth()==true);
           if (verboseLevel()==7) print(": ");
       })*
    ){return t;}
}

PPToken EqualityExpression() :
{PPToken t,u,v;}
{
    (t=InEqualityExpression()
     ( LOOKAHEAD(2)
       u=EqualTo(){
           if (verboseLevel()==7) print(u.image);
       }
       v=InEqualityExpression(){
           try {
               t.setTruth(t.compareTo(v)==0);
           } catch (NumberFormatException exc) {
               t.setTruth(false);
           }
           if (verboseLevel()==7) print(": ");
       })*
    ){return t;}
}

PPToken InEqualityExpression() :
{PPToken t,u,v;}
{
    (t=RelationalExpression()
     ( LOOKAHEAD(2)
       u=NotEqualTo(){
           if (verboseLevel()==7) print(u.image);
       }
       v=RelationalExpression(){
           try {
               t.setTruth(t.compareTo(v)!=0);
           } catch (NumberFormatException exc) {
               t.setTruth(true);
           }
           if (verboseLevel()==7) print(": ");
       })*
    ){return t;}
}

PPToken RelationalExpression() :
{PPToken t,u,v;}
{
    (t=LessExpression()
     ( LOOKAHEAD(2)
       u=LessThan(){
           if (verboseLevel()==7) print(u.image);
       }
       v=LessExpression(){
           try {
               t.setTruth(t.compareTo(v)<0);
           } catch (NumberFormatException exc) {
               t.setTruth(false);
           }
           if (verboseLevel()==7) print(": ");
       })*
    ){return t;}
}

PPToken LessExpression() :
{PPToken t,u,v;}
{  t=LessThanOrEqualExpression()
     (LOOKAHEAD(2)
      u=LessThan(){
          if (verboseLevel()==7) print(u.image);
      }
      v=LessThanOrEqualExpression(){
          try {
               t.setTruth(t.compareTo(v)<0);
           } catch (NumberFormatException exc) {
               t.setTruth(false);
           }
          if (verboseLevel()==7) print(": ");
      }
     )*{return t;}
}

PPToken LessThanOrEqualExpression() :
{PPToken t,u,v;}
{  t=GreaterThanOrEqualExpression()
     ( u=LessThanOrEqual(){
           if (verboseLevel()==7) print(u.image);
       }
       v=GreaterThanOrEqualExpression(){
           try {
               t.setTruth(t.compareTo(v)<=0);
           } catch (NumberFormatException exc) {
               t.setTruth(false);
           }
           if (verboseLevel()==7) print(": ");
       }
     )*{return t;}
}

PPToken GreaterThanOrEqualExpression() :
{PPToken t,u,v;}
{  t=GreaterThanExpression()
     ( u=GreaterThanOrEqual(){
           if (verboseLevel()==7) print(u.image);
       }
       v=GreaterThanExpression(){
           try {
               t.setTruth(t.compareTo(v)>=0);
           } catch (NumberFormatException exc) {
               t.setTruth(false);
           }
           if (verboseLevel()==7) print(": ");
       }
     )*{return t;}
}

PPToken GreaterThanExpression() :
{PPToken t,u,v;}
{  (
   t=Expression()
   (u=GreaterThan(){
        if (verboseLevel()==7) print(u.image);
    }
    v=Expression(){
        try {
            t.setTruth(t.compareTo(v)>0);
        } catch (NumberFormatException exc) {
            t.setTruth(false);
        }
        if (verboseLevel()==7) print(": ");
    }
   )*
   ){return t;}
}


PPToken LogOr() :
{Token t;PPToken pt;}
{
    t=<LOG_OR> {return new PPToken(t);}
}

PPToken LogAnd() :
{Token t;PPToken pt;}
{
    t=<LOG_AND> {return new PPToken(t);}
}

PPToken EqualTo() :
{Token t;PPToken pt;}
{
    t=<EQ> {return new PPToken(t);}
}

PPToken NotEqualTo() :
{Token t;PPToken pt;}
{
    t=<NEQ> {return new PPToken(t);}
}

PPToken LessThan() :
{Token t;PPToken pt;}
{
    t=<LT> {return new PPToken(t);}
}

PPToken LessThanOrEqual() :
{Token t;}
{
    t=<LE> {return new PPToken(t);}
}

PPToken GreaterThan() :
{Token t;}
{
    t=<GT> {return new PPToken(t);}
}

PPToken GreaterThanOrEqual() :
{Token t;}
{
    t=<GE> {return new PPToken(t);}
}

PPToken Qmark() :
{Token t;}
{
    t=<QMARK> {return new PPToken(t);}
}

PPToken ElseMark() :
{Token t;}
{
    t=<COLON> {return new PPToken(t);}
}


PPToken Assertion() :
{Token t; PPToken pt=null; boolean checkDefined = false; }
{
    ((t=<DEFINED> {if (verboseLevel()==7) print(t.image);} )
        pt=Expression()
    {
       pt = new PPToken(pt);
       pt.setTruth(isDef(pt) || (pt.kind == FP_NUMERIC || pt.kind == NUMERIC || pt.kind == CHAR_NUMERIC));  // numbers are always defined
       return pt;
    })
    | 
    ((t=<OPTIONED>  | t=<HASINCLUDE> | t=<HASINCLUDENEXT>
      {if (verboseLevel()==7) print(t.image);} )
      <BEGITEM> pt=Expression() <ENDITEM>
    {
       return pt;
    })
}

PPToken Expression() :
{ PPToken obj = null; }
{
  obj = InclusiveORExpression()
  {
    return obj;
  }
}
  

PPToken InclusiveORExpression() : {
    PPToken obj = null, obj2 = null; Token op=null;
}
{
	obj = ExclusiveORExpression() ( LOOKAHEAD(2) op=< OR > obj2=ExclusiveORExpression() { obj = obj.computeBinary(op, obj2); } ) *
	{
		return obj;
    }
}

PPToken ExclusiveORExpression() : {
    PPToken obj = null, obj2 = null; Token op=null;
}
{
	obj = ANDExpression() ( LOOKAHEAD(2) op=< XOR > obj2=ANDExpression() { obj = obj.computeBinary(op, obj2); } ) *
	{
		return obj;
    }
}

PPToken ANDExpression() : {
    PPToken obj = null, obj2 = null; Token op=null;
}
{
	obj = ShiftExpression() ( LOOKAHEAD(2) op=< AND > obj2=ShiftExpression() { obj = obj.computeBinary(op, obj2); } ) *
	{
		return obj;
    }
}

PPToken ShiftExpression() : {
   PPToken obj = null, obj2 = null; Token op=null;
}
{
	obj = AdditiveExpression()
	( LOOKAHEAD(2) (op=< LSH > | op=< RSH > ) obj2 = AdditiveExpression()
	   { obj = obj.computeBinary(op, obj2); }
	) *
	{
		return obj;
    }
}

PPToken AdditiveExpression() : {
    PPToken obj = null, obj2 = null; Token op=null;
}
{
	obj = MultiplicativeExpression()
	( LOOKAHEAD(2) ( op=< PLUS > | op=< MINUS >) obj2 = MultiplicativeExpression()
	  { obj = obj.computeBinary(op, obj2); }
    ) *
	{
		return obj;
    }
}

PPToken MultiplicativeExpression() : {
    PPToken obj = null, obj2 = null; Token op=null;
}
{
	obj = UnaryExpression()
	( LOOKAHEAD(2) ( op=< TIMES > | op=< DIVIDE > | op= < MOD > ) obj2 = UnaryExpression()
	  { obj = obj.computeBinary(op, obj2); }
    ) *
	{
		return obj;
    }
}


PPToken UnaryExpression() : {
     PPToken obj = null;
     Token op = null;
}
{
	(
		LOOKAHEAD(3)
		obj = LogNegation()
        | 
	    < PLUS > obj=LogNegation()
	    |
	    op=< MINUS > obj=LogNegation() { obj = obj.computeUnary(op); }
	)
	{
		return obj;
    }
}

PPToken LogNegation() :
{Token t; PPToken pt=null; boolean negate=false;}
{
    (t=<NOT>{
         negate = true;
         if (verboseLevel()==7) print(t.image);
     })*
    pt=ValueExpression(){
        if (negate==true) pt.setContra(true);
    }
    {return pt;}
}

PPToken ValueExpression() :
{Token t;Token v;PPToken pt;PPToken tv=null;
 Token u=null;Vector dargs = new Vector(); }
{

    (
    LOOKAHEAD(2)
    (t=<NUMERIC> | t=<FP_NUMERIC> | t=<CHAR_NUMERIC> | t=<ELSE> | t=<IF> ) {
        if (verboseLevel()==7) print(t.image);
        pt=new PPToken(t);
        if (pt.compareToZero()==0) pt.setTruth(false);
        else pt.setTruth(true);
        return pt;
    }
    |
    <BEGITEM> pt=CompoundConditionalExpression() <ENDITEM> {
    	return pt;
    }
    |
    pt=Assertion() {
        return pt;
    }
    |
    (t=<ITEM>) [ LOOKAHEAD(4) <BEGITEM> ((tv=Expression()) {dargs.add(tv);})+ <ENDITEM> ] {
        if (verboseLevel()==7) print(t.image);
        pt=new PPToken(t);
        if (dargs.size() > 0) {
            pt.image += "(";
            Enumeration<PPToken> denum = dargs.elements();
            int index = 0;
            while (denum.hasMoreElements()) {
                PPToken atok = (PPToken) denum.nextElement();
                if (index++ != 0) {
                        pt.image += ",";
                }
                pt.image += atok.image;
            }
            pt.image += ")";

            pt.image = defs.expand(pt.image, true);
            
            // The expanded macro text can't be injected into the parse stream
            // try parsing the expression with an internal simple expression
            // parser that can handle equality expressions
			Long val = AddressEvaluator.evaluateToLong(pt.image);
			if (val != null) {
			    pt.image = val.toString();
				pt.kind = NUMERIC;
				pt.setTruth(true);
				if (val == 0) {
					pt.setTruth(false);
				}
				return pt;
			}
        }
        pt.setTruth(isDef(pt));
        if (pt.getTruth()) {
            tv = getDef(pt);
            if (!pt.image.equals(tv.image)) {
            	tv.image = defs.expand(tv.image, true);
            	tv.kind = getNumericType(tv.image);
            }

			Long val = AddressEvaluator.evaluateToLong(tv.image);
			pt.setTruth(true);
			if (val != null) {
			  	pt.image = val.toString();
				pt.kind = NUMERIC;
				if (val == 0) {
					pt.setTruth(false);
				}
			}
		}
//        if (pt.getTruth()==true) tv =(PPToken) getDef(pt);
//        if (tv!=null) {
//            tv.beginLine=t.beginLine; return tv;
//        } else return pt;
		return pt;
    }
    )
    
}

// LEXICAL SCANNER SECTION
TOKEN_MGR_DECLS :
{
    int parenNesting = 0;
}

<DEFAULT>
SKIP:
{
    <_BOM: "\ufeff" > |    // beginning of file BOM for UTF8
    <_CTRL: (<WSP>)* <DIR> (<WSP>)* > : DIRECTIVE |
    <_XSYM: <XSYM> > : XSYMLINK |
    <_BLANKLINE: (<WSP>)+ >
}

<DEFAULT>
//MORE:
SKIP:
{
  <_LCMT: "/" "/" > : SpecialEOLComment |
  <_CMT: <CMT>(<ECMT>)  > : SpecialBlockComment
}

<SpecialEOLComment>
TOKEN :
{
  <EOLCMNTNL: <ENDL> > : DEFAULT
}
<SpecialEOLComment>
//MORE:
SKIP :
{
  <(~[])> 
}

<SpecialBlockComment>
SKIP :
{
  <CMNTNL: <ENDCMT> > : DEFAULT
}

<SpecialBlockComment>
// MORE:
SKIP:
{
  <(~[])>
}

<DEFAULT>
TOKEN:
{
    <#_EQ:  "==" > |
    <#_NEQ: "!=" > |
    <#_LT:  "<" > |
    <#_GT:  ">" > |
    <#_LE:  "<=" > |
    <#_GE:  ">=" > |
    <#_AND:  "&" > |
    <#_LOG_AND: "&&" > |
    <#_OR:  "|" > |
    <#_XOR:  "^" > |
    <#_LOG_OR: "||" > |
    <#_LSH:  "<<" > |
    <#_RSH:  ">>" > |
    <#_MINUS: "-" > |
    <#_PERCENT: "%" > |
    <#_PLUS: "+" > |
    <#_QMARK: "?" > |
    <#_COLON: ":" > |
    <#DIR:  "#" > |
    <#XSYM: "XSym" > |
    <#CMT:  "/" > |
    <#ECMT:  "*" > |
    <#ENDCMT: "*/" > |
    <#STARTCMT: "/*" > |
    <#COD:  ("\\" (<WSP>)* "\n" | "\\" (<WSP>)* "\r" | "\\" (<WSP>)* "\r\n" )> |
    <#ENDL: "\n" | "\r" | "\r\n" > |
    <#UNDIR:  (~["#","\n","\r","\"","/"," ","\t"] | "'\"'" | "'\\\"'" | "'#'")+  > |
    <#UNDIRALL:  (~["\n","\r","\"","/"] | "'\"'" | "'\\\"'" | "'#'")+  > |
    <#DEFD: "defined"> |
    <#OPTD: "__option"> |
    <#ENDREL: "\""> |
    <#CP: ")"  > |
    <#OP: "("  > |
    <#NOPAR: ~["(",")"]> |
    <#WSP: " " | "\t"  > |
    <#STD: ~[">"]> |
    <#REL: ~["\""]> |
    <#NOTENDL: ~["\n","\r"]>  |
    <#NOTENDLC: ~[" ","\t","\n","\r","/"]>  |
    <#NOTENDLSTAR: ~["\n","\r","*","/"]>  |
    <#NOTCMT:  ~["\n","\r","/","*","\""]>  |
    <#NOTCMTCOD:  ~["\\","\n","\r","/","\""]>  |
    <#NOTWS: ~[" ","\t"]> |
    <#NOTWSQ: ~[" ","\t","\n","\r","\""]> |
    <#NOTWQC: ~[" ","\t","\n","\r","/","\""]> |
    <#NOTWWSQLT: ~[" ","\t","\n","\r","<","\""]> |
    <#NOTWSQLT: ~["\t","\n","\r","<","\""]> |
    <#NOTVALCMT: ("/##/")> |
    <INTEGER_LITERAL: <DECIMAL_LITERAL> (["u","l","L","U"])* |
                      <HEX_LITERAL> (["u","l","L","U"])* |
                      <OCTAL_LITERAL> (["u","l","L","U"])* > |
    <#CHAR_LITERAL: ("L")? "\'" (~["\'"])+ "\'" > |
    <#DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])*> |
    <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+> |
    <#HEX_DIGIT: (["0"-"9","a"-"f","A"-"F"])> |
    <#OCTAL_LITERAL: "0" (["0"-"7"])*> |
    <FP_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]> |
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+> |
    <#NOTCHR: "!"> |
    <WS:  [" ","\t"] > |
    <OUTER_TEXT: (<WSP>)*(<UNDIR>)(<UNDIRALL>)* > |
    <NEWLINE: <ENDL> > : DEFAULT |
    <OTHER_TEXT:   ~[]  >
}


<DEFAULT>
TOKEN:
{
    <QUOTED_TEXT:  "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] |
                                                     ["0"-"7"] (["0"-"7"])? |
                                                     ["0"-"3"] ["0"-"7"] ["0"-"7"] |
                                                     (["\n","\r"] | "\r\n")))* "\"" >
}

<DIRECTIVE>
SKIP:
{
    "include" : INCLUDE
    |
    "import" : INCLUDE
    |
    "include_next" : INCLUDE
    |
    "pragma" : PRAGMA
    |
    "error" : ERROR
    |
    "warning" : WARNING
    |
    "info" : INFO
    |
    "define" : DEFINE
    |
    "undef" : UNDEFINE
    |
    "line" : LINE
    | // former IF states
    <_WSP0: <WSP> > : DIRECTIVE  |
    <_COD1: <COD> > : DIRECTIVE |
    <_WSP2: <WSP>> : DIRECTIVE |
    <COMMA: ","> : DIRECTIVE |
    <_LCMT0: <CMT><CMT>>  : LINECOMMENT |
    <_CMT0: <CMT><ECMT>>  : DIRECTIVECOMMENT
}


<DIRECTIVE>
TOKEN : {
    <IF: "if" > : DIRECTIVE |
    <ELIF: "elif" > : DIRECTIVE |
    <ELSE: "else" > { if (parenNesting == 0) SwitchTo(IGNORETOEOL); else matchedToken.kind=ITEM; } |
    <ENDIF: "endif" > { if (parenNesting == 0) SwitchTo(IGNORETOEOL); else matchedToken.kind=ITEM; } |
    <IFDEFED: "ifdef" > : IFDEF |
    <IFNDEFED: "ifndef" > : IFNDEF |
    <NOT: <NOTCHR> > |
    <DEFINED: <DEFD> > |
    <HASINCLUDE: "__has_include" > { if (parenNesting == 0) SwitchTo(INCDEF); matchedToken.kind=ITEM; }  |
    <HASINCLUDENEXT: "__has_include_next" > { if (parenNesting == 0) SwitchTo(INCDEF); matchedToken.kind=ITEM; } |
    <OPTIONED: <OPTD> > |
    <EQ: <_EQ> > |
    <NEQ: <_NEQ> > |
    <LT: <_LT>> |
    <GT: <_GT> > |
    <LE: <_LE> > |
    <GE: <_GE> > |
    <AND: <_AND> > |
    <OR: <_OR> > |
    <XOR: <_XOR> > |
    <LOG_OR: <_LOG_OR> > |
    <LOG_AND: <_LOG_AND> > |
    <LSH: <_LSH> > |
    <RSH: <_RSH> > |
    <MINUS: <_MINUS>> |
    <PLUS: <_PLUS>> |
    <DIVIDE: <CMT>> |
    <MOD: <_PERCENT >> |
    <TIMES: <ECMT>> |
    <QMARK: <_QMARK>> |
    <COLON: <_COLON>> |
//    <INT_CAST: "-0" | "- 0" | "- 0L" | "+ 0" > |
    <NUMERIC:  (<INTEGER_LITERAL>)+ > |
    <FP_NUMERIC: (<FP_LITERAL>)+ > |
    <CHAR_NUMERIC: (<CHAR_LITERAL>)+ > |
    <ITEM:  (["a"-"z","A"-"Z","_","$"] (["a"-"z","A"-"Z","_","$","0"-"9"])* | (["0"-"9"])+ | ["1"-"9"](["0"-"9"])* | ["0"](["0"-"9"])+ )> |
    <BEGITEM: <OP>> { parenNesting++; } : DIRECTIVE |
    <ENDITEM: <CP>> { parenNesting--; } : DIRECTIVE |
    <DIRLINE: <ENDL> > : DEFAULT
}

<IGNORETOEOL>
SKIP:
{
	<_TOEOL: (~["\n","\r","/"])* > : DIRECTIVE |
	<_LCMT11: <CMT><CMT>> : IGNORETOEOL |
	<_CMT11: <CMT><ECMT>>  : DIRECTIVECOMMENT
}

<INCDEF>
SKIP : {
    <_INCCOD: <COD> > : INCDEF |
    <_INCWSP: <WSP> > : INCDEF |
    <_INCCP: <CP> > : DIRECTIVE |
    <_INCOP: <OP> > : INCDEF |
    <_INCSTANDARD:  <_LT> (~["\n","\r",">",")","("])* <_GT> > : INCDEF
}

//<INCDEF>
//TOKEN : {
//    <INCSTANDARD:  (<STD>)+ { matchedToken.kind = ITEM; } >
//}


<XSYMLINK>
SKIP : {
    <_HEX: (<HEX_DIGIT>)+ <ENDL> (<HEX_DIGIT>)+ <ENDL> > : XSYMPATH |
    <_XSYMENDL: <ENDL> > : XSYMLINK
}

<XSYMPATH>
SKIP : {
    <EXPATH: <ENDL> > : DEFAULT
}

<XSYMPATH>
TOKEN : {
    <XSYMLINKPATH:  (<NOTENDL>)+ >
}

<INCLUDE>
TOKEN : {
    <INCLINE: <ENDL> > : INCLUDE |
    <MACEXPPATH: <NOTWWSQLT>(<NOTWWSQLT>)* > : DEFAULT
}

<INCLUDE>
SKIP : {
    <_COD: <COD> > : INCLUDE |
    <_WSP: <WSP> > : INCLUDE |
    <__LT: <_LT> > : STDPATH |
    <_QTE: <ENDREL> > : RELPATH |
    <_ECMT_INC: <CMT><ECMT> > : INCLUDE_COMMENT
}

<INCLUDE_COMMENT>
SKIP : {
    <_ECMT_INCLUDE_ns: ~["*"] > : INCLUDE_COMMENT |
    <_ECMT_INCLUDE_s:   "*" > : INCLUDE_COMMENT_END
}

<INCLUDE_COMMENT_END>
SKIP : {
    <_ECMT_INCLUDE_es: "*" > : INCLUDE_COMMENT_END |
    <_ECMT_INCLUDE_eo: ~["*","/"] > : INCLUDE_COMMENT |
    <_ECMT_INCLUDE_e:  "/" > : INCLUDE
}

<STDPATH>
SKIP : {
    <ESTD: <_GT> > : DEFAULT
}

<STDPATH>
TOKEN : {
    <STANDARD:  (<STD>)+ >
}

<RELPATH>
SKIP : {
    <_ENDREL: <ENDREL>>: DEFAULT
}

<RELPATH>
TOKEN : {
    <RELATIVE:  (<REL>)+ >
}


<PRAGMA>
TOKEN : {
    <PRAGMA_EXPRN:
             <WSP> ( ~["\\","\n","\r","/"," ","\t"] |
              (<CMT><NOTENDLSTAR>)
             )+ > : PRAGMA |
    <PRAGLINE:  <ENDL> > : DEFAULT
}

<PRAGMA>
SKIP : {
    <_LCMTPRAG: <CMT><CMT>> : LINECOMMENT |
    <_SCMT_PRAG: (<STARTCMT> (<NOTENDLSTAR> | ("*" ~["/"]) | ("/"))+ <ENDCMT>) > : PRAGMA |
    <_COD_WSP: <WSP>> : PRAGMA |
    <_COD_PRAG: <COD>> : PRAGMA
}


<IFDEF>
TOKEN : {
    <IFDEF_EXPRN:  <NOTWS> (<NOTENDLC> | ( "/" <NOTENDLC>) )* > : DEFAULT |
    <IFDLINE: <ENDL> > : DEFAULT
}

<IFDEF>
SKIP : {
    <_LCMT20: <CMT><CMT>> : LINECOMMENT |
    <_WSP3: <WSP>> : IFDEF
}

<IFNDEF>
TOKEN : {
    <IFNDEF_EXPRN:  <NOTWS> (<NOTENDLC> | ( "/" <NOTENDLC>) )* > : DEFAULT |
    <IFNDLINE: <ENDL> > : DEFAULT
}

<IFNDEF>
SKIP : {
    <_LCMT21: <CMT><CMT>> : LINECOMMENT |
    <_WSP4: <WSP>> : IFNDEF
}

<ERROR>
TOKEN : {
    <ERROR_EXPRN:  (<NOTENDL>)+ > : DEFAULT |
    <ERRLINE: <ENDL> > : DEFAULT
}

<ERROR>
SKIP : {
    <_WSP5: <WSP>> : ERROR
}


<WARNING>
TOKEN : {
    <WARNING_EXPRN:  <NOTWS> (<NOTENDL>)* > : DEFAULT |
    <WARNLINE: <ENDL> > : DEFAULT
}

<WARNING>
SKIP : {
    <_WSP6: <WSP>> : WARNING
}

<INFO>
TOKEN : {
    <INFO_EXPRN:  <NOTWS> (<NOTENDL>)* > : DEFAULT |
    <INFOLINE: <ENDL> > : DEFAULT
}

<INFO>
SKIP : {
    <_WSP_INFO: <WSP>> : INFO
}

<UNDEFINE>
SKIP : {
    <_LEADIN1: (<WSP>)+> : UNDEFINE
}

<UNDEFINE>
TOKEN : {
    <CONSTITUENT: <MANIFEST> > : DEFAULT |
    <UNDLINE: <ENDL>>: DEFAULT
}

<DEFINE>
SKIP : {
    <_LEADIN2: (<WSP>)+> : CONSTANT
}

<CONSTANT>
SKIP : {
    "(" : MACROARGS |
    ")" : MACROVALS |
    <_WSP7: <WSP>> : RVALUES |
    <_CODC: <COD>> : RVALUES
}

<CONSTANT>
TOKEN : {
    <MANIFEST: (["a"-"z","A"-"Z","_","$"] (["a"-"z","A"-"Z","_","$","0"-"9"])* | (["0"-"9"])+ | ["-","+"]["1"-"9"](["0"-"9"])* | ["-","+"]["0"](["0"-"9"])+ | "...") > |
    <CONLINE: <ENDL>> : DEFAULT
}


<LINE>
TOKEN : {
    <LINLINE: <ENDL>> : DEFAULT |
    <LINEINFO: (<NOTENDL>)+>
}


<COMMENT>
SKIP : {
    <_ECMT_COMMENT_ns: ~["*"] > : COMMENT |
    <_ECMT_COMMENT_s: "*" > : COMMENT_END
}

<COMMENT_END>
SKIP : {
    <_ECMT_COMMENT_es: "*" > : COMMENT_END |
    <_ECMT_COMMENT_eo: ~["*","/"] > : COMMENT |
    <_ECMT_COMMENT_e: "/" > : DEFAULT
}

<LINECOMMENT>
SKIP : {
    <_CMT3: (~["\n","\r"])* > : DEFAULT
}

<DIRECTIVECOMMENT>
SKIP : {
    <_ECMT_DIRECTIVECOMMENT_ns: ~["*"] > : DIRECTIVECOMMENT |
    <_ECMT_DIRECTIVECOMMENT_s: "*" > : DIRECTIVECOMMENT_END
}

<DIRECTIVECOMMENT_END>
SKIP : {
    <_ECMT_DIRECTIVECOMMENT_es: "*" > : DIRECTIVECOMMENT_END |
    <_ECMT_DIRECTIVECOMMENT_eo: ~["*","/"] > : DIRECTIVECOMMENT |
    <_ECMT_DIRECTIVECOMMENT_e: "/" > : DIRECTIVE
}

<RVALUES>
SKIP : {
    <_LCMT4: <CMT><CMT>> : LINECOMMENT |
    <_CMT4: <STARTCMT> > : RVALUES_COMMENT |
    <_QTE0: <ENDREL>> : QUOTED_VAL |
    <_WSP8: <WSP>> : RVALUES |
    <_COD2: (<WSP>)* <COD>> : RVALUES |
    <RVSLINE:  <ENDL>> : DEFAULT
}

<RVALUES>
TOKEN : {
    <VALUES: (<NOTVALCMT> |
              <NOTCMTCOD> |
              (<CMT><NOTENDLSTAR>) |
              ("'" ((~["\n","\r","\\"]) | ("\\" ~["\n","\r"] ) ) "'") |
              (["\\"] ~[" ","\n","\r"])
             )+ > : RVALUES |
    <VALUESCMT: <CMT><ENDL> > : DEFAULT |
    <MOREVAL: <MANIFEST> >
}


<RVALUES_COMMENT>
SKIP : {
    <_ECMT_RVALUES_ns: ~["*"] > : RVALUES_COMMENT |
    <_ECMT_RVALUES_s:   "*" > : RVALUES_COMMENT_END
}

<RVALUES_COMMENT_END>
SKIP : {
    <_ECMT_RVALUES_es: "*" > : RVALUES_COMMENT_END |
    <_ECMT_RVALUES_eo: ~["*","/"] > : RVALUES_COMMENT |
    <_ECMT_RVALUES_e:  "/" > : RVALUES
}


<QUOTED_VAL>
SKIP:
{
    <_EQT: <ENDREL>> : RVALUES
}

<QUOTED_VAL>
TOKEN:
{
    <QUOTED_VALUE: ( ~["\"","\\"] | "\\" ~["\n", "\r"] )+  > : QUOTED_VAL
}

<MACROARGS>
TOKEN : {
    <MACROMV: <MANIFEST> > |
    <MACROMVTAG: "[" <MANIFEST > "]" > |
    <MACROARGSEND: ")"> : MACROVALS 
}

<MACROARGS>
SKIP : {
    <_ECMT_MACROARGS: <CMT><ECMT> > : MACROARGSCOMMENT |
    <_CMT_MACROARGS: <CMT><CMT>(~["\n","\r"])+ > : MACROARGS |
    <_MWSP: ","> : MACROARGS |

    <_COD3: <COD> > : MACROARGS |
    <_MACWSP: <WSP>> : MACROARGS
}

<MACROARGSCOMMENT>
SKIP : {
    <_ECMT_MACROARGSns: ~["*"] > : MACROARGSCOMMENT |
    <_ECMT_MACROARGSs: "*" > : MACROARGSCOMMENT_END
}

<MACROARGSCOMMENT_END>
SKIP : {
    <_ECMT_MACROARGSes: "*" > : MACROARGSCOMMENT_END |
    <_ECMT_MACROARGSeo: ~["*","/"] > : MACROARGSCOMMENT |
    <_ECMT_MACROARGSe: "/" > : MACROARGS
}

<CONTARG>
SKIP : {
    ")" : MACROVALS
}

<CONTARG>
TOKEN : {
    <MOREARG: (<NOPAR>)+ >
}


<MACROVALS>
TOKEN : {
    <MACRORV: ( <NOTCMTCOD> | <CMT><NOTENDLSTAR> | ("\\" ~[" ","\t","\\","\n","\r"]))+ > : MACROVALS |
    <MACRORVCMT: <CMT><ENDL> > : DEFAULT
}

<MACROVALS>
SKIP : {
    <_LCMT7: <CMT><CMT>> : LINECOMMENT |
    <_COD4: (<WSP>)* <COD> > : MACROVALS |
    <_ECMT8: <CMT><ECMT> > : MACROVALS_COMMENT |
    <_QTE1: <ENDREL>> : MQUOTED_VAL |
    <MCVLINE: <ENDL>>: DEFAULT |
    <LEADIN3: (<WSP>)+> : MACROVALS
}


<MQUOTED_VAL>
SKIP:
{
    <_EQT1: <ENDREL>> : MACROVALS
}

<MQUOTED_VAL>
TOKEN:
{
    <MQUOTED_VALUE:  (~["\\","\""] | ("\\" ~[" ","\t","\n","\r"]) )+  > : MQUOTED_VAL
}

<MACROVALS_COMMENT>
SKIP : {
    <_ECMT_MACROVALS_ns: ~["*"] > : MACROVALS_COMMENT |
    <_ECMT_MACROVALS_s: "*" > : MACROVALS_COMMENT_END
}

<MACROVALS_COMMENT_END>
SKIP : {
    <_ECMT_MACROVALS_es: "*" > : MACROVALS_COMMENT_END |
    <_ECMT_MACROVALS_eo: ~["*","/"] > : MACROVALS_COMMENT |
    <_ECMT_MACROVALS_e:  "/" > : MACROVALS |
    <_ECMT_MACROVALS_ew: "/" (<WSP>)* <ENDL> > : DEFAULT
}
