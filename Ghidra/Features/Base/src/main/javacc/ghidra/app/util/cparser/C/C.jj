/* ###
 * IP: GHIDRA
 * NOTE: modified contribution for use with JavaCC distribution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*

  C grammar defintion for use with JavaCC
  Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97

  This parser assumes that the C source file has been preprocessed : all
  #includes have been included and all macros have been expanded. I accomplish
  this with "gcc -P -E <source file> > <output file>".

  There is a problem with compiler specific types, such as __signed, __const,
  __inline__, etc. These types can be added as typedef types before the parser
  is run on a file. See main() for an example. I have also found a strange little
  compiler specific "type" if you can call it that. It is __attribute__, but it
  does not seem to be used as a type. I found that just deleting the __attribute__
  and the following "offensive" code works.

  This grammar also prints out all the types defined while parsing the file. This
  is done via a call to printTypes() when the parser is complete. If you do not want
  this, just comment out the printTypes() method call in the production rule
  TranslationUnit(), which BTW is the root node for parsing a C source file.

  I have not in anyway extensively tested this grammar, in fact it is barely tested,
  but I imagine it is better to have a starting point for a C grammar other than from
  scratch. It has not been optimized in anyway, my main aim was to get a parser that
  works. Lookahead may not be optimum at choice points and may even be insufficient at
  times. I choose to err on the side of not optimum if I made a choice at all.

  If you use this grammar, I would appreciate hearing from you. I will try to maintain
  this grammar to the best of my ability, but at this point in time, this is only a side
  hobby (unless someone wants to pay me for doing JavaCC work!). In that regards, I am
  interested in hearing bugs and comments.

  TODO:

    Insert the appropiate code to enable C source trees from this grammar.

  */



options {
    // Methods and class variables should not be static to allow multiple parsers to be in use.
    // This is at the expense of some speed.
    STATIC= false;
    
    // Don't interpret unicode escape sequences, they can appear in embedded text in macros and strings,
    // which if interpreted can mess up parsing if they are pre-interpreted by the input stream.
    JAVA_UNICODE_ESCAPE = false;
    
    // However, if the file has real embedded unicode characters, such as some microsoft header files,
    // they need to be read correctly by the parser.  An example is the embedded code at the beginning
    // of a file that states that it is in unicode.  The characters might be all ascii, which for parsing
    // purposes is most likely the case.
    UNICODE_INPUT = true;
}


//options {
//    MULTI=true;
//    VISITOR=true;
//    // NODE_DEFAULT_VOID=true;
//}

PARSER_BEGIN(CParser)

package ghidra.app.util.cparser.C;

import ghidra.program.model.data.*;
import ghidra.program.model.data.Enum;
import ghidra.program.model.lang.CompilerSpec;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;
import ghidra.util.InvalidNameException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.*;

@SuppressWarnings("all")  // ignore warnings from generated code
public class CParser {

    private static String DEFAULT_PARSER_OUTPUT_FILENAME = "CParser.out";
    
    // Map for storing typedef types
    private Map<String, DataType> types = new HashMap<String, DataType>();    
    private Map<String, DataType> composites = new HashMap<String, DataType>();
    private Map<String, DataType> functions = new HashMap<String, DataType>();    
    private Map<String, DataType> enums = new HashMap<String, DataType>();

    private Map<String, DataType> declarations = new HashMap<String, DataType>();
    
    private Map<String, DataType> internalTypes = new HashMap<String, DataType>();

    private DataType lastDataType = DefaultDataType.dataType;
    private boolean storeNewDT = true;
    private String possiblyUndefinedType = null;

    DataTypeManager dtMgr = null;
    private DataTypeManager[] subDTMgrs = new DataTypeManager[0];

    private int cnt = 1;
    private int func_cnt = 1;

    private String headerFileName= null;     // Current header file from #line token
    private int headerFileLine = 1;          // Current line number from #line token
    private int headerFileLineOffset= 0;     // offset into parse stream of last #line token
    private String currentCategoryName = ""; // Current category, ROOT category

    private final static String ANONYMOUS_STRUCT_PREFIX = "_struct_";
    private final static String ANONYMOUS_UNION_PREFIX = "_union_";
    private final static String ANONYMOUS_FUNC_PREFIX = "_func_";
        
    // Stack for determining when the parser is parsing a typdef definition.
    private Stack<Boolean> typedefParsingStack = new Stack<Boolean>();

    // Stack for putting defined data types on
    private Stack<DataType> dataTypeStack = new Stack<DataType>();

    private StringBuilder parseMessages = new StringBuilder();

    // true if parse was successful
    private boolean parseSuccess = false;
    
    private TaskMonitor monitor = null;
    
    // packing size for structures
    private int packSize = 0;
    Stack<Integer> packStack = new Stack<Integer>();
    Stack<String> packStackID = new Stack<String>();

    String parseFileName = DEFAULT_PARSER_OUTPUT_FILENAME;

    public void setParseFileName(String fName) {
        parseFileName = fName;
    }
    
    private CategoryPath getCurrentCategoryPath() {
        return getCategory(currentCategoryName);
    }
    
    private CategoryPath getCurrentCategoryPath(String subCatName) {
        return getCategory(currentCategoryName).extend(subCatName);
    }

    private CategoryPath getCategory(String catName) {
        CategoryPath rootCat = CategoryPath.ROOT;
        if (catName == null || catName.length() == 0) {
            return rootCat;
        }
        
        CategoryPath cat= new CategoryPath(rootCat, catName);
        return cat;
    }

    private String getFileName(String path) {
        int slashpos = path.lastIndexOf('/');
        if (slashpos < 0) {
            slashpos = path.lastIndexOf('\\');
        }
        if (slashpos < 0) {
            return path;
        }
        return path.substring(slashpos + 1);
    }

    // Returns true if the given string is a typedef type.
    private boolean isType(String type) {
        // System.out.println("** isType " + type + " = " + (types.get(type)!=null));
        return getType(type) != null;
        // Object obj= types.get(type);
        // return obj instanceof DataType;
    }

    // Add a typedef type to those already defined
    private DataType addTypedef(String type, DataType dt) {

        if (type == null || dt == null) {
            addNearParseMessage("Problem with type " + type + " : " + dt);
            return dt;
        }
        
        if (type.equals(dt.getName())) {
            // these already get a typedef elsewhere
            if (dt instanceof Composite) {
                return addDef(composites,type,dt); 
            }
            if (dt instanceof Enum) {
                return addDef(enums,type,dt);
            }
        }

        // if typedef-ing an anonymous structure, rename structure/union
        if (dt instanceof Composite) {
            if (dt.getName().startsWith(ANONYMOUS_STRUCT_PREFIX) ||
                dt.getName().startsWith(ANONYMOUS_UNION_PREFIX))  {
                try {
                    composites.remove(dt.getName());
                    dt.setName(type);
                    dt = addDef(composites, type, dt);
                    return dt;
                } catch (InvalidNameException e) {
                    // handled below
                } catch (DuplicateNameException e) {
                    // handled below
                }
            }
        }

        // TODO: for builtin-Types, override with the built-in
        //       wchar_t, etc...
        if (type.equals("wchar_t")) {
        	dt = WideCharDataType.dataType;
        } else {
        	dt = new TypedefDataType(getCurrentCategoryPath(), type, dt, dtMgr);
        }
    	dt = addDef(types, type, dt);
    	
        return dt;
    }

    private DataType getType(String type) {
        Object obj;
        obj = composites.get(type);
        if (obj instanceof DataType) {
            return (DataType) obj;
        }
        obj = types.get(type);
        if (obj instanceof DataType) {
            return (DataType) obj;
        }
        obj = enums.get(type);
        if (obj instanceof DataType) {
            return (DataType) obj;
        }
        
        // only return a function as a type IF we are defining a typedef
        boolean functionsOK = typedefParsingStack.size() > 0;

        if (functionsOK) {
            obj = functions.get(type);
            if (obj instanceof DataType) {
                return (DataType) obj;
            }
        }

        DataType dt = findDataType(type);
        if (dt != null && (functionsOK || !(dt instanceof FunctionDefinition))) {
            return dt;
        }    
        
        // check the BuiltinTypeManager
        BuiltInDataTypeManager builtInMgr = BuiltInDataTypeManager.getDataTypeManager();
        DataType bdt = findDataType(builtInMgr, type);
        if (bdt != null) {
            return bdt;
        }
        
        possiblyUndefinedType = type;
        return null;
    }
    
    private DataType findDataType(String dataTypeString) {

        DataType dt = findDataType(dtMgr, dataTypeString);
        if (dt != null) {
            return dt;
        }

        for (int i = 0; i < subDTMgrs.length; i++) {
            DataTypeManager dtm = subDTMgrs[i];
            dt = findDataType(dtm, dataTypeString);
            if (dt != null) {
                return dt;
            }
        }

        return null;
    }

    private DataType findDataType(DataTypeManager dtm, String dataTypeString) {
        ArrayList<DataType> list = new ArrayList<DataType>();
        dtm.findDataTypes(dataTypeString, list);
        if (list.size() > 0) {
            return list.get(0);
        }

        return null;
    }
    
    private List<DataType> findAllDataTypes(String dataTypeString) {
        List<DataType> list = new ArrayList<DataType>();
        dtMgr.findDataTypes(dataTypeString, list);

        return list;
    }

    // Add a typedef type to those already defined
    private DataType addDef(Map<String, DataType> table, String name, DataType dt) {
        // System.out.println("** addDef " + name + " = " + (dt != null ? dt.getName() : " - no type -") );

		lastDataType = dt;
		
        DataType existingDT = table.get(name);
        if (existingDT != null && dt.isEquivalent(existingDT)) {
            return existingDT;
        }

        // If the exact data type exists in any open DTMgr, use the open DTmgr type
        // instead
        dt = findEquivalentInOpenDTMgrs(name, dt);

        if (storeNewDT) {
            try {
                dt = dtMgr.addDataType(dt, DataTypeConflictHandler.REPLACE_HANDLER);
            } catch (Exception e) {
                addNearParseMessage("Problem adding DataType " + dt.getDisplayName() + "\u005cn" + "    " + e.getMessage());
            }
        } else {
            dt = dt.clone(dtMgr);
        }

        table.put(name, dt);
        
        lastDataType = dt;

        return dt;
    }

    /**
     * Try to find this named data type in any open data type managers.
     * 
     * @param name name of datatype
     * @param dt datatype to find
     * @return Original dt if none found, dt in other archive if found and equivalent
     */
    private DataType findEquivalentInOpenDTMgrs(String name, DataType dt) {
        ArrayList<DataType> list = new ArrayList<DataType>();
        boolean foundDT = false;
        for (int i = 0; !foundDT && i < subDTMgrs.length; i++) {
            // look for the data type by name
            //    equivalent, return it
            // look for the data type by category
            //    equivalent, return it
            subDTMgrs[i].findDataTypes(name, list);

            Iterator<DataType> iter = list.iterator();
            while (iter.hasNext()) {
                DataType dataType = iter.next();
                if (dataType.isEquivalent(dt)) {
                    return dataType;
                }
            }
        }
        return dt;
    }
    
    // resolve data types using data type manager so that data organization is considered
    //
    private DataType resolveInternal(DataType datatype) {
        DataType existingDT = internalTypes.get(datatype.getName());
        if (existingDT != null) {
            return existingDT;
        }
        existingDT = datatype.clone(dtMgr);

        internalTypes.put(datatype.getName(), existingDT);

        return existingDT;
    }


    /**
     * Define a forward declared composite
     * 
     * @param name name of composite
     * @param comp composite most likely empty
     * @return composite with a name, possibly already declared
     */
    private Composite defineForwardDeclaredComposite(Token symName, Composite comp) {
        DataType dt = findAnyComposite(symName.image);
        if (dt instanceof Composite) {
            comp = (Composite) dt;
        }
        if (dt == null) {
            String nameStr = symName.image;
            try {
                comp.setName(nameStr);
            } catch (InvalidNameException e) {
                // This should not happen
                e.printStackTrace();
            } catch (DuplicateNameException e) {
                // This should not happen
                e.printStackTrace();
            }
            comp = (Composite) addDef(composites, nameStr, comp);
        }
        return comp;
    }

    /**
     * Define a named composite
     * 
     * @param name name of the composite
     * @param parentName possible parent name
     * @param comp the composite components
     * @return a new composite with the correct name and components
     */
    private Composite defineNamedComposite(Token name, Token parentName, Composite comp) {

            String nameStr = name.image;

            DataType dt = findAnyComposite(nameStr);

            // if existing composite is found
            boolean hasNoComponents = false;
            boolean hasSameSourceArchive = true;
            if (dt != null) {
                    Composite dtComp = (Composite) dt;

                    hasNoComponents = (dtComp.getNumDefinedComponents() == 0 ? true : false);

                    hasSameSourceArchive = Objects.equals(dt.getSourceArchive(), dtMgr.getLocalSourceArchive());
            }

            // make sure comp is a Composite, if existing dt is empty, in same category and archive
            if (comp instanceof Composite && hasNoComponents && hasSameSourceArchive) {
                    // existing composite was an empty placeholder
                    // replace the internals of the exisint datatype with the composite components
                    Composite dtcomp = (Composite) dt;
                    dtcomp.replaceWith(comp);
                    comp = dtcomp;
            } else {

                    // check if a parent name was specified, and if so insert it
                    // only single parent supported currently
                    if (parentName != null) {
                            DataType superDt = findAnyComposite(parentName.image);
                            if (superDt == null) {
                                    addNearParseMessage("Parent structure " + parentName.image + " for " + nameStr + " undefined ");
                            } else {
                                    // surgically add parent to top of structure
                                    comp.insert(0, superDt);
                            }
                    }
                    try {
                        comp.setName(nameStr);
                    } catch (InvalidNameException e) {
                        // This should not happen
                        e.printStackTrace();
                    } catch (DuplicateNameException e) {
                        // This should not happen
                        e.printStackTrace();
                    }
                    comp = (Composite) addDef(composites, nameStr, comp);
            }

            return comp;
    }


    private DataType findAnyComposite(String name) {
        DataType dt = getDef(composites, name);
        if (dt != null) {
            return dt;
        }
        
        if (!storeNewDT) {
        
            List<DataType> list = findAllDataTypes(name);
            for (int i = 0; i < list.size(); i++) {
                dt = list.get(i);
                if (dt instanceof Composite) {
                    return dt;
                }
            }
        }
        
        return null;
    }
    
    private DataType getEnumDef(String name) {
        DataType dt = getDef(enums, name);
        if (dt != null) {
            return dt;
        }
        
        if (!storeNewDT) {
            List<DataType> list = findAllDataTypes(name);
            for (int i = 0; i < list.size(); i++) {
                dt = list.get(i);
                if (dt instanceof Enum) {
                    return dt;
                }
            }
        }

        return null;
    }
    

    private DataType allocateEnumDT(Token t, ArrayList<EnumMember> list) {
    	String enumName = (t != null ? t.image : ("enum_" + cnt++));
    	
    	// get the normal enum size, which is an int
    	// TODO: allow for packing of enum to smallest value with either dataOrganization, or packing flag
        int normalEnumLen = (dtMgr != null ? dtMgr.getDataOrganization().getIntegerSize() : 4);
        
        // create an initial enum and add all new members
        EnumDataType enumDT= new EnumDataType(getCurrentCategoryPath(), enumName, 8, dtMgr);
        if (list != null) {
            for (EnumMember member : list) {
                try {
                        enumDT.add(member.name, member.value);
                } catch (IllegalArgumentException exc) {
                    addNearParseMessage("duplicate enum value: " + enumName + " : " + member.name + " : " + member.value);
                }
            }
            // get the minimum length to represent the values and resize if too big
            int minLen = enumDT.getMinimumPossibleLength();
            if (minLen > normalEnumLen) {
                enumDT.setLength(minLen);
            } else {
                enumDT.setLength(normalEnumLen);
            }
        } else {
            // length doesn't really matter, forward declaration with no values
            enumDT.setLength(normalEnumLen);
        }
        
        return addDef(enums, enumDT.getName(), enumDT);
    }

    private DataType getDef(Map<String, DataType> table, String name) {
        return table.get(name);
    }

    // Prints out all the types used in parsing the c source
    @SuppressWarnings("unused")
    private void printTypes() {
        System.out.println("**************   TYPES   ********************");
        printTable(types);
        System.out.println("**************   FUNCTIONS  *****************");
        printTable(functions);
        System.out.println("**************   DECLS      *****************");
        printTable(declarations);
        System.out.println("**************   ENUMS      *****************");
        printTable(enums);
        System.out.println("**************   STRUCTS    *****************");
        printTable(composites);
    }

    private void addNearParseMessage(String message) {
        parseMessages.append(message + "\n");
        parseMessages.append("   In file " + this.headerFileName + "\n");
        parseMessages.append(
            "  Near datatype: " + (lastDataType == null ? "- none -" : lastDataType.getName()) + "\n");

        int endLine = token_source.input_stream.line;
        long subLinenum = ((endLine - headerFileLineOffset) + headerFileLine);

        if (headerFileName != null) {
           parseMessages.append("         in " + headerFileName + " near line " + subLinenum + "\n");
        }
    }

    public String getParseMessages() {
        return parseMessages.toString();
    }

    public boolean didParseSucceed() {
      return parseSuccess;
    }
    
    public void setMonitor(TaskMonitor monitor) {
      this.monitor = monitor;
    }

    private FunctionDefinitionDataType newAnonymousFunction(FunctionDefinitionDataType currentFuncDT) {
      if (currentFuncDT != null) {
         return currentFuncDT;
      }
      return new FunctionDefinitionDataType(getCurrentCategoryPath("functions"), ANONYMOUS_FUNC_PREFIX+func_cnt++, dtMgr);
    }
    
    private void checkReturnDataType(DataType retDT) throws ParseException {
        if (retDT == null) {
            return; // treat as void type
        }
        DataType dt = retDT;
        int len = dt.getLength();
        if (len == 0 && dt instanceof TypeDef) {
            dt = ((TypeDef) dt).getBaseDataType();
        }
        if (len <= 0 && !dt.isEquivalent(DataType.VOID)) {
            throw new ParseException("'"+retDT.getName()+"'" + " is not fixed length.  Function return must be fixed length data type or void.");
        }
    }

  /**
   * Add a definition to the correct category for funcDT, and replace any use of funcDT in Declaration
   * 
   * @param dec Declaration data type change to replace any use of funcDT with new addDef
   * @param funcDT function to put in the correct category
   */
    private void defineAndReplaceFunction(Declaration dec, FunctionDefinitionDataType funcDT) {
        DataType newDT = addDef(functions, dec.getName(), funcDT);
        DataType newDecDT = newDT;
        DataType repDT = dec.getDataType();
        DataType origDT = repDT;
        // shove the data type into any pointer definition.
        while (repDT != null) {
                if (repDT instanceof Pointer) {
                        PointerDataType ptDT = (PointerDataType) repDT;
                        if (ptDT.getDataType() instanceof FunctionDefinition) {
                                ptDT.dataTypeReplaced(ptDT.getDataType(), newDT);
                                newDecDT = origDT;
                                break;
                        }
                        repDT = ptDT.getDataType();
                } else if (repDT instanceof Array) {
                        ArrayDataType arrDT = (ArrayDataType) repDT;
                        if (arrDT.getDataType() instanceof FunctionDefinition) {
                                arrDT.dataTypeReplaced(arrDT.getDataType(), newDT);
                                newDecDT = origDT;
                                break;
                        }
                        repDT = arrDT.getDataType();
                } else {
                        break;
                }
        }
        dec.setDataType(newDecDT);
    }

  /**
   * Apply any accumulated function Qualifiers to functionDT from Declaration
   * @param dec Declaration
   * @param funcDT function data type to qualify
   */
    private void applyFunctionQualifiers(Declaration dec, FunctionDefinition funcDT) {
		List<Integer> qualifierList = dec.getQualifiers();
		if (qualifierList.contains(NORETURN)) {
			funcDT.setNoReturn(true);
		}

		String convention = null;
		for (Integer qualifier : qualifierList) {
			switch (qualifier) {
				case CDECL:
					convention = CompilerSpec.CALLING_CONVENTION_cdecl;
					break;
				case STDCALL:
					convention = CompilerSpec.CALLING_CONVENTION_stdcall;
					break;
				case FASTCALL:
					convention = CompilerSpec.CALLING_CONVENTION_fastcall;
					break;
				case VECTORCALL:
					convention = CompilerSpec.CALLING_CONVENTION_vectorcall;
					break;
				case RUSTCALL:
					convention = CompilerSpec.CALLING_CONVENTION_rustcall;
					break;
				case PASCALCALL:
					convention = CompilerSpec.CALLING_CONVENTION_pascal;
					break;
			}
		}
		if (convention != null) {
			try {
				funcDT.setCallingConvention(convention);
			}
			catch (InvalidInputException e) {
				// should not happen
			}
		}
    }
    
    private Integer getConstantValue (Object obj, int defaultValue) {
        int value = defaultValue;
        
        if (obj == null) {
            return defaultValue;
        }
        
        if (obj instanceof Integer) {
            value = ((Integer)obj).intValue();
        }
        else if (obj instanceof Long) {
            value = (int) ((Long) obj).longValue();
        }
        else if (obj instanceof Character) {
            value = ((Character) obj).charValue();
        }
        return value;
    }
    
        private void pushPack(Token iD, int packingSize) {
        packStack.push(packingSize);
        String name = "";
        if (iD != null) {
            name = iD.image;
        }
        packStackID.push(name);
    }

    private int popPack(Token iD) {
        if (packStack.size() == 0) {
            return packSize;
        }
        String name = "";
        if (iD != null) {
            name = iD.image;
        }
        
        // keep poping looking for ID, stop when find it
        int popVal = packSize;
        do {
            String ID = packStackID.pop();
            popVal = packStack.pop();
            if (name.equals(ID)) {
                break;
            }
        } while (packStack.size() > 0);
        return popVal;
    }

    private void printTable(Map<String, DataType> table) {

        for (String name : table.keySet()) {
            DataType dt = table.get(name);
            String dataTypeName = "- unknown -";
            String mnemonic = "";
            if (dt != null) {
                dataTypeName = dt.getName();
                mnemonic = dt.getMnemonic(null);
            }
            System.out.println(name + " = " + dataTypeName + " : " + mnemonic);
        }
    }

    Object computeBinaryValue(Object obj1, Token operation, Object obj2) {
        if (!(obj1 instanceof Long && obj2 instanceof Long)) {
            return null;
        }
        Long val1 = (Long) obj1;
        Long val2 = (Long) obj2;
        
        switch(operation.image) {
          case "<<":
          return val1 << val2;
          case ">>":
          return val1 >> val2;
          case "+":
          return val1 + val2;
          case "-":
          return val1 - val2;
          case "*":
          return val1 * val2;
          case "/":
          return val1 / val2;
          case "%":
          return val1 % val2;
          case "|":
          return val1 | val2;
          case "&":
          return val1 & val2;
          case "^":
          return val1 ^ val2;
          case "==":
          return (val1 == val2 ? 1 : 0);
          case "!=":
          return (val1 != val2 ? 1 : 0);
          case "<":
          return (val1 < val2 ? 1 : 0);
          case ">":
          return (val1 > val2 ? 1 : 0);
          case "<=":
          return (val1 <= val2 ? 1 : 0);
          case ">=":
          return (val1 >= val2 ? 1 : 0);
          case "&&":
          return ((val1 != 0 && val2 != 0) ? 1 : 0);
          case "||":
          return ((val1 != 0 || val2 != 0) ? 1 : 0);
        }
        return null;
    }

    Object computeUnaryValue(Object obj, Token operation) {
        if (!(obj instanceof Long)) {
            return null;
        }
        Long val = (Long) obj;
        
        switch(operation.image) {
          case "+":
          return val;
          case "-":
          return -val;
          case "~":
          return ~val;
          case "!":
          return (val != 0 ? 0 : 1);
        }
        return null;
    }

    Object computeTernaryValue(Object objTest, Object objTrue, Object objFalse) {
        if (!(objTest instanceof Long)) {
            return null;
        }

        Long testValue = (Long) objTest;
        return (testValue != 0 ? objTrue : objFalse);
    }
    

    /**
     * Get the data type manager
     * 
     * @return
     */
    public DataTypeManager getDataTypeManager() {
        return dtMgr;
    }

    /**
     * @return the last data type parsed
     */
    public DataType getLastDataType() {
        return lastDataType;
    }

    /**
     * Get Global variable declarations
     * 
     * @return
     */
    public Map<String, DataType> getDeclarations() {
        return declarations;
    }

    /**
     * Get Defined Enumerations
     * 
     * @return Defined enumeration names
     */
    public Map<String, DataType> getEnums() {
        return enums;
    }

    /**
     * Get Function signatures
     * 
     * @return Function signatures
     */
    public Map<String, DataType> getFunctions() {
        return functions;
    }

    /**
     * Get composite definitions
     * 
     * @return Composite (structure/union) definitions
     */
    public Map<String, DataType> getComposites() {
        return composites;
    }

    /**
     * Get Type definitions
     * 
     * @return Type definitions
     */
    public Map<String, DataType> getTypes() {
        return types;
    }

    public DataType parse(String str) throws ParseException {
        InputStream is = new ByteArrayInputStream(str.getBytes());

        parse(is);
        if (lastDataType != null && dtMgr != null) {
            // ensure that data-type sizing is relative to dtMgr's data organization 
            return lastDataType.clone(dtMgr);
        }
        return lastDataType;
    }

    public void parse(InputStream fis) throws ParseException {
        ReInit(fis);
        int transactionID = -1;
        String parseMessage;

        parseSuccess = false;
        try {
            transactionID = dtMgr.startTransaction("Parsing");
            TranslationUnit();
            parseSuccess = true;
        } catch (ParseException e) {
            if (headerFileName == null) {
                throw e;
            }
            
            long endLine = (e.currentToken != null ? e.currentToken.endLine : 0);
            long subLinenum = ((endLine - headerFileLineOffset) + headerFileLine);

            parseMessage = "C Parser:  Encountered errors during parse.\n";
            if (headerFileName != null) {
                parseMessage += "         in " + headerFileName + " near line " + subLinenum + "\n";
            }
            parseMessage += "Error: " + e.getMessage() + "\n";
            parseMessage += "         near token: " + e.currentToken + "\n";
            parseMessage += "Possibly Undefined : " + possiblyUndefinedType + "\n";  
            parseMessage += "         Last Valid Datatype: "
                    + (lastDataType == null ? "- none -" : lastDataType.getDisplayName()) + "\n";
            parseMessage += "         Check around " + parseFileName + " around line: "
                                    + this.jj_input_stream.getBeginLine() + "\n";
            ParseException parseException = new ParseException(parseMessage);
            parseException.currentToken = e.currentToken;
            throw parseException;
        } catch (Error e) {
            if (headerFileName == null) {
                throw e;
            }
            
            parseMessage = "C Parser:  Problem Parsing.\n";
            if (headerFileName != null) {
                parseMessage += "          in " + headerFileName + " near line " + headerFileLine + "\n";
            }
            parseMessage += "         Last Valid Datatype: "
                    + (lastDataType == null ? "- none -" : lastDataType.getDisplayName()) + "\n";
                            parseMessage += "         Check around " + parseFileName + " around line: "
                                    + this.jj_input_stream.getBeginLine() + "\n";
            Msg.warn(this, e, e);
            ParseException parseException = new ParseException(parseMessage);
            if (token != null) {
                parseException.currentToken = token;
            }
            throw parseException;
        } catch (Exception e) {
            parseMessage = "C Parser:  Problem Parsing.\n";
            if (headerFileName != null) {
                parseMessage += "          in " + headerFileName + " near line " + headerFileLine + "\n";
            }
            parseMessage += "         Last Valid Datatype: "
                    + (lastDataType == null ? "- none -" : lastDataType.getDisplayName()) + "\n";
            parseMessage += "         Check around " + parseFileName + " around line: "
                                    + this.jj_input_stream.getBeginLine() + "\n";
            Msg.warn(this, e, e);
            throw new ParseException(parseMessage);
        } finally {
            dtMgr.endTransaction(transactionID, true);
        }
    }

    public CParser() {
        this(System.in);
        dtMgr= new StandAloneDataTypeManager("parsed");
    }

    public CParser(DataTypeManager dtmgr) {
        this(dtmgr, false, null);
    }

    public CParser(DataTypeManager dtmgr, boolean storeDataType, DataTypeManager subDTMgrs[]) {
        this(System.in);
        this.dtMgr = dtmgr;
        if (subDTMgrs == null) {
            subDTMgrs = new DataTypeManager[0];
        }
        this.subDTMgrs = subDTMgrs;
        this.storeNewDT = storeDataType;
    }

        // Run the parser
    public static void main(String args[]) {
            CParser parser = new CParser();

        try {
            if (args.length == 0) {
                System.out.println("C Parser:  Reading from standard input . . .");
                parser.parse(System.in);
            } else if (args.length == 1) {
                System.out.println("C Parser:  Reading from file " + args[0] + " . . .");
                try {
                        parser.parse(new java.io.FileInputStream(args[0]));
                } catch (java.io.FileNotFoundException e) {
                        System.out.println("C Parser:  File " + args[0] + " not found.");
                        return;
                }
            } else {
                System.out.println("C Parser:  Usage is one of:");
                System.out.println("         java CParser < inputfile");
                System.out.println("OR");
                System.out.println("         java CParser inputfile");
                return;
            }

            System.out.println("C Parser:  Java program parsed successfully.");
        } catch (ParseException e) {
            System.out.println("C Parser:  Encountered errors during parse.");
        }
    }
    
    private static class EnumMember {
        final String name;
        final long value;
        EnumMember(String name, long value) {
            this.name = name;
            this.value = value;
        }
    }
    
}

PARSER_END(CParser)

TOKEN_MGR_DECLS :
{
    int parenNesting = 0;
}

SKIP :
{
    "\ufeff"   // BOM character at beginning of file
    |  
    " "
    |
    "\f" 
    |
    "\t" 
    |
    "\n" 
    |
    "\r"
    |
    "\\"
    |
    < 
        "//"
        ( ~[ "\n", "\r" ] )*
        ( "\n" | "\r" | "\r\n" )
    >
    |
    < 
        "/*"
        ( ~[ "*" ] )*
        "*"
        (
            "*"
            |
            ~[ "*", "/" ] ( ~[ "*" ] )* "*"
        )*
        "/"
    >
}

TOKEN :
{
    <INTEGER_LITERAL : 
        <DECIMAL_LITERAL> (  "ull" | "ULL" | "ul" | "UL" | "ll" | "LL" | "l" | "L" | "U" | "u")? ("i")? ( ["0"-"9"] )*
        |
        <HEX_LITERAL> ( "ull" | "ULL" | "ul" | "UL" | "ll" | "LL" | "l" | "L" | "U" | "u")? ("i")? ( ["0"-"9"] )*
        |
        <OCTAL_LITERAL> ( "ull" | "ULL" | "ul" | "UL" | "ll" | "LL" | "l" | "L" | "U" | "u")? ("i")? ( ["0"-"9"] )*
    >
    |
    <#DECIMAL_LITERAL : [ "1"-"9" ] ( [ "0"-"9" ] )*> 
    |
    <#HEX_LITERAL : "0" [ "x", "X" ] ( [ "0"-"9", "a"-"f", "A"-"F" ] )+> 
    |
    <#OCTAL_LITERAL : "0" ( [ "0"-"7" ] )*> 
    |
    <FLOATING_POINT_LITERAL : 
        ( [ "0"-"9" ] )+ "." ( [ "0"-"9" ] )* ( <EXPONENT> )? ( [ "f", "F", "d", "D" ] )?
        |
        "." ( [ "0"-"9" ] )+ ( <EXPONENT> )? ( [ "f", "F", "d", "D" ] )?
        |
        ( [ "0"-"9" ] )+ <EXPONENT> ( [ "f", "F", "d", "D" ] )?
        |
        ( [ "0"-"9" ] )+ ( <EXPONENT> )? [ "f", "F", "d", "D" ]
    >
    |
    <#EXPONENT : [ "e", "E" ] ( [ "+", "-" ] )? ( [ "0"-"9" ] )+> 
    |
    <CHARACTER_LITERAL : 
        ("L")?
        "\'"
        (
            ~[ "\'", "\\", "\n", "\r" ]
            |
            "\\"
            (
                [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]
                |
                [ "0"-"7" ] ( [ "0"-"7" ] )?
                |
                [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
            )
        )+
        "\'"
    >
    |
    <STRING_LITERAL : 
        ("L")?
        "\""
        (
            ~[ "\"", "\\", "\n", "\r" ]
            |
            "\\"
            (
                [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]
                |
                [ "0"-"7" ] ( [ "0"-"7" ] )?
                |
                [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
            )
        )*
        "\""
    >
}

TOKEN :
{
    <CONTINUE : "continue"> 
    |
    <VOLATILE : ( [ "_" ] )* "volatile" ( [ "_" ] )* > 
    |
    <REGISTER : "register"> 
    |
    <UNSIGNED : "unsigned"> 
    |
    <TYPEDEF : "typedef"> 
    |
    <DFLT : "default"> 
    |
    <DOUBLE : "double"> 
    |
    <SIZEOF : "sizeof"> 
    |
    <SWITCH : "switch"> 
    |
    <RETURN : "return"> 
    |
    <EXTERN : "extern"> 
    |
    <QUOTE_C : "\"C\"">
    |
    <STRUCT : "struct"> 
    |
    <STATIC : "static"> 
    |
    <THREADLOCAL : "_Thread_local">
    | 
    <SIGNED : ( [ "_" ] )* "signed"> 
    |
    <WHILE : "while"> 
    |
    <BREAK : "break"> 
    |
    <UNION : "union"> 
    |
    <CONST : ( [ "_" ] )* "const">
    |
    <DECLSPEC : "__declspec">
    |
    <PRAGMA : "#" "pragma"> {parenNesting=-1; SwitchTo(PRAGMALINE); }
    |
    <PRAGMA_FUNC : ("__pragma" | "_Pragma")> {parenNesting=0; SwitchTo(PRAGMALINE); }
    | 
    <READABLETO : "__readableTo">
    |
    <CDECL : ( [ "_" ] )+ "cdecl"> 
    |
    <STDCALL : ( [ "_" ] )+ "stdcall"> 
    |
    <FASTCALL : ( [ "_" ] )+ "fastcall"> 
    |
    <VECTORCALL : ( [ "_" ] )+ "vectorcall"> 
    |
    <RUSTCALL : ( [ "_" ] )+ "rustcall">
    |
    <PASCALCALL : ( [ "_" ] )+ "pascal">
    |
    <NORETURN : "_Noreturn" >
    |
    <ALIGNAS : "_Alignas" >
    |
    <ALIGNOF : "_Alignof" >
    |
    <UNALIGNED : "__unaligned" >
    |
    <PACKED : "__packed" >
    |
    <ATTRIBUTE : "__attribute" (["_"])* >
    |
    <EXTENSION : (["_"])+ "extension" (["_"])* >
    |
    <RESTRICT : (["_"])+ "restrict" >
    |
    <ASM : ( [ "_" ] )* "asm" ( [ "_" ] )*  >
    |
    <INLINE : ( [ "_" ] )* ("inline" | "forceinline") ( [ "_" ] )*>
    |
    <STATICASSERT : ("_S" | "s") "tatic_assert">
    |
    <FLOAT : "float"> 
    |
    <SHORT : "short"> 
    |
    <ELSE : "else"> 
    |
    <CASE : "case"> 
    |
    <LONG : "long">
    |
    <INT8 : "__int8">
    |
    <INT16 : "__int16">
    |
    <INT32 : "__int32">
    |
    <INT64 : "__int64">
    |
    <PTR64 : "__ptr64">
    |
    <PTR32 : "__ptr32">
    |
    <BOOL : "_Bool">
    |
    <W64 : "__w64">
    |
    <ENUM : "enum"> 
    |
    <AUTO : "auto"> 
    |
    <VOID : "void"> 
    |
    <CHAR : "char"> 
    |
    <GOTO : "goto"> 
    |
    <NEAR : "__near"> 
    |
    <FAR : "__far"> 
    |
    <FOR : "for"> 
    |
    <INT : "int"> 
    |
    <IF : "if"> 
    |
    <DO : "do">
    |
    <PROTOCOL : "@protocol"> : OBJC
    |
    <INTERFACE : "@interface"> : OBJC
    |
    <LINE : "#line">  : LINEBLOCK
    |
    <LINEALT : "#" ([" ", "\t"])+> : LINEBLOCK
}

TOKEN :
{
    <IDENTIFIER : <LETTER> ( <LETTER> | <DIGIT> )*> 
    |
    <#LETTER : [ "$", "A"-"Z", "_", "a"-"z" ]> 
    |
    <#DIGIT : [ "0"-"9" ]> 
}

<ASMBLOCK> SKIP:
{
    " " 
    |
    "\t"
}

<ASMBLOCK> TOKEN :
{
    <ASMBLOCKB : 
        (
            ( ~[ "{" , "}", ";" ] )+ ( ["\r","\n"] )+
        )
    > : ASMBLOCK
    |
    <ASMBLOCKP : 
        (
            ( ~[ "(", ")", ";" ] )+ ( ["\r","\n"] )+
        )
    > : ASMBLOCK
    |
    <ASM_SEMI : [ ";" ]> : DEFAULT
}

<LINEBLOCK> SKIP:
{
    " "
    |
    "\f" 
    |
    "\t" 
    |
    ":"
}

<LINEBLOCK> TOKEN:
{
    <PATH_LITERAL : 
        "\""
        (
            ~[ "\"", "\n", "\r" ]
        )*
        "\""
    >:DEFAULT
    |
    <LINENUMBER_LITERAL : [ "1"-"9" ] ( [ "0"-"9" ] )*> :LINEBLOCK
}

<PRAGMALINE> SKIP:
{
    " "
    |
    "\f" 
    |
    "\t"
    |
    "\n" : DEFAULT
    |
    "\r" : DEFAULT
    |
    ";" : DEFAULT
    |
    < 
        "//"
        ( ~[ "\n", "\r" ] )*
    >
    |
    < 
        "/*"
        ( ~[ "*" ] )*
        "*"
        (
            "*"
            |
            ~[ "*", "/" ] ( ~[ "*" ] )* "*"
        )*
        "/"
    >
}

<PRAGMALINE> TOKEN:
{
    <PIDENTIFIER : <PLETTER> ( <PLETTER> | <PDIGIT> )*> 
    |
    <#PLETTER : [ "$", "A"-"Z", "_", "a"-"z", ".", "#" ]> 
    |
    <#PDIGIT : [ "0"-"9" ]>
    |
    <POPEN : "("> { if (parenNesting != -1) parenNesting++; }
    |
    <PCLOSE : ")"> { if (parenNesting != -1) parenNesting--; if (parenNesting == 0) SwitchTo(DEFAULT); }
    |
    <PMINUS : "-">
    |
    <PPLUS : "+">
    |
    <PSTAR: "*">
    |
    <PCOLON : ":">
    |
    <PCOMMA : ",">
    |
    <PINTEGER_LITERAL : 
        <PDECIMAL_LITERAL> (  "ull" | "ULL" | "ul" | "UL" | "ll" | "LL" | "l" | "L" | "U" | "u")?
        |
        <PHEX_LITERAL> ( "ull" | "ULL" | "ul" | "UL" | "ll" | "LL" | "l" | "L" | "U" | "u")?
        |
        <POCTAL_LITERAL> ( "ull" | "ULL" | "ul" | "UL" | "ll" | "LL" | "l" | "L" | "U" | "u")?
    >
    |
    <#PDECIMAL_LITERAL : [ "1"-"9" ] ( [ "0"-"9" ] )*> 
    |
    <#PHEX_LITERAL : "0" [ "x", "X" ] ( [ "0"-"9", "a"-"f", "A"-"F" ] )+> 
    |
    <#POCTAL_LITERAL : "0" ( [ "0"-"7" ] )*> 
    |
    <PSTRING_LITERAL : 
        ("L")?
        "\""
        (
            ~[ "\"", "\\", "\n", "\r" ]
            |
            "\\"
            (
                [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]
                |
                [ "0"-"7" ] ( [ "0"-"7" ] )?
                |
                [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
            )
        )*
        "\""
    >
}

<OBJC> SKIP:
{
    " "
    |
    "\f" 
    |
    "\t"
    |
    "\n" : OBJC2
    |
    "\r" : OBJC2
}


<OBJC> TOKEN:
{
    <OBJC_IGNORE : ( ~[ "@", "$", "A"-"Z", "_", "a"-"z", "0"-"9", ";" ] ) > : OBJC
    |
    <OBJC_IDENTIFIER : ( <OBJC_LETTER> | <OBJC_DIGIT> )+> : OBJC
    |
    <#OBJC_LETTER : [ "$", "A"-"Z", "_", "a"-"z" ]>
    |
    <#OBJC_DIGIT : [ "0"-"9" ]>
    |
    <OBJC_SEMI : [ ";" ]> :DEFAULT
}

<OBJC2> SKIP:
{
    " "
    |
    "\f" 
    |
    "\t"
    |
    "\n"
    |
    "\r"
    |
    "@private"
    |
    "@protected"
    |
    "@property"
    |
    "@optional"
    |
    "@required"
}


<OBJC2> TOKEN:
{
    <OBJC2_IGNORE : ( ~[ "@" ] ) > : OBJC2
    |
    <OBJC2_END : "@end"> :DEFAULT
}

//jjt SimpleNode TranslationUnit() #TranslationUnit : {}
void TranslationUnit() : {}
{
    ( ExternalDeclaration() )+
    < EOF >
    {
        //jjt         return jjtThis;
    }
}

void ExternalDeclaration() : {}
{
    (
        LOOKAHEAD( FunctionDefinition() "{" )
          (FunctionDefinition() "{" [ StatementList() ] "}")
        |
//        <INLINE> FunctionDefinition() 
//        |
        Declaration()
        |
        PragmaSpec()
        |
        StaticAssert()
        |
        LineDef()
        |
        ";"
    )
    {
        if (monitor != null && monitor.isCancelled()) {
           throw new ParseException("Parsing Canceled");
        }
        typedefParsingStack.clear();
    }
}

void LineDef() : {
    Token lineTok, fileTok;
}
{
    (<LINE> | <LINEALT>)  ( lineTok= <LINENUMBER_LITERAL> )  ( fileTok= <PATH_LITERAL> ) [ (<INTEGER_LITERAL>)+ ]
    {
        headerFileName= fileTok.image.substring(1, fileTok.image.length() - 1);
        headerFileLine= Integer.parseInt(lineTok.image);
        headerFileLineOffset= lineTok.beginLine;
        currentCategoryName = getFileName(headerFileName);
    }
}

DataType ObjcDef() : {
    Token nameTok;
}
{
    ( nameTok=<OBJC_IDENTIFIER> ) ( <OBJC_IDENTIFIER> | <OBJC_IGNORE> | <OBJC2_IGNORE> )*  ( <OBJC_SEMI> | <OBJC2_END> )
    {
        return addTypedef(nameTok.image, resolveInternal(VoidDataType.dataType));
    }
}

void FunctionDefinition() : {
    Declaration retDT = new Declaration();
    Declaration dec = null;
}
{
    [
        LOOKAHEAD(DeclarationSpecifiers(retDT))
        retDT = DeclarationSpecifiers(retDT) 
    ]
    {typedefParsingStack.push(Boolean.FALSE);}
    dec= Declarator(retDT, null) [ DeclarationList() ] {typedefParsingStack.pop();}
    {
        if (dec.getDataType() instanceof FunctionDefinition) {
            addDef(functions, dec.getName(), dec.getDataType());
        }
    }
}

Declaration Declaration() : {
    Declaration dec = new Declaration();
    DataType dt = null;
}
{
    (
        dec = DeclarationSpecifiers(dec) [ InitDeclaratorList(dec) ] ";"
        |
        ( <PROTOCOL> | <INTERFACE> ) ( dt = ObjcDef() ) {
            dec.setDataType(dt);
        }
    )
    {
        return dec;
    }
}

void DeclarationList() : {}
{
    (
        LOOKAHEAD(Declaration())
        Declaration() 
    )+
}

Declaration DeclarationSpecifiers(Declaration specDT) : {
    Declaration typeDT= null;
}
{
    (    
        specDT = StorageClassSpecifier(specDT) 
        [
//            LOOKAHEAD(DeclarationSpecifiers(specDT))
            specDT= DeclarationSpecifiers(specDT) 
        ]
        |
        specDT = BuiltInDeclarationSpecifier(specDT)
        [
            LOOKAHEAD(TypeQualifierList(specDT))
            specDT = TypeQualifierList(specDT) 
        ]
        |
        specDT = TypeSpecifier(specDT)
        [
// I don't think this does anything useful.  Look into removing it.
            LOOKAHEAD(DeclarationSpecifiers(specDT) , { specDT.getDataType() == null } )
//            LOOKAHEAD(DeclarationSpecifiers()
//                     , { (typeDT == null ||
//                         (!typeDT.getName().equals(getToken(1).image) && !isType(getToken(1).image))) }
 //                     )
            specDT = DeclarationSpecifiers(specDT)
        ]
        |
        specDT = TypeQualifier(specDT) 
        [
            LOOKAHEAD(DeclarationSpecifiers(specDT))
            specDT = DeclarationSpecifiers(specDT) 
        ]
    )
    [ LOOKAHEAD(TypeQualifier(specDT))
      specDT = TypeQualifier(specDT) ]
    {
        if (specDT == null) {
            specDT = new Declaration(typeDT);
        }
        return specDT;
    }
}

Declaration StorageClassSpecifier(Declaration specDT) : {}
{
   // TODO: might want to set a storage classifier on DECL
    (
        <AUTO> 
        |
        <REGISTER> 
        |
        <STATIC>
        |
        <CONST> 
        |
        <THREADLOCAL>
        | 
        <EXTERN> [ MultiLineString() ]
        |
        <TYPEDEF> 
        {
            //            System.out.println("TYPEDEF! " + typedefParsingStack.size());
            typedefParsingStack.push(Boolean.TRUE);
        }
    )
    {
        return specDT;
    }
}


Declaration BuiltInTypeSpecifier(Declaration dec) : {
    DataType dt;
}
{
    (
        <VOID>                 { dec.setDataType(resolveInternal(VoidDataType.dataType)); }
        |
        <CHAR>                 {   dt = dec.getDataType();
                                if (dt != null) {
                                    if (dt == resolveInternal(UnsignedIntegerDataType.dataType)) {
                                         dt = resolveInternal(UnsignedCharDataType.dataType);
                                    } else if (dt == resolveInternal(IntegerDataType.dataType)) {
                                         dt = resolveInternal(CharDataType.dataType);
                                    } else {
                                         throw new ParseException("Bad datatype " + dt + " char");
                                    }
                                }
                                else {
                                    dt = resolveInternal(CharDataType.dataType);
                                }
                                dec.setDataType(dt);
                            }
        |
        <SHORT>             { dt = dec.getDataType();
                           if (dt == null) {
                               dt = resolveInternal(ShortDataType.dataType);
                           } else if (dt == resolveInternal(UnsignedIntegerDataType.dataType)) {
                               dt = resolveInternal(UnsignedShortDataType.dataType);
                           } else if (dt == resolveInternal(IntegerDataType.dataType)) {
                               dt = resolveInternal(ShortDataType.dataType);
                           } else {
                              throw new ParseException("Bad datatype " + dt + " short");
                           }
                           dec.setDataType(dt);
                         }
            [
                LOOKAHEAD(BuiltInDeclarationSpecifier(dec))
                dec = BuiltInDeclarationSpecifier(dec) 
            ]
        |
        <INT>                 { dt = dec.getDataType();
                               if (dt == null ) { 
                                 dec.setDataType(resolveInternal(IntegerDataType.dataType));
                               }
                             }
        |
        <LONG>                 { dt = dec.getDataType();
                              if ( dt == null) {
                                  dt = resolveInternal(LongDataType.dataType);
                              } else if ( dt == resolveInternal(UnsignedIntegerDataType.dataType)) {
                                  dt = resolveInternal(UnsignedLongDataType.dataType);
                              } else if (dt == resolveInternal(IntegerDataType.dataType)) {
                                 dt = resolveInternal(LongDataType.dataType);
                              } else if (dt == resolveInternal(LongDataType.dataType)) {
                                 dt = resolveInternal(LongLongDataType.dataType);
                              } else if (dt == resolveInternal(UnsignedLongDataType.dataType)) {
                                 dt = resolveInternal(UnsignedLongLongDataType.dataType);
                              } else {
                                 throw new ParseException("Bad datatype " + dt + " long");
                              }
                               dec.setDataType(dt);
                            }
            [
                LOOKAHEAD(BuiltInDeclarationSpecifier(dec))
                dec = BuiltInDeclarationSpecifier(dec) 
            ]                
        |
        <FLOAT>             { dt = dec.getDataType();
                          if ( dt == null) {
                              dt = resolveInternal(FloatDataType.dataType);
                          } else if ( dt == resolveInternal(LongDataType.dataType)) {
                              dt = resolveInternal(DoubleDataType.dataType);
                           } else {
                              throw new ParseException("Bad datatype " + dt + " long");
                          }
                          dec.setDataType(dt);
                         }
        |
        <DOUBLE>             { dec.setDataType(resolveInternal(DoubleDataType.dataType)); }
        |
        <SIGNED>            { dt = dec.getDataType();
                          if ( dt == null) {
                              dt = resolveInternal(IntegerDataType.dataType);
                          } else {
                              // data type already set, don't do anything?
                             dt = dt;
                          }
                          dec.setDataType(dt);
                         }
                           
            [
                LOOKAHEAD(BuiltInDeclarationSpecifier())
                dec = BuiltInDeclarationSpecifier(dec) 
            ]
        |
        <UNSIGNED>        {     dt = dec.getDataType();
                              if ( dt == null) {
                                  dt = resolveInternal(UnsignedIntegerDataType.dataType);
                              } else if (dt == resolveInternal(ShortDataType.dataType)) {
                                 dt = resolveInternal(UnsignedShortDataType.dataType);
                              } else if (dt == resolveInternal(LongDataType.dataType)) {
                                 dt = resolveInternal(UnsignedLongDataType.dataType);
                              } else if (dt == resolveInternal(LongLongDataType.dataType)) {
                                 dt = resolveInternal(UnsignedLongLongDataType.dataType);
                              } else {
                                 throw new ParseException("Bad datatype " + dt + " unsigned");
                              }
                              dec.setDataType(dt);
                         }
            [
                LOOKAHEAD(BuiltInDeclarationSpecifier())
                dec = BuiltInDeclarationSpecifier(dec) 
            ]
        |
        <INT8>              { dec.setDataType(resolveInternal(SignedByteDataType.dataType)); }
        |
        <INT16>             { dec.setDataType(resolveInternal(ShortDataType.dataType)); }
        |
        <INT32>             { dec.setDataType(resolveInternal(IntegerDataType.dataType)); }
        |
        <INT64>             { dec.setDataType(resolveInternal(LongLongDataType.dataType)); }
        |
        <BOOL>              { dec.setDataType(resolveInternal(BooleanDataType.dataType)); }
    )
    {
        return dec;
    }
}


Declaration BuiltInDeclarationSpecifier(Declaration dec) : {
    DataType dt= null;
}
{
    dec = BuiltInTypeSpecifier(dec)
    {
        return dec;
    }
}

Declaration TypeSpecifier(Declaration dec) : { DataType dt = null; }
{
    (
        dt= StructOrUnionSpecifier() 
        |
        dt= EnumSpecifier() 
        |
        LOOKAHEAD( { isType(getToken(1).image) } )
        dt= TypedefName() 
    )
    {
        dec.setDataType(dt);
        return dec;
    }
}

Declaration TypeQualifier(Declaration dec) : {}
{
    (
      <CONST>  { dec.addQualifier(CONST); } |
      <VOLATILE> |
      <CDECL> { dec.addQualifier(CDECL); } |
      <NEAR> |
      <FAR> |
      <STDCALL> { dec.addQualifier(STDCALL); } |
      <FASTCALL> { dec.addQualifier(FASTCALL); } |
      <VECTORCALL> { dec.addQualifier(VECTORCALL); } |
      <RUSTCALL> { dec.addQualifier(RUSTCALL); } |
      <PASCALCALL> { dec.addQualifier(PASCALCALL); } |
      <NORETURN> { dec.addQualifier(NORETURN); } |
      <W64> |
      <PTR64> |
      <PTR32> |
      <INLINE> |
      <RESTRICT> |
      <EXTENSION> |
      <STATIC> |
      <PACKED> |
      <UNALIGNED> |
      ( DeclSpec(dec) )
    )
    {
        return dec;
    }
}

void AttributeSpec(Declaration dec) : {}
{
      ( <ATTRIBUTE> ("(") SubIdent(dec) (")") ) |
      AsmStatement() |
      ( "[" "[" AttributeList(dec) "]" "]" ) |
      AlignmentSpecifier()

}

void AlignmentSpecifier() : { Declaration dt = new Declaration(); }
{
    < ALIGNAS > "(" ( TypeQualifier(dt) | AssignmentExpression() ) ")"
}

void AttributeList(Declaration dec) : { }
{
    AttributeToken(dec) [ ("," AttributeToken(dec))+ ]
}

void AttributeToken(Declaration dec) : { }
{
    ( < IDENTIFIER > | TypeQualifier(dec) ) [ ":" ":" ( < IDENTIFIER > | TypeQualifier(dec) ) ] [ "(" ( < IDENTIFIER > | Constant() ) [ ( ","  (< IDENTIFIER > | Constant()) )+ ] ")" ] 
}

void AttributeSpecList(Declaration dec) : {}
{
    ( AttributeSpec(dec) )+
}

void SubIdent(Declaration dec) : {
   Token id = null;
   Declaration dt = new Declaration();
}
{
    ( ( "(" [SubIdent(dec)] ")" ) |
      (id=<IDENTIFIER> | TypeQualifier(dec)) [ ( "(" [SubIdent(dt)] ")") | ("=" SubIdent(dt)) ]
                   [ "," 
                        SubIdent(dt)   
                       ] |            
      Constant() [ "," 
                        SubIdent(dt)   
                       ]
    )
    {
        if (id != null && "noreturn".equals(id.image.replace("_", ""))) {
            dec.addQualifier(NORETURN);
            if (dec.getDataType() instanceof FunctionDefinition) {
               applyFunctionQualifiers(dec, (FunctionDefinition) dec.getDataType());
            }
        }
    }
}

void DeclSpec(Declaration dec) : {
}
{
  ( ( <DECLSPEC> | <READABLETO> ) "(" DeclSpecifier(dec) ")" )  |
  AttributeSpecList(dec)
}

void DeclSpecifier(Declaration dec) : {
   Token id = null;
}
{
  "(" DeclSpecifier(dec) ")" |
      (id=<IDENTIFIER> { if (id != null && "noreturn".equals(id.image)) dec.addQualifier(NORETURN); } )+
                 [ "(" DeclConstant() ( DeclConstant() )* ")" ]
}

void DeclConstant() : {}
{
    <INTEGER_LITERAL> |
    <IDENTIFIER> [ ":" <INTEGER_LITERAL> ] |
    ( "#" | ":" | <IDENTIFIER> | "(" ")" |  MultiLineString() )
}

Token MultiLineString() : {
   Token t = null;
   Token r = null;
}
{
    (t = <STRING_LITERAL>
      {
        if (r == null) {
           r = t;
        } else {
    	  r.image = r.image.substring(0,r.image.length()) + t.image.substring(1);
        }
       }
      )+
    
    { return r; }
}

void PragmaSpec() : {
}
{
  <PRAGMA> (PragmaSpecifier())+ | 
  <PRAGMA_FUNC> PragmaSpecifier()
}

 

void PragmaSpecifier() : {
   Token id;
   Token ds1=null, ds2=null, ds3 = null;
}
{
  LOOKAHEAD(3)
  <POPEN> PragmaSpecifier() <PCLOSE> |
      id=<PIDENTIFIER> (<PIDENTIFIER> | <PINTEGER_LITERAL> | <PSTRING_LITERAL> | <PCOMMA> )*
          ([ <POPEN> [ (ds1=PragmaConstant())+ [ ( <PCOMMA> ds2=PragmaConstant() ) [ ( <PCOMMA> ds3=PragmaConstant() ) [ ( <PCOMMA> PragmaConstant() )+ ] ] ] ] <PCLOSE> ] ) 
  {
    if (id.image.equals("pack") && ds1 != null) {
        Token newPackVal = ds1;
        Token ID = ds2;
        if (ds1.image.equals("pop")) {
            // pop and set current value
            packSize = popPack(ID);
            newPackVal = null;
        }
        else if (ds1.image.equals("push") && ds2 != null) {
            try {
                // check if second arg is an integer
                int ival = Integer.parseInt(ds2.image);
                // if it is, the ID is default
                newPackVal = ds2;
                ID = null;
            }
            catch (NumberFormatException exc) {
                // if it is not, then second arg is an ID
                // and third arg is potentially a pack value
                newPackVal = ds3;
                ID = ds2;
            }
            pushPack(ID, packSize);
        }
        // set current pack value
        if (newPackVal != null) {
            int ival = packSize;
            try {
                // second arg may be an integer
                ival = Integer.parseInt(newPackVal.image);
            }
            catch (NumberFormatException exc) {
                // bad parse of number, just keep current pack size
            }
            packSize = ival;
        }
    } else if (id.image.equals("pack")) {
       packSize = 0;
    }
  }
  // ignore to EOL now.         
}

Token PragmaConstant() : {
  Token val = null;
}
{
  (
    val=<PINTEGER_LITERAL>
    |
    (<PSTAR> | <PPLUS> | <PMINUS> ) (PragmaConstant())*
    |
    ( <POPEN> (PragmaConstant())* <PCLOSE> )+
    |
    (
      (val=<PIDENTIFIER>) [ <PSTRING_LITERAL> | (<PCOLON> (<PINTEGER_LITERAL> | <PIDENTIFIER> )+ ) ]
    )
    |
    (
      val=<PSTRING_LITERAL> ( <PIDENTIFIER> [<POPEN> <PCLOSE>] <PSTRING_LITERAL> )*
    )
  )
  {
      return val;
  }
}

void StaticAssert() : {
  Object expr = null;
  Token t, message=null;
}
{
  ( ( t=<STATICASSERT> ) "(" expr=ConstantExpression() [ "," message=<STRING_LITERAL> ] ")" )
    {
        if (expr != null) {
          Integer evalue = getConstantValue(expr,1);
          if (evalue == 0) {
            String smessage = (message == null ? "" : message.image);
              addNearParseMessage("Static_Asssert has failed " + " \"" + smessage + "\"");
          }
        }
    }
}


DataType StructOrUnionSpecifier() : {
    Token t;
    Token parent;
    Token sname;
    Composite comp;
    Declaration dec = new Declaration();
}
{
    {
        typedefParsingStack.push(Boolean.FALSE);
        t= sname= null;
        parent = null;
    }
    comp= StructOrUnion() 
    (
        LOOKAHEAD(3)
        [ t= <IDENTIFIER>  [ ":" parent=<IDENTIFIER>]
              { comp=defineNamedComposite(t, null, comp); } // no parent yet, since there are no guts
        ] "{" [StructDeclarationList(comp)] "}" [ AttributeSpecList(dec) ]
        |
        sname= <IDENTIFIER> 
    )
    {
        if (t != null) {
            comp = defineNamedComposite(t, parent, comp);
        } else if (sname != null) {
            comp = defineForwardDeclaredComposite(sname, comp);
        }
        typedefParsingStack.pop();
        return comp;
    }
}

Composite StructOrUnion() : {
    Composite comp;
    Declaration dec = new Declaration();
}
{
    (
        <STRUCT> ( DeclSpec(dec) | PragmaSpec() )*
        {
            comp =  new StructureDataType(getCurrentCategoryPath(), ANONYMOUS_STRUCT_PREFIX + cnt++, 0, dtMgr);

            // Always set the packing, because by default structures should be aligned
            if (packSize > 0) {
                comp.setExplicitPackingValue(packSize);
            }
            else {
                comp.setPackingEnabled(true); // ensure default packing enabled
            }
                                   
        }
        |
        <UNION>  ( DeclSpec(dec) )* {
            comp = new UnionDataType(getCurrentCategoryPath(), ANONYMOUS_UNION_PREFIX  + cnt++, dtMgr); 
        
            // Always set the packing, because by default structures should be aligned
            if (packSize > 0) {
                comp.setExplicitPackingValue(packSize);
            } else {
                comp.setPackingEnabled(true); // ensure default packing enabled
            }
        }
    )
    {
        return comp;
    }
}

void StructDeclarationList(Composite comp) : {
    CompositeHandler compositeHandler = new CompositeHandler(comp);
}
{
    ( StructDeclaration(comp, compositeHandler) )+
}

void InitDeclaratorList(Declaration dt) : {
    Declaration initialDT = new Declaration(dt);
}
{
    InitDeclarator(dt) 
    ( "," { dt = new Declaration(initialDT); } InitDeclarator(dt) )* 
    {
        // Finished with a typedefDeclaration??
        if (!(typedefParsingStack.empty()) && (typedefParsingStack.peek()).booleanValue()) {
            typedefParsingStack.pop();
        }
    }
}

void InitDeclarator(Declaration dt) : { Declaration dec; }
{
    dec = Declarator(dt, null) [ "=" Initializer() ] 
    {
        if (!(typedefParsingStack.empty()) && (typedefParsingStack.peek()).booleanValue()) {
            addTypedef(dec.getName(), dec.getDataType());
        } else {
            if (dt.getDataType() instanceof FunctionDefinition) {
                addDef(functions, dec.getName(), dec.getDataType());
            }
        }
    }
}

void StructDeclaration(Composite comp, CompositeHandler compositeHandler) : {
    Declaration dt = null;
    Declaration dec = new Declaration();
}
{
    LineDef() |
    StaticAssert() |
    PragmaSpec() |
    (   
        [ dt = SpecifierQualifierList() ]
        [
            StructDeclaratorList(dt, comp, compositeHandler)     { dt= null; }
        ]
        [ AttributeSpecList(dec) ]
        ";" 
    )
    {
        if (dt != null) { // dt was not used up
            if (dt.getDataType().getLength() > 0) {
                comp.add(dt.getDataType(), "", null);
            } else {
                addNearParseMessage("BAD data type struct size  " + dt);
            }
        }
    }
}

Declaration SpecifierQualifierList() : {
    Declaration dt = new Declaration();
    Declaration sdt= null;
}
{
    (
        (
            dt = BuiltInDeclarationSpecifier(dt) 
            [
                LOOKAHEAD(TypeQualifierList(dt))
                dt = TypeQualifierList(dt) 
            ]
        )
        |
        (
            dt = TypeSpecifier(dt) 
            [
                LOOKAHEAD(SpecifierQualifierList() , { dt == null || dt.getDataType() == null } )
                sdt = SpecifierQualifierList()
            ]
            [
                sdt = TypeQualifier(sdt != null ? sdt : dt)
            ]
        )
        |
        (
            dt = TypeQualifier(dt) 
            [
                LOOKAHEAD(SpecifierQualifierList())
                sdt = SpecifierQualifierList() 
            ]
        )
    )
    {
        if (sdt == null) {
            dataTypeStack.push(dt.getDataType());
            return dt;
        }
        return sdt;
    }
}

void StructDeclaratorList(Declaration dt, Composite comp, CompositeHandler compositeHandler) : {
}
{
    StructDeclarator(dt, comp, compositeHandler) ( "," StructDeclarator(dt, comp, compositeHandler) )*
}


void StructDeclarator(Declaration dt, Composite comp, CompositeHandler compositeHandler) : {
    Declaration dec= null;
    Object bitSizeObj;
}
{
    LineDef() |
    StaticAssert() |
    (
        LOOKAHEAD(3)
        dec= Declarator(dt, comp) [ ":" bitSizeObj = ConstantExpression() {
               Integer bitSize = getConstantValue(bitSizeObj,-1);
               dec.setBitFieldSize(bitSize);
           }] 
        |
        ":" bitSizeObj = ConstantExpression() {
               Integer bitSize = getConstantValue(bitSizeObj,-1);
               dec = new Declaration(dt);
               dec.setBitFieldSize(bitSize);
        }
    )
    {
        try {
            compositeHandler.add(dec);
        } catch (IllegalArgumentException e) {
            addNearParseMessage("Bad structure size " + dec.getName() + "  length=" + dec.getDataType().getLength());
        }
    }
}

DataType EnumSpecifier() : {
    Token t= null;
    DataType dt;
    ArrayList<EnumMember> list;
    Declaration dec = new Declaration();
}
{
    <ENUM> 
    (
        LOOKAHEAD(3)
        [AttributeSpecList(dec)] [ t= <IDENTIFIER> ] "{" list= EnumeratorList() "}" 
        {
            dt = allocateEnumDT(t, list);
        }
        |
        t= <IDENTIFIER>
        {
            dt= getEnumDef(t.image);
            // not defined yet, define an empty one
            if (dt == null) {
            	dt = allocateEnumDT(t, null);
            }
        }
    )
    {
        return dt;
    }
}

ArrayList<EnumMember> EnumeratorList() : {
    int value= 0;
    ArrayList<EnumMember> list= new ArrayList<EnumMember>();
}
{
    (
        LineDef() |
        PragmaSpec() |
        StaticAssert() |
        value= Enumerator(list, value) [ "," ]     { value++; }
    )*
    {
        return list;
    }
}

int Enumerator(ArrayList<EnumMember> list, int value) : {
    Token t = null;
    Object obj = null;
    Integer evalue;
}
{
    t = <IDENTIFIER> [ "=" obj = ConstantExpression() ] 
    {
        evalue = getConstantValue(obj,value);
        if (evalue != null) {
            value = evalue;
        }
        list.add(new EnumMember(t.image, value));
        return value;
    }
    |
    t = <INTEGER_LITERAL> [ "=" obj = ConstantExpression() ]
    {
        evalue = getConstantValue(obj,value);
        if (evalue != null) {
            value = evalue;
        }
        list.add(new EnumMember(t.image, value));
        return value;
    }
}

Declaration Declarator(Declaration dt, DataType container) : {
    Declaration dec= null;
}
{
    (
        [ dt = TypeQualifierList(dt) ]  [ dt = Pointer(dt) ] dec= DirectDeclarator(dt, container) [ AttributeSpecList(dec) ] 
    )
    {
        return dec;
    }
}

Declaration DirectDeclarator(Declaration dt, DataType container) : {
    Token t;
    Declaration dec= null;
    Declaration funcDec= null;
    FunctionDefinitionDataType funcDT= null;
    Object obj = null;
    ArrayList list = new ArrayList();
}
{
    [ PragmaSpec() ]
    (
        (
            t= <IDENTIFIER>        { dec= new Declaration(dt, t.image); }
            |
            "(" dec= Declarator(new Declaration(funcDT=newAnonymousFunction(funcDT)), null) ")" 
            {
                // System.out.println(" ( func dec ) " + dec.getName() + "   " + dec.getDataType());
            }
        )
        { lastDataType = dec.getDataType(); }
        (
            (
                "[" [ obj = ConditionalExpression() ] "]" 
                {
                    // make a new array given value on constant expression
                    Integer size = getConstantValue(obj, 0);
                    if (size == null) {
                        System.out.println("BAD ARRAY SIZE! " + obj);
                        size = 0;
                    }
                    list.add(0,size);
                }
            )*
        )
        {
            if (list.size() > 0) {
            dec.setDataType(dt.getDataType());
            for (Iterator iterator = list.iterator(); iterator.hasNext();) {
                Integer iSize = (Integer) iterator.next();
                DataType decDt = dec.getDataType();
                dec.setDataType(new ArrayDataType(decDt, iSize, decDt.getLength()));
            }
            //System.out.println("Array expr: for " + dec.getName() + " make an array " + dt.getName() + "["+size+"]");
            }
        }
        
        (
            LOOKAHEAD(3)
            "(" funcDec= ParameterTypeList(funcDT=newAnonymousFunction(funcDT), dt.getDataType()) ")" 
            {
                //System.out.println(
                //    "Param list: for " + dec.getName() + " make a function " + dt.getName());
            }
            |
            "(" [ IdentifierList(funcDT=newAnonymousFunction(funcDT), dt.getDataType()) ] ")" 
            {
                //System.out.println(
                //    "ID List: for " + dec.getName() + " make a function " + dt.getName());
                funcDec= new Declaration(funcDT=newAnonymousFunction(funcDT), "__paramIDList__");
            }
        )*
    )
    {
        if (funcDec != null) {
            try {
              // functions in containers stay anonymous
              if (container == null) { 
                funcDT.setName(dec.getName());
              }
                funcDec.setName(dec.getName());
                if (dec.getDataType() != null) {
                    funcDec.setDataType(dec.getDataType());
                }
            } catch (InvalidNameException e) {
                throw new ParseException("duplicate name " + dec.getName());
            }
            DataType retDT = dt.getDataType();
            checkReturnDataType(retDT);
            funcDT.setReturnType(retDT);
            // get qualifiers and apply them
            applyFunctionQualifiers(dt, funcDT);
            dec= funcDec;
            defineAndReplaceFunction(dec, funcDT);
        }

        return dec;
    }
}

Declaration Pointer(Declaration dec) : {}
{
    ("*" | "&") [ dec = TypeQualifierList(dec) ] [ dec = Pointer(dec) ] 
    {
        // TODO: is this right?
        dec.setDataType(dtMgr.getPointer(dec.getDataType()));
        return dec;
    }
}

Declaration TypeQualifierList(Declaration dec) : {}
{
    ( dec = TypeQualifier(dec) )+
    {
        return dec;
    }
}

Declaration ParameterTypeList(FunctionDefinitionDataType funcDT, DataType retDT) : {
    ArrayList<Declaration> list;
    Token varargs= null;
}
{
    list= ParameterList() [ "," varargs = "..." ] 
    {
        checkReturnDataType(retDT);
        if (funcDT == null) {
            funcDT= new FunctionDefinitionDataType(getCurrentCategoryPath("functions"), ANONYMOUS_FUNC_PREFIX, dtMgr);
        }
        funcDT.setVarArgs(varargs!=null);
        Declaration firstDeclaration = null;
        ParameterDefinition[] variables= new ParameterDefinition[list.size()];
        if (variables.length == 1) {
            firstDeclaration = list.get(0);
        }
        for (int i= 0; i < variables.length; i++) {
            Declaration dec= list.get(i);
            DataType varDT = dec.getDataType();

            // if this is a single void parameter, empty the parameter variable list
            //
            if (variables.length == 1 && varDT instanceof VoidDataType) {
                variables = new ParameterDefinition[0];
                break;
            }
            variables[i] = new ParameterDefinitionImpl(dec.getName(), dec.getDataType(), null);
        }
        funcDT.setReturnType(retDT);
        funcDT.setArguments(variables);
        Declaration dec = new Declaration(funcDT);
        if (firstDeclaration != null) {
            dec.addQualifiers(firstDeclaration);
        }
        return dec;
    }
}

ArrayList<Declaration> ParameterList() : {
    ArrayList<Declaration> list= new ArrayList<Declaration>();
}
{
    ParameterDeclaration(list) 
    (
        LOOKAHEAD(2)
         "," ParameterDeclaration(list)
    )*
    {
        return list;
    }
}

void ParameterDeclaration(ArrayList<Declaration> list) : {
    Declaration dt = new Declaration();
    Declaration dec= new Declaration();
}
{

    dt = DeclarationSpecifiers(dec) 
    (
        LOOKAHEAD(Declarator(dt))
        dec= Declarator(dt, null) 
        |
        [ dec = AbstractDeclarator(dt) ] 
    )  [ "=" <INTEGER_LITERAL > ] [PragmaSpec()]
    {
        if (dec == null) {
            dec = new Declaration(dt);
        }
        DataType decDT = dec.getDataType();
        if (decDT != null) {
            if (decDT.getLength() < 0  && !((decDT instanceof FunctionDefinition) || (decDT instanceof TypeDef && (((TypeDef) decDT).getDataType() instanceof FunctionDefinition)))) {
            // if (decDT.getLength() < 0  && !(decDT instanceof FunctionDefinitionDataType)) {
               throw new ParseException("'"+decDT.getName()+"'" + " is not fixed length.  Function parameters must use fixed length data type.");
            } else {
               list.add(dec);
            }
        }
    }
}

void IdentifierList(FunctionDefinitionDataType funcDT, DataType retDT) : {
    Token t;
}
{
    {
        ArrayList<String> list= new ArrayList<String>();
    }
    t= <IDENTIFIER>                 { list.add(t.image); }
    (
        "," t= <IDENTIFIER>             { list.add(t.image); }
    )*
    {
        checkReturnDataType(retDT);
        ParameterDefinition[] variables= new ParameterDefinition[list.size()];
        for (int i= 0; i < variables.length; i++) {
            // TODO need a data type
            variables[i] = new ParameterDefinitionImpl(list.get(i), null, null);
        }
        funcDT.setReturnType(retDT);
        funcDT.setArguments(variables);
    }
}

void Initializer() : {}
{
    ( AssignmentExpression() | "{" InitializerList() [ "," ]  "}" )
}

void InitializerList() : {}
{
    [ Designation() ] Initializer() [ "," InitializerList() ]
}

void Designation() : { }
{
  DesignatorList() "="
}

void DesignatorList() : { }
{
  Designator() [ DesignatorList() ]
}

void Designator() : { }
{
  "[" ConstantExpression() "]" |
  "." <IDENTIFIER>
}

Declaration TypeName() : {
    Declaration dec = null;
}
{
    dec = SpecifierQualifierList() [ dec = AbstractDeclarator(new Declaration(dec)) ]
    {
       return dec;
    }
}

Declaration AbstractDeclarator(Declaration dt) : {
    Declaration dec= null;
}
{
    (
        LOOKAHEAD(3)
        dec = DirectAbstractDeclarator(dt) { return dec; } |
        dt = Pointer(dt) [dec= DirectAbstractDeclarator(dt) { return dec; }]
    )
    { return new Declaration(dt); }
}

Declaration DirectAbstractDeclarator(Declaration dt) : {
    Declaration dec= dt;
    Declaration paramDec= null;
    FunctionDefinitionDataType funcDT = null;
    Object constObj = null;
    ArrayList list = new ArrayList();
}
{
    (
        LOOKAHEAD(2)
        "(" { funcDT = newAnonymousFunction(null); dec = new Declaration(funcDT); } dec = AbstractDeclarator(dec) ")" 
        |
        "[" [ constObj = ConstantExpression() ] "]"
        {
           // TODO: create an array
           Integer size = getConstantValue(constObj, 0);
           list.add(0,size);
        }
        |
        "(" [ { funcDT = newAnonymousFunction(null); } dec= ParameterTypeList(funcDT, dt.getDataType()) ] ")"
        {
          funcDT = (FunctionDefinitionDataType) dec.getDataType();
          dec.setDataType(dtMgr.getPointer(funcDT));
        }
    )

    (
        (
            "[" [ constObj = ConstantExpression() ] "]"
            {
              // TODO: create an array
               Integer size = getConstantValue(constObj, 0);
               list.add(0,size);
            }
        ) *
    )
    {
        if (list.size() > 0) {
            for (Iterator iterator = list.iterator(); iterator.hasNext();) {
                Integer iSize = (Integer) iterator.next();
                DataType decDt = dec.getDataType();
                dec.setDataType(new ArrayDataType(decDt, iSize, decDt.getLength()));
            }
        }
    }
   
    ( "(" [ paramDec = ParameterTypeList(funcDT, dt.getDataType()) ] ")"
        {
           dec = (funcDT != null ? dec : paramDec);
        }
    )*
    {
        if (funcDT != null) {
            // get qualifiers and apply them
            List<Integer> dtQualifiers = dt.getQualifiers();
            if (dtQualifiers == null || dtQualifiers.isEmpty()) {
                dt = dec;
            }
            applyFunctionQualifiers(dt, funcDT);
            defineAndReplaceFunction(dec, funcDT);
        }
        return dec;
    }
}

DataType TypedefName() : {
    Token t;
}
{
    t= <IDENTIFIER> 
    {
        return getType(t.image);
    }
}

void Statement() : {}
{
    (
        LOOKAHEAD(2)
        AsmStatement()
        |
        LOOKAHEAD(3)
        DeclarationList()
        |
        LOOKAHEAD(2)
        LabeledStatement() 
        |
        ExpressionStatement() 
        |
        CompoundStatement() 
        |
        SelectionStatement() 
        |
        IterationStatement() 
        |
        JumpStatement() 
        |
        AsmStatement()
        |
        PragmaSpec()
        |
        StaticAssert()
    )
}

void LabeledStatement() : {}
{
    ( <IDENTIFIER> ":" Statement() | <CASE> ConstantExpression() ":" Statement() | <DFLT> ":" Statement() )
}

void ExpressionStatement() : {}
{
    [ Expression() ] ";"
}

void CompoundStatement() : {}
{
    "{" 
//    [
//        LOOKAHEAD(DeclarationList())
//        DeclarationList() 
//    ]
    [ StatementList() ] "}" 
}

void StatementList() : {}
{
    ( LineDef() |
      Statement() )+
}


void AsmStatement() :
{
   Declaration dec = new Declaration();
}
{
  (
    <ASM> [TypeQualifier(dec)]
    (
      ( AsmLine() )
    )
  )
}

void AsmLine() :
{
    Declaration dec = new Declaration();
}
{
  (<IDENTIFIER> | <STRING_LITERAL> | <INTEGER_LITERAL> | <ATTRIBUTE> | BuiltInTypeSpecifier(dec) | "#" | "+" | "-" | "," | ":" | "*" | ("[" AsmLine() "]") | ( "(" AsmLine() ")" ) | ( "{" AsmLine() "}" ) )+
}


void SelectionStatement() : {}
{
    (
        <IF> "(" Expression() ")" Statement() 
        [
            LOOKAHEAD(2)
            <ELSE> Statement() 
        ]
        |
        <SWITCH> "(" Expression() ")" Statement() 
    )
}

void IterationStatement() : {}
{
    (
        <WHILE> "(" Expression() ")" Statement() 
        |
        <DO> Statement() <WHILE> "(" Expression() ")" ";" 
        |
        <FOR> "(" [ Expression() ] ";" [ Expression() ] ";" [ Expression() ] ")" Statement() 
    )
}

void JumpStatement() : {}
{
    ( <GOTO> <IDENTIFIER> ";" | <CONTINUE> ";" | <BREAK> ";" | <RETURN> [ Expression() ] ";" )
}

Object Expression() : {
   Object obj = null;
}
{
    obj = AssignmentExpression() ( "," obj = AssignmentExpression() )*
    {
        return obj;
    }
}

Object AssignmentExpression() : {
   Object obj = null;
}
{
    ( LOOKAHEAD(UnaryExpression() AssignmentOperator())
       UnaryExpression() AssignmentOperator() obj=AssignmentExpression() 
      |
      LOOKAHEAD(3)
      obj = ConditionalExpression()
    ) [ PragmaSpec() ]
    {
        return obj;
    }
}

void AssignmentOperator() : {}
{
    ( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" )
}

Object ConditionalExpression() : {
    Object obj = null;
    Object objTrue = null, objFalse = null;
}
{
    obj = LogicalORExpression() [ "?" objTrue=Expression() ":" objFalse=ConditionalExpression() { obj = computeTernaryValue(obj, objTrue, objFalse); } ]
    {
        return obj;
    }
}

Object ConstantExpression() : {
    Object obj = null;
}
{
    obj = ConditionalExpression()
    {
        return obj;
    }
}

Object LogicalORExpression() : {
   Object obj = null, obj2 = null; Token op=null;
}
{
    obj = LogicalANDExpression() ( op="||" obj2 = LogicalANDExpression() { obj = computeBinaryValue(obj, op, obj2); } ) *
    {
        return obj;
    }
}

Object LogicalANDExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = InclusiveORExpression() ( op="&&" obj2=InclusiveORExpression() { obj = computeBinaryValue(obj, op, obj2); } ) *
    {
        return obj;
    }
}

Object InclusiveORExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = ExclusiveORExpression() ( op="|" obj2=ExclusiveORExpression() { obj = computeBinaryValue(obj, op, obj2); } ) *
    {
        return obj;
    }
}

Object ExclusiveORExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = ANDExpression() ( op="^" obj2=ANDExpression() { obj = computeBinaryValue(obj, op, obj2); } ) *
    {
        return obj;
    }
}

Object ANDExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = EqualityExpression() ( op="&" obj2=EqualityExpression() { obj = computeBinaryValue(obj, op, obj2); } ) *
    {
        return obj;
    }
}

Object EqualityExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = RelationalExpression()
    (
      (op="=="  | op="!=") obj2 = RelationalExpression() { obj = computeBinaryValue(obj, op, obj2); }   ) *
    {
        return obj;
    }
}

Object RelationalExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = ShiftExpression()
    (
      (op="<" | op=">" | op="<=" | op=">=") obj2=ShiftExpression() { obj = computeBinaryValue(obj, op, obj2); }
    ) *
    {
        return obj;
    }
}

Object ShiftExpression() : {
   Object obj = null, obj2 = null; Token op=null;
}
{
    obj = AdditiveExpression()
    (
     ( op="<<" | op=">>" ) obj2 = AdditiveExpression()
       { obj = computeBinaryValue(obj, op, obj2); }
    ) *
    {
        return obj;
    }
}

Object AdditiveExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = MultiplicativeExpression()
    ( ( op="+" | op="-" ) obj2 = MultiplicativeExpression()
      { obj = computeBinaryValue(obj, op, obj2); }
    ) *
    {
        return obj;
    }
}

Object MultiplicativeExpression() : {
    Object obj = null, obj2 = null; Token op=null;
}
{
    obj = CastExpression()
    ( ( op="*" | op="/" | op="%" ) obj2 = CastExpression()
      { obj = computeBinaryValue(obj, op, obj2); }
    ) *
    {
        return obj;
    }
}

Object CastExpression() : {
    Object obj = null;
}
{
    (
        LOOKAHEAD("(" TypeName() ")")
        (
           "(" TypeName() ")" ( obj = CastExpression() |
                   ( "{" InitializerList() [ "," ] "}" ) )
        )
        |
        obj = UnaryExpression() 
    )
    {
        return obj;
    }
}

Object UnaryExpression() : {
     Object obj = null;
     Token op = null;
     Declaration dec = null;
}
{
    (
        LOOKAHEAD(3)
        obj = PostfixExpression()
        |
        UnaryOperator() CastExpression()
        |
        "++" UnaryExpression() 
        |
        "--" UnaryExpression() 
        |
        "+" obj=CastExpression()
        |
        op="-" obj=CastExpression() { obj = computeUnaryValue(obj, op); }
        |
        op="~" obj=CastExpression() { obj = computeUnaryValue(obj, op); }
        |
        op="!" obj=CastExpression() { obj = computeUnaryValue(obj, op); }
        | 
        <SIZEOF> 
        (
            "(" ( dec = TypeName() | obj = UnaryExpression() ) ")"
            {
                if (obj != null && obj instanceof String) {
                    obj = Long.valueOf(((String) obj).length() - 1); // will include "" plus \0
                }
                else if (dec != null) {
                    obj = Long.valueOf(dec.getDataType().clone(dtMgr).getLength());
                }
                else if (obj != null) {
                   // TODO: try to look up the type of the identifier
                   // TODO: Throw error if identifier is not defined
                   //       may need to actually track declarations!
                }
            }
        )
        | 
        <ALIGNOF> 
        (
            "(" ( dec = TypeName() ) ")"
            {
                // TODO: if data types can have alignment, replace with alignment of the data type
            }
        )
    )
    {
        return obj;
    }
}

void UnaryOperator() : { }
{
    (
    "&"
    |
    "*"
    )
}

Object PostfixExpression() : {
     Object obj = null;
}
{
    obj = PrimaryExpression() 
    (
        ( "[" Expression() "]" )
        |
        "(" 
        [
            LOOKAHEAD(ArgumentExpressionList() )
            ArgumentExpressionList() 
        ]
        ")"
        |
        "." <IDENTIFIER> 
        |
        "->" <IDENTIFIER> 
        |
        "++" 
        |
        "--"      
    )*
    {
        return obj;
    }
}

Object PrimaryExpression() : {
    Object obj = null;
}
{
    ( obj = <IDENTIFIER> |
      obj = Constant() |
      "(" obj = Expression() ")" )
    {
        return obj;
    }
}

void ArgumentExpressionList() : {}
{
    [ PragmaSpec() ] AssignmentExpression() (  "," [ PragmaSpec() ] AssignmentExpression() )* [ PragmaSpec() ]
}

Object Constant() : {
    Token t;
    Object obj= null;
}
{
    (
        t = <INTEGER_LITERAL>
        {
            String sval = t.image;
            if (sval.endsWith("i8") || sval.endsWith("I8")) {
                sval = sval.substring(0,sval.length()-2);
            }
            else if (sval.endsWith("i16") || sval.endsWith("I16")) {
                sval = sval.substring(0,sval.length()-3);
            }
            else if (sval.endsWith("i32") || sval.endsWith("I32")) {
                sval = sval.substring(0,sval.length()-3);
            }
            else if (sval.endsWith("i64") || sval.endsWith("I64")) {
                sval = sval.substring(0,sval.length()-3);
            }
            
            if (sval.endsWith("ull") || sval.endsWith("ULL")) {
                sval = sval.substring(0,sval.length()-3);
            }
            else if (sval.endsWith("ll") || sval.endsWith("LL")) {
                sval = sval.substring(0,sval.length()-2);
            }
            else if (sval.endsWith("ul") || sval.endsWith("UL")) {
                sval = sval.substring(0,sval.length()-2);
            }
            else if (sval.endsWith("l") || sval.endsWith("L")) {
                sval = sval.substring(0,sval.length()-1);
            }
            else if (sval.endsWith("u") || sval.endsWith("U")) {
                sval = sval.substring(0,sval.length()-1);
            }
            if (sval.startsWith("0x") || sval.startsWith("0X")) {
                BigInteger bigConst = new BigInteger(sval.substring(2), 16);           
                obj = Long.valueOf(bigConst.longValue());
            }
            else {
                BigInteger bigConst = new BigInteger(sval);           
                obj = Long.valueOf(bigConst.longValue());
            }
        }
        |
        t = <FLOATING_POINT_LITERAL>
        {
            obj = new Double(t.image);
        }
        |
        t = <CHARACTER_LITERAL>
        {
            if (t.image.length() == 1) {
              obj = new Character(t.image.charAt(0));
            } else if (t.image.length() == 4) {
              long cval = ((long)t.image.charAt(0) << 24) + ((long)t.image.charAt(1) << 16) + ((long)t.image.charAt(2) << 8) + ((long) t.image.charAt(3));
              obj = Long.valueOf(cval);
            }
        }
        |
        t = MultiLineString()
        {
            obj = t.image;
        }
    )
    {
        return obj;
    }
}
